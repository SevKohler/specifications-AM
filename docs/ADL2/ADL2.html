<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="description" content="openEHR Archetype Defnition Language (AOM2) specification">
<meta name="keywords" content="archetype, openehr, aom, aom2">
<title>Archetype Defnition Language (ADL2) specification</title>
<link rel="stylesheet" href="../../../spec-publish-asciidoc/resources/css/openehr.css">
<link rel="stylesheet" href="../../../spec-publish-asciidoc/resources/css/pygments-murphy.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#_archetype_defnition_language_adl2_specification">Archetype Defnition Language (ADL2) specification</a>
<ul class="sectlevel1">
<li><a href="#_amendment_record">Amendment Record</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a>
<ul class="sectlevel2">
<li><a href="#_primary_author">Primary Author</a></li>
<li><a href="#_contributors">Contributors</a></li>
<li><a href="#_trademarks">Trademarks</a></li>
<li><a href="#_supporters">Supporters</a></li>
</ul>
</li>
<li><a href="#_introduction">1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#_purpose">1.1. Purpose</a></li>
<li><a href="#_related_documents">1.2. Related Documents</a></li>
<li><a href="#_nomenclature">1.3. Nomenclature</a></li>
<li><a href="#_status">1.4. Status</a></li>
<li><a href="#_tools">1.5. Tools</a></li>
<li><a href="#_changes_from_previous_versions">1.6. Changes from Previous Versions</a>
<ul class="sectlevel3">
<li><a href="#_dadl_odin">1.6.1. dADL (ODIN)</a></li>
<li><a href="#_adl_2_0">1.6.2. ADL 2.0</a>
<ul class="sectlevel4">
<li><a href="#_changes">Changes</a></li>
<li><a href="#_backward_compatibility">Backward Compatibility</a></li>
</ul>
</li>
<li><a href="#_adl_1_5">1.6.3. ADL 1.5</a>
<ul class="sectlevel4">
<li><a href="#_changes_2">Changes</a></li>
</ul>
</li>
<li><a href="#_adl_1_4">1.6.4. ADL 1.4</a>
<ul class="sectlevel4">
<li><a href="#_iso_8601_date_time_conformance">ISO 8601 Date/Time Conformance</a></li>
<li><a href="#_non_inclusive_two_sided_intervals">Non-inclusive Two-sided Intervals</a></li>
<li><a href="#_occurrences_for_use_node_references">Occurrences for ‘use_node’ References</a></li>
<li><a href="#_quoting_rules">Quoting Rules</a></li>
</ul>
</li>
<li><a href="#_adl_1_3">1.6.5. ADL 1.3</a>
<ul class="sectlevel4">
<li><a href="#_query_syntax_replaced_by_uri_data_type">Query syntax replaced by URI data type</a></li>
<li><a href="#_top_level_invariant_section">Top-level Invariant Section</a></li>
</ul>
</li>
<li><a href="#_adl_1_2">1.6.6. ADL 1.2</a>
<ul class="sectlevel4">
<li><a href="#_adl_version">ADL Version</a></li>
<li><a href="#_dadl_odin_syntax_changes">dADL (ODIN) Syntax Changes</a></li>
<li><a href="#_revision_history_section">Revision History Section</a></li>
<li><a href="#_primary_language_and_languages_available_sections">Primary_language and Languages_available Sections</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_overview">2. Overview</a>
<ul class="sectlevel2">
<li><a href="#_an_example">2.1. An Example</a></li>
</ul>
</li>
<li><a href="#_file_encoding_and_character_quoting">3. File Encoding and Character Quoting</a>
<ul class="sectlevel2">
<li><a href="#_file_encoding">3.1. File Encoding</a></li>
<li><a href="#_special_character_sequences">3.2. Special Character Sequences</a></li>
</ul>
</li>
<li><a href="#_cadl_constraint_adl">4. cADL - Constraint ADL</a>
<ul class="sectlevel2">
<li><a href="#_overview_2">4.1. Overview</a></li>
<li><a href="#_basics">4.2. Basics</a>
<ul class="sectlevel3">
<li><a href="#_keywords">4.2.1. Keywords</a></li>
<li><a href="#_block_node_structure">4.2.2. Block / Node Structure</a></li>
<li><a href="#_comments">4.2.3. Comments</a></li>
<li><a href="#_the_underlying_information_model">4.2.4. The Underlying Information Model</a>
<ul class="sectlevel4">
<li><a href="#_information_model_identifiers">Information Model Identifiers</a></li>
</ul>
</li>
<li><a href="#_node_identifiers">4.2.5. Node Identifiers</a></li>
<li><a href="#_the_matches_operator">4.2.6. The matches Operator</a></li>
<li><a href="#_natural_language">4.2.7. Natural Language</a></li>
</ul>
</li>
<li><a href="#_constraints_on_complex_types">4.3. Constraints on Complex types</a>
<ul class="sectlevel3">
<li><a href="#_attribute_constraints">4.3.1. Attribute Constraints</a>
<ul class="sectlevel4">
<li><a href="#_existence">Existence</a></li>
</ul>
</li>
<li><a href="#_single_valued_attributes">4.3.2. Single-valued Attributes</a></li>
<li><a href="#_container_attributes">4.3.3. Container Attributes</a>
<ul class="sectlevel4">
<li><a href="#_cardinality">Cardinality</a></li>
</ul>
</li>
<li><a href="#_object_constraints">4.3.4. Object Constraints</a>
<ul class="sectlevel4">
<li><a href="#_node_identifiers_2">Node Identifiers</a></li>
<li><a href="#_occurrences">Occurrences</a></li>
</ul>
</li>
<li><a href="#__any_constraints">4.3.5. "Any" Constraints</a></li>
<li><a href="#_reference_model_type_matching">4.3.6. Reference Model Type Matching</a>
<ul class="sectlevel4">
<li><a href="#_narrowed_subtype_constraints">Narrowed Subtype Constraints</a></li>
<li><a href="#_remove_specified_subtypes">Remove Specified Subtypes</a></li>
</ul>
</li>
<li><a href="#_paths">4.3.7. Paths</a>
<ul class="sectlevel4">
<li><a href="#_archetype_path_formation">Archetype Path Formation</a></li>
<li><a href="#_external_use_of_paths">External Use of Paths</a></li>
<li><a href="#_runtime_paths">Runtime Paths</a></li>
</ul>
</li>
<li><a href="#_internal_references_proxy_constraint_objects">4.3.8. Internal References (Proxy Constraint Objects)</a>
<ul class="sectlevel4">
<li><a href="#_paths_and_proxy_objects">Paths and Proxy Objects</a></li>
</ul>
</li>
<li><a href="#_external_references">4.3.9. External References</a>
<ul class="sectlevel4">
<li><a href="#_paths_2">Paths</a></li>
</ul>
</li>
<li><a href="#_archetype_slots">4.3.10. Archetype Slots</a>
<ul class="sectlevel4">
<li><a href="#_formal_semantics_of_include_and_exclude_constraints">Formal Semantics of include and exclude Constraints</a></li>
<li><a href="#_semantic_slot_definition">Semantic Slot Definition</a></li>
<li><a href="#_slots_based_on_lexical_archetype_identifiers">Slots based on Lexical Archetype Identifiers</a></li>
<li><a href="#_slots_based_on_other_constraints">Slots based on other Constraints</a></li>
<li><a href="#_slot_filling">Slot-filling</a></li>
</ul>
</li>
<li><a href="#_mixed_structures">4.3.11. Mixed Structures</a></li>
</ul>
</li>
<li><a href="#_second_order_constraints">4.4. Second-order Constraints</a>
<ul class="sectlevel3">
<li><a href="#_tuple_constraints">4.4.1. Tuple Constraints</a></li>
<li><a href="#_group_constraints">4.4.2. Group Constraints</a>
<ul class="sectlevel4">
<li><a href="#_slots_and_grouping">Slots and Grouping</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_constraints_on_primitive_types">4.5. Constraints on Primitive Types</a>
<ul class="sectlevel3">
<li><a href="#_assumed_values">4.5.1. Assumed Values</a></li>
<li><a href="#_constraints_on_string">4.5.2. Constraints on String</a>
<ul class="sectlevel4">
<li><a href="#_list_of_strings">List of Strings</a></li>
<li><a href="#_regular_expression">Regular Expression</a></li>
</ul>
</li>
<li><a href="#_constraints_on_integer">4.5.3. Constraints on Integer</a>
<ul class="sectlevel4">
<li><a href="#_list_of_integers">List of Integers</a></li>
<li><a href="#_interval_of_integer">Interval of Integer</a></li>
</ul>
</li>
<li><a href="#_constraints_on_real">4.5.4. Constraints on Real</a></li>
<li><a href="#_constraints_on_boolean">4.5.5. Constraints on Boolean</a></li>
<li><a href="#_constraints_on_character">4.5.6. Constraints on Character</a>
<ul class="sectlevel4">
<li><a href="#_list_of_characters">List of Characters</a></li>
<li><a href="#_regular_expression_2">Regular Expression</a></li>
</ul>
</li>
<li><a href="#_constraints_on_dates_times_and_durations">4.5.7. Constraints on Dates, Times and Durations</a>
<ul class="sectlevel4">
<li><a href="#_date_time_and_date_time">Date, Time and Date/Time</a></li>
<li><a href="#_duration_constraints">Duration Constraints</a></li>
</ul>
</li>
<li><a href="#_terminology_constraints">4.5.8. Terminology Constraints</a>
<ul class="sectlevel4">
<li><a href="#_overview_3">Overview</a></li>
<li><a href="#_requirement">Requirement</a></li>
<li><a href="#_design_basis">Design Basis</a></li>
<li><a href="#_source_form">Source Form</a></li>
<li><a href="#_expanded_form">Expanded Form</a></li>
<li><a href="#_substituted_form">Substituted Form</a></li>
<li><a href="#_resolved_form">Resolved Form</a></li>
</ul>
</li>
<li><a href="#_constraints_on_lists_of_primitive_types">4.5.9. Constraints on Lists of Primitive types</a></li>
<li><a href="#_constraints_on_enumerated_types">4.5.10. Constraints on Enumerated Types</a></li>
</ul>
</li>
<li><a href="#_syntax_validity_rules">4.6. Syntax Validity Rules</a></li>
</ul>
</li>
<li><a href="#_assertions">5. Assertions</a>
<ul class="sectlevel2">
<li><a href="#_overview_4">5.1. Overview</a>
<ul class="sectlevel3">
<li><a href="#_requirements">5.1.1. Requirements</a></li>
<li><a href="#_design_basis_2">5.1.2. Design Basis</a></li>
</ul>
</li>
<li><a href="#_keywords_2">5.2. Keywords</a></li>
<li><a href="#_typing">5.3. Typing</a></li>
<li><a href="#_operators">5.4. Operators</a>
<ul class="sectlevel3">
<li><a href="#_arithmetic_operators">5.4.1. Arithmetic Operators</a></li>
<li><a href="#_equality_operators">5.4.2. Equality Operators</a></li>
<li><a href="#_relational_operators">5.4.3. Relational Operators</a></li>
<li><a href="#_boolean_operators">5.4.4. Boolean Operators</a></li>
<li><a href="#_quantifiers">5.4.5. Quantifiers</a></li>
<li><a href="#_functions">5.4.6. Functions</a></li>
</ul>
</li>
<li><a href="#_operands">5.5. Operands</a>
<ul class="sectlevel3">
<li><a href="#_constants">5.5.1. Constants</a></li>
<li><a href="#_object_references">5.5.2. Object References</a></li>
<li><a href="#_built_in_variables">5.5.3. Built-in Variables</a></li>
<li><a href="#_archetype_defined_variables">5.5.4. Archetype-defined Variables</a></li>
<li><a href="#_external_queries">5.5.5. External Queries</a>
<ul class="sectlevel4">
<li><a href="#_query_contexts">Query Contexts</a></li>
<li><a href="#_query_names">Query Names</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_precedence_and_parentheses">5.6. Precedence and Parentheses</a></li>
<li><a href="#_conditions">5.7. Conditions</a></li>
<li><a href="#_natural_language_issues">5.8. Natural Language Issues</a></li>
</ul>
</li>
<li><a href="#_adl_paths">6. ADL Paths</a>
<ul class="sectlevel2">
<li><a href="#_overview_5">6.1. Overview</a>
<ul class="sectlevel3">
<li><a href="#_relationship_with_w3c_xpath">6.1.1. Relationship with W3C Xpath</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_default_values">7. Default Values</a>
<ul class="sectlevel2">
<li><a href="#_overview_6">7.1. Overview</a></li>
</ul>
</li>
<li><a href="#_adl_archetype_definition_language">8. ADL - Archetype Definition Language</a>
<ul class="sectlevel2">
<li><a href="#_introduction_2">8.1. Introduction</a></li>
<li><a href="#_file_naming_convention">8.2. File-naming Convention</a></li>
<li><a href="#_basics_2">8.3. Basics</a>
<ul class="sectlevel3">
<li><a href="#_keywords_3">8.3.1. Keywords</a></li>
<li><a href="#_artefact_declaration">8.3.2. Artefact declaration</a></li>
<li><a href="#_node_identifier_codes">8.3.3. Node Identifier Codes</a></li>
<li><a href="#_local_term_codes">8.3.4. Local Term Codes</a></li>
<li><a href="#_local_constraint_codes">8.3.5. Local Constraint Codes</a></li>
</ul>
</li>
<li><a href="#_archetype_identification_section">8.4. Archetype Identification Section</a>
<ul class="sectlevel3">
<li><a href="#_adl_version_indicator">8.4.1. ADL Version Indicator</a></li>
<li><a href="#_machine_identifiers">8.4.2. Machine Identifiers</a></li>
<li><a href="#_namespaces">8.4.3. Namespaces</a></li>
<li><a href="#_human_readable_archetype_identifier">8.4.4. Human Readable Archetype Identifier</a></li>
<li><a href="#_specialised_archetype_identification">8.4.5. Specialised Archetype Identification</a></li>
<li><a href="#_version_identifiers">8.4.6. Version Identifiers</a></li>
<li><a href="#_validity">8.4.7. Validity</a></li>
<li><a href="#_generated_indicator">8.4.8. Generated Indicator</a></li>
<li><a href="#_controlled_indicator">8.4.9. Controlled Indicator</a></li>
</ul>
</li>
<li><a href="#_specialise_section">8.5. Specialise Section</a></li>
<li><a href="#_language_section">8.6. Language Section</a></li>
<li><a href="#_description_section">8.7. Description Section</a></li>
<li><a href="#_deprecated_sections">8.8. Deprecated Sections</a>
<ul class="sectlevel3">
<li><a href="#_concept_section">8.8.1. Concept Section</a></li>
</ul>
</li>
<li><a href="#_definition_section">8.9. Definition Section</a>
<ul class="sectlevel3">
<li><a href="#_design_time_and_run_time_paths">8.9.1. Design-time and Run-time paths</a></li>
</ul>
</li>
<li><a href="#_rules_section">8.10. Rules Section</a></li>
<li><a href="#_terminology_section">8.11. Terminology Section</a>
<ul class="sectlevel3">
<li><a href="#_adl_1_4_1_5_version_compatibility">8.11.1. ADL 1.4 / 1.5 Version Compatibility</a></li>
<li><a href="#_overview_7">8.11.2. Overview</a></li>
<li><a href="#_term_definitions_section">8.11.3. Term_definitions Section</a></li>
<li><a href="#_term_bindings_section">8.11.4. Term_bindings Section</a>
<ul class="sectlevel4">
<li><a href="#_global_term_bindings">Global Term Bindings</a></li>
<li><a href="#_path_based_bindings">Path-based Bindings</a></li>
</ul>
</li>
<li><a href="#_deprecated_elements">8.11.5. Deprecated Elements</a></li>
</ul>
</li>
<li><a href="#_annotations_section">8.12. Annotations Section</a></li>
<li><a href="#_revision_history_section_2">8.13. Revision History Section</a></li>
</ul>
</li>
<li><a href="#_terminology_integration">9. Terminology Integration</a>
<ul class="sectlevel2">
<li><a href="#_source_form_constraints">9.1. Source-form Constraints</a></li>
<li><a href="#_expanded_constraints">9.2. Expanded Constraints</a></li>
<li><a href="#_constraint_resolution">9.3. Constraint Resolution</a></li>
</ul>
</li>
<li><a href="#_specialisation">10. Specialisation</a>
<ul class="sectlevel2">
<li><a href="#_overview_8">10.1. Overview</a></li>
<li><a href="#_examples">10.2. Examples</a>
<ul class="sectlevel3">
<li><a href="#_redefinition_for_refinement">10.2.1. Redefinition for Refinement</a></li>
<li><a href="#_redefinition_for_specialisation">10.2.2. Redefinition for Specialisation</a></li>
<li><a href="#_specialisation_with_cloning">10.2.3. Specialisation with Cloning</a></li>
</ul>
</li>
<li><a href="#_specialisation_concepts">10.3. Specialisation Concepts</a>
<ul class="sectlevel3">
<li><a href="#_differential_and_flat_forms">10.3.1. Differential and Flat Forms</a></li>
<li><a href="#_specialisation_levels">10.3.2. Specialisation Levels</a></li>
<li><a href="#_specialisation_paths">10.3.3. Specialisation Paths</a></li>
<li><a href="#_path_congruence">10.3.4. Path Congruence</a></li>
<li><a href="#_redefinition_concepts">10.3.5. Redefinition Concepts</a></li>
</ul>
</li>
<li><a href="#_attribute_redefinition">10.4. Attribute Redefinition</a>
<ul class="sectlevel3">
<li><a href="#_existence_redefinition_mandation_and_exclusion">10.4.1. Existence Redefinition: Mandation and Exclusion</a></li>
<li><a href="#_multiply_valued_container_attributes">10.4.2. Multiply-valued (Container) Attributes</a>
<ul class="sectlevel4">
<li><a href="#_cardinality_2">Cardinality</a></li>
<li><a href="#_ordering_of_sibling_nodes">Ordering of Sibling Nodes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_object_redefinition">10.5. Object Redefinition</a>
<ul class="sectlevel3">
<li><a href="#_node_identifiers_3">10.5.1. Node Identifiers</a>
<ul class="sectlevel4">
<li><a href="#_node_redefinition_semantics">Node Redefinition Semantics</a></li>
<li><a href="#_adding_nodes">Adding Nodes</a></li>
</ul>
</li>
<li><a href="#_occurrences_redefinition_and_exclusion">10.5.2. Occurrences Redefinition and Exclusion</a></li>
<li><a href="#_reference_model_type_refinement">10.5.3. Reference Model Type Refinement</a></li>
<li><a href="#_terminology_external_subset_redefinition">10.5.4. Terminology External Subset Redefinition</a></li>
<li><a href="#_internal_reference_proxy_object_redefinition">10.5.5. Internal Reference (Proxy Object) Redefinition</a></li>
<li><a href="#_external_reference_redefinition">10.5.6. External Reference Redefinition</a></li>
<li><a href="#_slot_filling_and_redefinition">10.5.7. Slot Filling and Redefinition</a></li>
<li><a href="#_unconstrained_attributes">10.5.8. Unconstrained Attributes</a></li>
<li><a href="#_primitive_object_redefinition">10.5.9. Primitive Object Redefinition</a></li>
<li><a href="#_10_5_10_tuple_redefinition">10.5.10. 10.5.10 Tuple Redefinition</a></li>
</ul>
</li>
<li><a href="#_rules">10.6. Rules</a></li>
<li><a href="#_languages">10.7. Languages</a></li>
<li><a href="#_description_section_2">10.8. Description Section</a></li>
<li><a href="#_terminology">10.9. Terminology</a></li>
<li><a href="#_bindings">10.10. Bindings</a></li>
</ul>
</li>
<li><a href="#_relationship_of_adl_to_other_formalisms">Appendix A: Relationship of ADL to Other Formalisms</a>
<ul class="sectlevel2">
<li><a href="#_overview_9">A.1. Overview</a></li>
<li><a href="#_constraint_syntaxes">A.2. Constraint Syntaxes</a>
<ul class="sectlevel3">
<li><a href="#_omg_ocl_object_constraint_language">A.2.1. OMG OCL (Object Constraint Language)</a></li>
</ul>
</li>
<li><a href="#_ontology_formalisms">A.3. Ontology Formalisms</a>
<ul class="sectlevel3">
<li><a href="#_owl_web_ontology_language">A.3.1. OWL (Web Ontology Language)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_references">References</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="../../../spec-publish-asciidoc/resources/images/openehr_logo_large.png" alt="openEHR logo">
</div>
</div>
</div>
</div>
<h1 id="_archetype_defnition_language_adl2_specification" class="sect0">Archetype Defnition Language (ADL2) specification</h1>
<div class="openblock partintro">
<div class="content">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 33%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="3"><strong>Issuer</strong>: <a href="http://www.openehr.org/programs/specification/">openEHR Specification Program</a></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Revision</strong>: <a href="#latest_issue">[latest_issue]</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Date</strong>: <a href="#latest_issue_date">[latest_issue_date]</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Status</strong>: TRIAL</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>Keywords</strong>: EHR, ADL, AOM, health records, archetypes, constraint language, 13606, CIMI</p></td>
</tr>
</tbody>
</table>
<div class="imageblock" style="text-align: center">
<div class="content">
<img src="diagrams/openehr_block_diagram-adl.png" alt="openEHR components" width="60%">
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> </pre>
</div>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top" colspan="2">&#169; 2003 - 2015 The openEHR Foundation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><a href="http://www.openehr.org/">The openEHR Foundation</a> is an independent, non-profit community organisation, facilitating the sharing of health records by consumers and clinicians via open-source, standards-based implementations.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Affiliates</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Australia, Brazil, Japan, New Zealand, Slovenia, Norway</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Licence</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="../../../spec-publish-asciidoc/resources/images/cc-by-nd-88x31.png" alt="image"></span> Creative Commons Attribution-NoDerivs 3.0 Unported. <a href="https://creativecommons.org/licenses/by-nd/3.0/" class="bare">https://creativecommons.org/licenses/by-nd/3.0/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock"><strong>Support</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Issues: <a href="https://openehr.atlassian.net/browse/SPECPR/" class="bare">https://openehr.atlassian.net/browse/SPECPR/</a><br>
 Web: <a href="http://www.openehr.org/" class="bare">http://www.openehr.org/</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_amendment_record">Amendment Record</h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 9%;">
<col style="width: 54%;">
<col style="width: 18%;">
<col style="width: 18%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Issue</th>
<th class="tableblock halign-left valign-top">Details</th>
<th class="tableblock halign-left valign-top">Raiser</th>
<th class="tableblock halign-left valign-top">Completed</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="latest_issue"></a>2.0.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add semantic slot definitions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="latest_issue_date"></a>15 Jun 2015</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Upgrade specification to ADL 2.x level. Reduce overview text.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">openEHR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 Nov 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Change <code>use_archetype</code> syntax to include id-code.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 P Langford</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17 July 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Corrections on semantics of node id redefinition in Specialisation section; correct further typos.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">H Solbrig</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">25 June 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add support for constraints on enumeration types.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 CIMI</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 June 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Move terminology value set constraints to terminology section, convert external term references to URIs.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 H Solbrig</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">17 May 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">New format term codes &amp; mandatory node ids.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7 Jan 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convert ‘placeholder’ (ac-code) constraint to primitive terminology type constraint.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">H Solbrig</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.7.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add archetype id namespacing.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 I McNicoll</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24 Nov 2014</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add tuple construct.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 Aug 2013</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remove dADLsyntax description to new ODIN specification.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">22 Apr 2013</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-316: Allow ‘cardinality’ keyword on its own to indicate container attributes, even if no other constraints required.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D Moner</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">21 Mar 2012</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-270: Add specialisation semantics to ADL and AOM.<br>
 Improve explanation of node identifiers.<br>
 Correct typographical errors.<br>
 Make concept optional.<br>
 Refine slot include/exclude rules.<br>
 Review of text &amp; validity rules.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard<br>
 O Pishev<br>
 T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecate <em>terminologies_available</em> statement in terminology section.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Add fractional seconds to dADL grammar.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Arikan</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-303. Make existence, occurrences and cardinality optional in AOM.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Garde<br>
 S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-300. Archetype slot regular expressions should cover whole identifier. Added <code>C_STRING</code>.<em>is_pattern</em>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Flinton</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4" style="background-color: aqua;"><p class="tableblock"><strong>R E L E A S E&#160;&#160;&#160;&#160;&#160;1.0.2</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.4.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-268: Correct missing parentheses in dADL type identifiers. dADL grammar and cADL scanner rules updated.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">R Chen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 Dec 2008</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-284: Correct inconsistencies in naming of term_definitions, constraint_definitions, term_bindings, constraint_bindings attributes in XML-schema and specifications.<br>
 Improved explanatory text for composite identifiers, including statement on case-sensitivity. Warning on .v1draft non-conformance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Torrisi</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPEC-260: Correct the regex published for the ARCHETYPE_ID type. Update ADL grammar <code>ARCHEYTPE_ID</code> definition.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">P Gummer,<br>
 J Arnett,<br>
 E Browne</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4" style="background-color: aqua;"><p class="tableblock"><strong>R E L E A S E&#160;&#160;&#160;&#160;&#160;1.0.1</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.4.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000203: Release 1.0 explanatory text improvements. Improve Archetype slot explanation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13 Mar 2007</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000208: Improve ADL grammar for assertion expressions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000160: Duration constraints. Added ISO 8601 patterns for duration in cADL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000213: Correct ADL grammar for date/times to be properly ISO8601-compliant. Include ‘T’ in cADL patterns and dADL and cADL Date/time, Time and Duration values.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000216: Allow mixture of W, D etc in ISO8601 Duration (deviation from standard).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000200: Correct Release 1.0 typographical errors.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Patterson<br>
 R Chen<br>
 S Garde<br>
 T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000225: Allow generic type names in ADL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">M Forss</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000226: Rename <code>C_CODED_TEXT</code> to <code>C_CODE_PHRASE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000233: Define semantics for <code>occurrences</code> on <code>ARCHETYPE_INTERNAL_REF</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">K Atalag</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000241: Correct cADL grammar for archeype slot match expressions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000223: Clarify quoting rules in ADL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Patterson</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000242: Allow non-inclusive two-sided ranges in ADL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000245: Allow term bindings to paths in archetypes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4" style="background-color: aqua;"><p class="tableblock"><strong>R E L E A S E&#160;&#160;&#160;&#160;&#160;1.0</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.3.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000136. Add validity rules to ADL document.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18 Jan 2006</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000171. Add validity check for cardinality &amp; occurrences</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Maldondo</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.3.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000141. Allow point intervals in ADL. Updated atomic types part of cADL section and dADL grammar section.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18 Jun 2005</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000142. Update dADL grammar to support assumed values.<br>
 CR-000143. Add partial date/time values to dADL syntax.<br>
 CR-000149. Add URIs to dADL and remove query() syntax.<br>
 CR-000153. Synchronise ADL and AOM for language attributes<br>
 CR-000156. Update documentation of container types.<br>
 CR-000138. Archetype-level assertions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4" style="background-color: aqua;"><p class="tableblock"><strong>R E L E A S E&#160;&#160;&#160;&#160;&#160;0.95</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.2.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000125. <code>C_QUANTITY</code> example in ADL manual uses old dADL syntax.<br>
 CR-000115. Correct "/[xxx]" path grammar error in ADL.<br>
 Create new section describing ADL path syntax.<br>
 CR-000127. Restructure archetype specifications. Remove clinical constraint types section of document.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11 Feb 2005</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000110. Update ADL document and create AOM document.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15 Nov 2004</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added explanatory material; added domain type support; rewrote of most dADL sections. Added section on assumed values, “controlled” flag, nested container structures. Change language handling.<br>
 Rewrote OWL section based on input from: University of Manchester, UK; University Seville, Spain.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Rector<br>
 R Qamar<br>
 I Román Martínez</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Various changes to assertions due to input from the DSTC.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A Goodchild<br>
 Z Z Tun</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detailed review from Clinical Information Project, Australia.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">E Browne</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Remove UML models to “Archetype Object Model” document.</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Detailed review from CHIME, UCL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Austin</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000103. Redevelop archetype UML model, add new keywords: <code>allow_archetype</code>, <code>include</code>, <code>exclude</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000104. Fix ordering bug when <code>use_node</code> used. Required parser rules for identifiers to make class and attribute identifiers distinct.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">K Atalag</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added grammars for all parts of ADL, as well as new UML diagrams.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="4" style="background-color: aqua;"><p class="tableblock"><strong>R E L E A S E&#160;&#160;&#160;&#160;&#160;0.9</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000079. Change interval syntax in ADL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24 Jan 2004</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000077. Add cADL date/time pattern constraints.<br>
 CR-000078. Add predefined clinical types.
 Better explanation of cardinality, occurrences and existence.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">S Heard,<br>
 T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14 Jan 2004</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000073. Allow lists of Reals and Integers in cADL.<br>
 CR-000075. Add predefined clinical types library to ADL.<br>
 Added cADL and dADL object models.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 S Heard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">28 Dec 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CR-000070. Create Archetype System Description.
 Moved Archetype Identification Section to new Archetype System document.  Copyright Assgined by Ocean Informatics P/L Australia to The openEHR Foundation.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale,<br>
 S Heard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">29 Nov 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added simple value list continuation (“,&#8230;&#8203;"). Changed path syntax so that trailing ‘/’ required for object paths.<br>
 Remove ranges with excluded limits.<br>
 Added terms and term lists to dADL leaf types.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">01 Nov 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Additions during HL7 WGM Memphis Sept 2003</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">09 Sep 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added comparison to other formalisms. Renamed CDL to cADL and dDL to dADL. Changed path syntax to conform (nearly) to Xpath. Numerous small changes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">03 Sep 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rewritten with sections on cADL and dDL.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">28 July 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.8.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Added basic type constraints, re-arranged sections.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15 July 2003</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial Writing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T Beale</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 July 2003</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_primary_author">Primary Author</h3>
<div class="ulist">
<ul>
<li>
<p>Thomas Beale, Ocean Informatics UK; openEHR Foundation Management Board</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_contributors">Contributors</h3>
<div class="paragraph">
<p>This specification and its sibling Archetype Definition Language specification have benefited from wide formal and informal input from the openEHR and wider health informatics community. The openEHR Foundation would like to recognise the following people and institutions.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Seref Arikan, MEcon, Ocean Informatics UK, Centre for Health Informatics and Multi-professional Education (CHIME), UCL, UK</p>
</li>
<li>
<p>John Arnett, NHS Connecting for Health, UK</p>
</li>
<li>
<p>Koray Atalag PhD, University of Auckland, NZ</p>
</li>
<li>
<p>Tony Austin PhD, Centre for Health Informatics and Multi-professional Education (CHIME), UCL, UK</p>
</li>
<li>
<p>Eric Browne PhD, HealthBase Australia</p>
</li>
<li>
<p>Rong Chen MD, PhD, Cambio Heath Systems, Sweden</p>
</li>
<li>
<p>Adam Flinton, NHS Connecting for Health, UK</p>
</li>
<li>
<p>Matias Forss MSc, Institute of Technology at Linköping University</p>
</li>
<li>
<p>Sebastian Garde, PhD, Ocean Informatics</p>
</li>
<li>
<p>Andrew Goodchild PhD, Distributed Systems Technology Centre, Australia</p>
</li>
<li>
<p>Peter Gummer MSc, Ocean Informatics</p>
</li>
<li>
<p>Sam Heard MD, Ocean Informatics</p>
</li>
<li>
<p>Jose Alberto Maldondo PhD, Universitat Politècnica de València, Spain</p>
</li>
<li>
<p>David Moner PhD, Universitat Politècnica de València, Spain</p>
</li>
<li>
<p>Isabel Román Martínez PhD, Universitat de Sevilla, Spain</p>
</li>
<li>
<p>Ian McNicoll MD, MSc, Ocean Informatics UK</p>
</li>
<li>
<p>Andrew Patterson PhD, LLM, Federation Health Software, Australia</p>
</li>
<li>
<p>Ognian Pishev PhD, Australia, Ocean Informatics * Rahil Qamar Siddiqui PhD, NHS Health &amp; Social Care Information Centre, UK</p>
</li>
<li>
<p>Prof Alan Rector MD, PhD, University of Manchester, UK</p>
</li>
<li>
<p>Harold Solbrig PhD, Mayo Clinic, Rochester, USA</p>
</li>
<li>
<p>Alessandro Torrisi, Code24, Netherlands</p>
</li>
<li>
<p>Zar Zar Tun, Distributed Systems Technology Centre, Australia</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Thanks to Sebastian Garde, Central Qld University, Australia, for German translations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_trademarks">Trademarks</h3>
<div class="ulist">
<ul>
<li>
<p>'Microsoft' and '.Net' are registered trademarks of the Microsoft Corporation.</p>
</li>
<li>
<p>'Java' is a registered trademark of Oracle Corporation</p>
</li>
<li>
<p>'Linux' is a registered trademark of Linus Torvalds.</p>
</li>
<li>
<p>'openEHR' is a registered trademark of The openEHR Foundation</p>
</li>
<li>
<p>'SNOMED CT' is a registered trademark of IHTSDO</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_supporters">Supporters</h3>
<div class="paragraph">
<p>The work reported in this document was funded by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ocean Informatics;</p>
</li>
<li>
<p>University College London, Centre for Health Informatics and Multi-professional Education (CHIME).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_purpose">1.1. Purpose</h3>
<div class="paragraph">
<p>This document describes the design basis and syntax of the Archetype Definition Language (ADL) 2.x, a new major version of ADL, containing structural changes with respect to the ADL 1.x versions.</p>
</div>
<div class="paragraph">
<p>It is intended for software developers, technically-oriented domain specialists and subject matter experts (SMEs). ADL is designed as an abstract human-readable and computer-processible syntax. ADL archetypes can be hand-edited using a normal text editor.</p>
</div>
<div class="paragraph">
<p>The intended audience includes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standards bodies producing health informatics standards;</p>
</li>
<li>
<p>Academic groups using openEHR;</p>
</li>
<li>
<p>The open source healthcare community;</p>
</li>
<li>
<p>Solution vendors;</p>
</li>
<li>
<p>Medical informaticians and clinicians interested in health information.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_related_documents">1.2. Related Documents</h3>
<div class="paragraph">
<p>Prerequisite documents for reading this document include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="http://www.openehr.org/releases/trunk/architecture/overview.pdf">openEHR Architecture Overview</a></p>
</li>
<li>
<p>The <a href="http://www.openehr.org/releases/trunk/architecture/am/archetype_technical_overview.pdf">openEHR Archetypes: Technical Overview</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Related documents include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The openEHR <a href="http://www.openehr.org/releases/trunk/architecture/am/aom2.pdf">Archetype Object Model (AOM2)</a></p>
</li>
<li>
<p>The <a href="http://www.openehr.org/releases/trunk/architecture/am/templates_guide.pdf">openEHR Operational Template Specification</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_nomenclature">1.3. Nomenclature</h3>
<div class="paragraph">
<p>In this document, the term ‘attribute’ denotes any stored property of a type defined in an object model, including primitive attributes and any kind of relationship such as an association or aggregation. XML ‘attributes’ are always referred to explicitly as ‘XML attributes’.</p>
</div>
<div class="paragraph">
<p>We also use the word ‘archetype’ in a broad sense to designate what are commonly understood to be ‘archetypes’ (specifications of clinical data groups / data constraints) and ‘templates’ (data sets based on archetypes, since at a technical level, an ADL/AOM 2 template is in fact just an archetype. Accordingly, statements about ‘archetypes’ in this specification can be always understood to also apply to templates, unless otherwise indicated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_status">1.4. Status</h3>
<div class="paragraph">
<p>This specification is in the Trial state. The development version of this document can be found at <a href="http://www.openehr.org/releases/trunk/architecture/am/ADL2.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/am/ADL2.pdf</a>.</p>
</div>
<div class="paragraph">
<p>Known omissions or questions are indicated in the text with a 'to be determined' paragraph, as follows:</p>
</div>
<div class="paragraph tbd">
<p><strong>TBD</strong>: (example To Be Determined paragraph)</p>
</div>
<div class="paragraph">
<p>Users are encouraged to comment on and/or advise on these paragraphs as well as the main content.  Feedback should be provided either on the <a href="http://lists.openehr.org/mailman/listinfo/openehr-technical_lists.openehr.org">technical mailing list</a>, or on the <a href="https://openehr.atlassian.net/browse/SPECPR/?selectedTab=com.atlassian.jira.jira-projects-plugin:issues-panel">specifications issue tracker</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tools">1.5. Tools</h3>
<div class="paragraph">
<p>Various tools exist for creating and processing archetypes. The <a href="http://www.openehr.org/downloads/ADLworkbench/home">ADL Workbench</a> is a reference compiler, visualiser and editor. The openEHR tools can be <a href="http://www.openehr.org/downloads/modellingtools">downloaded from the website</a> .
Source projects can be found at the <a href="https://github.com/openEHR">openEHR Github project</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_changes_from_previous_versions">1.6. Changes from Previous Versions</h3>
<div class="paragraph">
<p>For existing users of ADL or archetype development tools, the following provides a guide to the changes in the syntax.</p>
</div>
<div class="sect3">
<h4 id="_dadl_odin">1.6.1. dADL (ODIN)</h4>
<div class="paragraph">
<p>The object syntax used to represent the description, terminology and annotations sections of an ADL archetype has been historically known as ‘dADL’ (i.e. ‘data ADL’). Since this syntax is completely generic and has no specific dependency on either ADL or openEHR, it has been separated out into its own specification known as Object Data Instance Notation (ODIN).</p>
</div>
</div>
<div class="sect3">
<h4 id="_adl_2_0">1.6.2. ADL 2.0</h4>
<div class="sect4">
<h5 id="_changes">Changes</h5>
<div class="paragraph">
<p>The changes in version 2.0 are designed to make archetypes more computable with respect to terminology. The changes with respect to 1.x versions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the internal node identification system has been changed so that at-codes are no longer used to identify nodes; instead, ‘id-codes’ are used for that purpose;</p>
</li>
<li>
<p>all nodes now require an id-code;</p>
</li>
<li>
<p>rules for the construction of node identifier codes in specialised archetypes;</p>
</li>
<li>
<p>the <code>ontology</code> section has been renamed `terminology;</p>
</li>
<li>
<p>value sets are now declared in their own subsection of the terminology section rather than inline in the definition section;</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_backward_compatibility">Backward Compatibility</h5>
<div class="paragraph">
<p>In its current form, the changes to the internal coding system and value set representation in ADL 2.x and the AOM with respect to ADL/AOM 1.5 constitute syntactically breaking changes, and therefore require conversion of ADL 1.4 archetypes to ADL 2 form. The changes have been carefully designed to allow this conversion to be implementable, and are implemented in the ADL Workbench tool. ADL
1.4 style paths are generatable from ADL 2 archetypes, so that AQL queries can be built for use with ADL 1.4 based data.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adl_1_5">1.6.3. ADL 1.5</h4>
<div class="sect4">
<h5 id="_changes_2">Changes</h5>
<div class="paragraph">
<p>The changes in version 1.5 are made to better facilitate the representation of specialised archetypes.  The key semantic capability for specialised archetypes is to be able to support a differential representation, i.e. to express a specialised archetype only in terms of the changed or new elements in its defnition, rather than including a copy of unchanged elements. Doing the latter is clearly unsustainable in terms of change management. ADL 1.4 already supported differential representation, but somewhat inconveniently.</p>
</div>
<div class="paragraph">
<p>The changes for ADL 1.5 include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>optional <code>generated</code> marker in the archetype first line;</p>
</li>
<li>
<p>the semantics of reference model subtype matching are now described;</p>
</li>
<li>
<p>a differential expression form allows specialised archetypes to be expressed efficiently and ensures they are maintainable;</p>
</li>
<li>
<p>new keywords for defining the order of specialised object nodes within container attributes;</p>
</li>
<li>
<p>an explanation of how to use the negated match operator (<code>~matches</code>, or <code>∈</code>) to define value set exclusions in specialised archetypes;</p>
</li>
<li>
<p>a description of the semantics of ‘inheritance-flattened’ archetypes;</p>
</li>
<li>
<p>optional <code>annotations</code> section added to archetypes;</p>
</li>
<li>
<p><code>declarations</code> and <code>invariants</code> sections merged into <code>rules</code> section;</p>
</li>
<li>
<p>In the ADL grammar, the language section is now mandatory;</p>
</li>
<li>
<p><code>.adls</code> files are introduced as the standard file extension for differential ADL files (<code>.adl</code> files are retained for standalone, inheritance-flattened, or ‘flat’, archetype).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Nearly all the changes occur in the section on cADL - Constraint ADL on page 22 or the new section Specialisation on page 90.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adl_1_4">1.6.4. ADL 1.4</h4>
<div class="paragraph">
<p>A number of small changes were made in this version, along with significant tightening up of the explanatory text and examples.</p>
</div>
<div class="sect4">
<h5 id="_iso_8601_date_time_conformance">ISO 8601 Date/Time Conformance</h5>
<div class="paragraph">
<p>All ISO 8601 date, time, date/time and duration values in dADL are now conformant (previously the usage of the ‘T’ separator was not correct). Constraint patterns in cADL for dates, times and date/times are also corrected, with a new constraint pattern for ISO 8601 durations being added. The latter allows a deviation from the standard to include the ‘W’ specifier, since durations with a mixture of weeks, days etc is often used in medicine.</p>
</div>
</div>
<div class="sect4">
<h5 id="_non_inclusive_two_sided_intervals">Non-inclusive Two-sided Intervals</h5>
<div class="paragraph">
<p>It is now possible to define an interval of any ordered amount (integer, real, date, time, date/time, duration) where one or both of the limits is not included, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    |0..&lt;1000|    -- 0 &gt;= x &lt; 1000
    |&gt;0.5..4.0|   -- 0.5 &gt; x &lt;= 4.0
    |&gt;P2d..&lt;P10d| -- 2 days &gt; x &lt; 10 days</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_occurrences_for_use_node_references">Occurrences for ‘use_node’ References</h5>
<div class="paragraph">
<p>Occurrences can now be stated for <code>use_node</code> references, overriding the occurrences of the target node.  If no occurrences is stated, the target node occurrences value is used.</p>
</div>
</div>
<div class="sect4">
<h5 id="_quoting_rules">Quoting Rules</h5>
<div class="paragraph">
<p>The old quoting rules based on XML/ISO mnemonic patterns (<code>&ohmgr;</code> etc) are replaced by specifying ADL to be UTF-8 based, and any exceptions to this requiring ASCII encoding should use the <code>\Uhhhh</code> style of quoting unicode used in various programming languuages.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adl_1_3">1.6.5. ADL 1.3</h4>
<div class="paragraph">
<p>The specific changes made in version 1.3 of ADL are as follows.</p>
</div>
<div class="sect4">
<h5 id="_query_syntax_replaced_by_uri_data_type">Query syntax replaced by URI data type</h5>
<div class="paragraph">
<p>In version 1.2 of ADL, it was possible to include an external query, using syntax of the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    attr_name = &lt;query("some_service", "some_query_string")&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is now replaced by the use of URIs, which can express queries, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    attr_name = &lt;http://some.service.org?some%20query%20etc&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>No assumption is made about the URI; it need not be in the form of a query - it may be any kind of URI.</p>
</div>
</div>
<div class="sect4">
<h5 id="_top_level_invariant_section">Top-level Invariant Section</h5>
<div class="paragraph">
<p>In this version, invariants can only be defined in a top level block, in a way similar to object-oriented class definitions, rather than on every block in the definition section, as is the case in version 1.2 of ADL. This simplifies ADL and the Archetype Object Model, and makes an archetype more comprehensible as a <code>type</code> definition.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_adl_1_2">1.6.6. ADL 1.2</h4>
<div class="sect4">
<h5 id="_adl_version">ADL Version</h5>
<div class="paragraph">
<p>The ADL version is now optionally (for the moment) included in the first line of the archetype, as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    archetype (adl_version=1.2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is strongly recommended that all tool implementors include this information when archetypes are saved, enabling archetypes to gradually become imprinted with their correct version, for more reliable later processing. The adl_version indicator is likely to become mandatory in future versions of ADL.</p>
</div>
</div>
<div class="sect4">
<h5 id="_dadl_odin_syntax_changes">dADL (ODIN) Syntax Changes</h5>
<div class="paragraph">
<p>The dADL (now ODIN) syntax for container attributes has been altered to allow paths and typing to be expressed more clearly, as part of enabling the use of Xpath-style paths. ADL 1.1 dADL had the following appearance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>	school_schedule = &lt;
		locations(1) = &lt;...&gt;
		locations(2) = &lt;...&gt;
		locations(3) = &lt;...&gt;
		subjects("philosophy:plato") = &lt;...&gt;
		subjects("philosophy:kant") = &lt;...&gt;
		subjects("art") = &lt;...&gt;
	&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has been changed to look like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>	school_schedule = &lt;
		locations = &lt;
			[1] = &lt;...&gt;
			[2] = &lt;...&gt;
			[3] = &lt;...&gt;
		&gt;
		subjects = &lt;
			["philosophy:plato"] = &lt;...&gt;
			["philosophy:kant"] = &lt;...&gt;
			["art”] = &lt;...&gt;
		&gt;
	&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The new appearance both corresponds more directly to the actual object structure of container types,
and has the property that paths can be constructed by directly reading identifiers down the backbone
of any subtree in the structure. It also allows the optional addition of typing information anywhere in
the structure, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>	school_schedule = SCHEDULE &lt;
		locations = LOCATION &lt;
			[1] = &lt;...&gt;
			[2] = &lt;...&gt;
			[3] = ARTS_PAVILLION &lt;...&gt;
		&gt;
		subjects = &lt;
			["philosophy:plato"] = ELECTIVE_SUBJECT &lt;...&gt;
			["philosophy:kant"] = ELECTIVE_SUBJECT &lt;...&gt;
			["art"] = MANDATORY_SUBJECT &lt;...&gt;
		&gt;
	&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>These changes will affect the parsing of container structures and keys in the description and terminology parts of the archetype.</p>
</div>
</div>
<div class="sect4">
<h5 id="_revision_history_section">Revision History Section</h5>
<div class="paragraph">
<p>Revision history is now recorded in a separate section of the archetype, both to logically separate it from the archetype descriptive details, and to facilitate automatic processing by version control systems in which archtypes may be stored. This section is included at the end of the archetype because it is in general a monotonically growing section.</p>
</div>
</div>
<div class="sect4">
<h5 id="_primary_language_and_languages_available_sections">Primary_language and Languages_available Sections</h5>
<div class="paragraph">
<p>An attribute previously called <code><em>primary_language</em></code> was required in the ontology section of an ADL 1.1 archetype. This is renamed to <code><em>original_language</em></code> and is now moved to a new top level section in the archetype called <code>language</code>. Its value is still expressed as a dADL String attribute. The <code><em>languages_available</em></code> attribute previously required in the ontology section of the archetype is renamed to <code><em>translations</em></code>, no longer includes the original languages, and is also moved to this new top level section.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview">2. Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ADL uses three syntaxes, cADL (constraint form of ADL), ODIN (Object Data Instance Notation), and a version of first-order predicate logic (FOPL), to express constraints on data which are instances of an underlying information model, which may be expressed in UML, relational form, or in a programming language. ADL itself is a very simple ‘glue’ syntax, which uses two other syntaxes for expressing structured constraints and data, respectively. The cADL syntax is used to express the archetype <code><em>definition</em></code> section, while the ODIN syntax is used to express data which appears in the <code><em>language</em></code>, <code><em>description</em></code>, <code><em>terminology</em></code>, and <code><em>revision_history</em></code> sections of an ADL archetype. The toplevel structure of an ADL archetype is shown in FIGURE 1.</p>
</div>
<div class="paragraph">
<p>This main part of this document describes cADL and ADL path syntax, before going on to describe the combined ADL syntax, archetypes and domain-specific type libraries.</p>
</div>
<div id="package_overview" class="imageblock text-center" style="text-align: center">
<div class="content">
<img src="diagrams/adl_text_overview.png" alt="adl text overview" width="50%">
</div>
<div class="title">Figure 1. ADL Archetype Structure</div>
</div>
<div class="sect2">
<h3 id="_an_example">2.1. An Example</h3>
<div class="paragraph">
<p>The following is an example of a very simple archetype, giving a feel for the syntax. The main point to glean from the following is that the notion of ‘guitar’ is defined in terms of <em>constraints</em> on a <em>generic</em> model of the concept "INSTRUMENT". The names mentioned down the left-hand side of the definition section (<code>INSTRUMENT</code>, <code>size</code> etc) are alternately class and attribute names from an object model.  Each block of braces encloses a specification for some particular set of instances that conform to a specific concept, such as ‘guitar’ or ‘neck’, defined in terms of constraints on types from a generic class model. The leaf pairs of braces enclose constraints on primitive types such as <code>Integer</code>, <code>String</code>, <code>Boolean</code> and so on. </p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5)
	adl-test-instrument.guitar.v1.0.4

language
	original_language = &lt;[iso_639-1::en]&gt;

definition
	INSTRUMENT[id1] matches {
		size matches {|60..120|} -- size in cm
		date_of_manufacture matches {yyyy-mm-??} -- year &amp; month ok
		parts cardinality matches {0..*} matches {
			PART[id2] matches { -- neck
				material matches {[ac1]} -- timber or nickel alloy
			}
			PART[id3] matches { -- body
				material matches {[at3]} -- timber
			}
		}
	}

terminology
	term_definitions = &lt;
		[&quot;en&quot;] = &lt;
			[&quot;id1&quot;] = &lt;
				text = &lt;&quot;guitar&quot;&gt;;
				description = &lt;&quot;stringed instrument&quot;&gt;
			&gt;
			[&quot;id2&quot;] = &lt;
				text = &lt;&quot;neck&quot;&gt;;
				description = &lt;&quot;neck of guitar&quot;&gt;
			&gt;
			[&quot;id3&quot;] = &lt;
				text = &lt;&quot;body&quot;&gt;;
				description = &lt;&quot;body of guitar&quot;&gt;
			&gt;
			[&quot;at3&quot;] = &lt;
				text = &lt;&quot;timber&quot;&gt;;
				description = &lt;&quot;straight, seasoned timber&quot;&gt;
			&gt;
			[&quot;at4&quot;] = &lt;
				text = &lt;&quot;nickel alloy&quot;&gt;;
				description = &lt;&quot;frets&quot;&gt;
			&gt;
		&gt;
	&gt;

	value_sets = &lt;
		[&quot;ac1&quot;] = &lt;
			id = &lt;&quot;ac1&quot;&gt;
				members = &lt;&quot;at3&quot;, &quot;at4&quot;&gt;
			&gt;
		&gt;
	&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_file_encoding_and_character_quoting">3. File Encoding and Character Quoting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_file_encoding">3.1. File Encoding</h3>
<div class="paragraph">
<p>Because ADL files are inherently likely to contain multiple languages due to internationalised authoring and translation, they must be capable of accommodating characters from any language. ADL files do not explicitly indicate an encoding because they are assumed to be in UTF-8 encoding of unicode.  For ideographic and script-oriented languuages, this is a necessity.</p>
</div>
<div class="paragraph">
<p>There are three places in ADL files where non-ASCII characters can occur:
* in string values, demarcated by double quotes, e.g. "xxxx";
* in regular expression patterns, demarcated by either <code>//</code> or <code>^^</code>;
* in character values, demarcated by single quotes, e.g. 'x'.</p>
</div>
<div class="paragraph">
<p>URIs (a data type in ODIN) are assumed to be ‘percent-encoded’ according to RFC 39861 <a href="#uri_syntax">[uri_syntax]</a>, which applies to all characters outside the ‘unreserved set’. The unreserved set is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>unreserved = ALPHA / DIGIT / "-" / "." / "_" / "~"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In actual fact, ADL files encoded in latin 1 (ISO-8859-1) or another variant of ISO-8859 - both containing accented characters with unicode codes outside the ASCII 0-127 range - may work perfectly well, for various reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the contain nothing but ASCII, i.e. unicode code-points 0 - 127; this will be the case in English- language authored archetypes containing no foreign words;</p>
</li>
<li>
<p>some layer of the operating system is smart enough to do an on-the-fly conversion of characters above 127 into UTF-8, even if the archetype tool being used is designed for pure UTF-8 only;</p>
</li>
<li>
<p>the archetype tool (or the string-processing libraries it uses) might support UTF-8 and ISO- 8859 variants.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For situations where binary UTF-8 (and presumably other UTF-* encodings) cannot be supported, ASCII encoding of unicode characters above code-point 127 should only be done using the system supported by many programming languages today, namely \u escaped UTF-16. In this system, unicode codepoints are mapped to either:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>\uHHHH</code> - 4 hex digits which will be the same (possibly 0-filled on the left) as the unicode code-point number expressed in hexadecimal; this applies to unicode codepoints in the range U+0000 - U+FFFF (the ‘base multi-lingual plane’, BMP);</p>
</li>
<li>
<p><code>\uHHHHHHHH</code> - 8 hex digits to encode unicode code-points in the range U+10000 through U+10FFFF (non-BMP planes); the algorithm is described in IETF RFC 27812 <a href="#rfc2781">[rfc2781]</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is not expected that the above approach will be commonly needed, and it may not be needed at all; it is preferable to find ways to ensure that native UTF-8 can be supported, since this reduces the burden for ADL parser and tool implementers. The above guidance is therefore provided only to ensure a standard approach is used for ASCII-encoded unicode, if it becomes unavoidable.</p>
</div>
<div class="paragraph">
<p>Thus, while <strong>the only officially designated encoding for ADL and its constituent syntaxes is UTF-8</strong>, real software systems may be more tolerant. This document therefore specifies that any tool designed to process ADL files need only support UTF-8; supporting other encodings is an optional extra. This could change in the future, if required by the ADL or openEHR user community.</p>
</div>
</div>
<div class="sect2">
<h3 id="_special_character_sequences">3.2. Special Character Sequences</h3>
<div class="paragraph">
<p>In strings and characters, characters not in the lower ASCII (0-127) range should be UTF-8 encoded, with the exception of quoted single- and double quotes, and some non-printing characters, for which the following customary quoted forms are allowed (but not required):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>\r</code> - carriage return</p>
</li>
<li>
<p><code>\n</code> - linefeed</p>
</li>
<li>
<p><code>\t</code> - tab</p>
</li>
<li>
<p><code>\\</code> - backslash</p>
</li>
<li>
<p><code>\"</code> - literal double quote</p>
</li>
<li>
<p><code>\'</code> - literal single quote</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Any other character combination starting with a backslash is illiegal; to get the effect of a literal backslash, the <code>\\</code> sequence should always be used.</p>
</div>
<div class="paragraph">
<p>Typically in a normal string, including multi-line paragraphs as used in ODIN, only <code>\\</code> and <code>\"</code> are likely to be necessary, since all of the others can be accommodated in their literal forms; the same goes for single characters - only <code>\\</code> and <code>\'</code> are likely to commonly occur. However, some authors may prefer to use <code>\n</code> and <code>\t</code> to make intended formatting clearer, or to allow for text editors that do not react properly to such characters. Parsers should therefore support the above list.</p>
</div>
<div class="paragraph">
<p>In regular expressions (only used in cADL string constraints), there will typically be backslashescaped characters from the above list as well as other patterns like <code>\s</code> (whitspace) and <code>\d</code> (decimal digit), according to the PERL regular expression specification (<a href="#Perl_regex">[Perl_regex]</a>). These should not be treated as anything other than literal strings, since they are processed by a regular expression parser.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cadl_constraint_adl">4. cADL - Constraint ADL</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_2">4.1. Overview</h3>
<div class="paragraph">
<p>cADL is a block-structured syntax which enables constraints on data defined by object-oriented information models to be expressed in archetypes or other knowledge definition formalisms. It is most useful for defining the specific allowable configurations of data whose instances conform to very general object models. cADL is used both at design time, by authors and/or tools, and at runtime, by computational systems which validate data by comparing it to the appropriate sections of cADL in an archetype. The general appearance of cADL is illustrated by the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] matches {                                -- constraint on a PERSON instance
        name matches {                                   -- constraint on PERSON.name
            TEXT[id2] matches {/.+/}                     -- any non-empty string
        }
        addresses cardinality matches {1..*} matches {   -- constraint on
            ADDRESS[id3] matches {                       -- PERSON.addresses
                -- etc --
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the textual keywords in this example can be more efficiently rendered using common mathematical logic symbols. In the following example, the <code>matches</code> keyword have been replaced by an equivalent symbol:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] ∈ {                            -- constraint on a PERSON instance
        name ∈ {                               -- constraint on PERSON.name
            TEXT[id2] ∈ {/..*/}                -- any non-empty string
        }
        addresses cardinality ∈ {1..*} ∈ {     -- constraint on
            ADDRESS[id3] ∈ {                   -- PERSON.addresses
                -- etc --
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The full set of equivalences appears below. Raw cADL is persisted in the text-based form, to remove any difficulties when authoring cADL text in normal text editors, and to aid reading in English. However, the symbolic form might be more widely used for display purposes and in more sophisticated tools, as it is more succinct and less language-dependent. The use of symbols or text is completely a matter of taste, and no meaning whatsoever is lost by completely ignoring one or other format according to one’s personal preference. This document uses both conventions.</p>
</div>
<div class="paragraph">
<p>In the standard cADL documented in this section, literal leaf values (such as the regular expression <code>/.+/</code> in the above example) are always constraints on a set of ‘standard’ widely-accepted primitive types, as described in the openEHR ODIN syntax specification.</p>
</div>
</div>
<div class="sect2">
<h3 id="_basics">4.2. Basics</h3>
<div class="sect3">
<h4 id="_keywords">4.2.1. Keywords</h4>
<div class="paragraph">
<p>The following keywords are recognised in cADL:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>matches</code>, <code>~matches</code>, <code>is_in</code>, <code>~is_in</code></p>
</li>
<li>
<p><code>occurrences</code>, <code>existence</code>, <code>cardinality</code></p>
</li>
<li>
<p><code>ordered</code>, <code>unordered</code>, <code>unique</code></p>
</li>
<li>
<p><code>use_node, allow_archetype</code></p>
</li>
<li>
<p><code>include</code>, <code>exclude</code></p>
</li>
<li>
<p><code>before</code> , <code>after</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Symbol equivalents for some of the above are given in the following table.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16%;">
<col style="width: 16%;">
<col style="width: 66%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Textual<br>
 Rendering</th>
<th class="tableblock halign-left valign-top">Symbolic<br>
 Rendering</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set membership, "p is in P"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">not, ~</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∼</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Negation, "not p"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∗</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Infinity, ‘any number of&#8230;&#8203;’</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_block_node_structure">4.2.2. Block / Node Structure</h4>
<div class="paragraph">
<p>cADL constraints are written in a block-structured style, similar to block-structured programming languages like C. A typical block resembles the following (the recurring pattern <code>/.+/</code> is a regular expression meaning "non-empty string"):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] ∈ {
        name ∈ {
            PERSON_NAME[id2] ∈ {
                forenames cardinality ∈ {1..*} ∈ {/.+/}
                family_name ∈ {/.+/}
                title ∈ {&quot;Dr&quot;, &quot;Miss&quot;, &quot;Mrs&quot;, &quot;Mr&quot;}
            }
        }
        addresses cardinality ∈ {1..*} ∈ {
            LOCATION_ADDRESS[id3] ∈ {
                street_number existence ∈ {0..1} ∈ {/.+/}
                street_name ∈ {/.+/}
                locality ∈ {/.+/}
                post_code ∈ {/.+/}
                state ∈ {/.+/}
                country ∈ {/.+/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, an identifier (shown in green in this document) followed by the ∈ operator (equivalent text keyword: <code>matches</code> or <code>is_in</code> ) followed by an open brace, is the start of a ‘block’, which continues until the closing matching brace (normally visually indented to match the line at the beginning of the block).</p>
</div>
<div class="paragraph">
<p>Two kinds of identifiers from the underlying information model are used, in alternation: type names (shown in upper case in this document) and attribute names (shown in lower case).</p>
</div>
<div class="paragraph">
<p>Blocks introduced by a type name are known as <em>object blocks</em> or <em>object nodes</em>, while those introduced by an attribute name are <em>attribute blocks</em> or <em>attribute nodes</em> as illustrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] ∈ {                     -- OBJECT block 1 ------------+
        name ∈ {                            -- attribute block A ---+ |
            PERSON_NAME[id2] ∈ { ... }          -- OBJECT block 2   + |
        }                                   -------------------------+ |
    }                                   -------------------------------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>An object block or node can be thought of as a constraint matching a set of instances of the type which introduces the block.</p>
</div>
<div class="paragraph">
<p>The example above expresses a constraint on an instance of the type <code>PERSON</code> ; the constraint is expressed by everything inside the <code>PERSON</code> block. The two blocks at the next level define constraints on properties of <code>PERSON</code> , in this case <code><em>name</em></code> and <code><em>addresses</em></code>. Each of these constraints is expressed in turn by the next level containing constraints on further types, and so on. The general structure is therefore a recursive nesting of constraints on types, followed by constraints on attributes (of that type), followed by types (being the types of the attribute under which it appears) until leaf nodes are reached.</p>
</div>
<div class="paragraph principle">
<p>A cADL text is a structure of alternating object and attribute blocks each introduced respectively by type names and attribute names from an underlying information model.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comments">4.2.3. Comments</h4>
<div class="paragraph">
<p>In a cADL text, comments are defined as follows:</p>
</div>
<div class="paragraph principle">
<p>Comments are indicated by the leader characters '--'. Multi-line comments are achieved using the '--' leader on each line where the comment continues.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_underlying_information_model">4.2.4. The Underlying Information Model</h4>
<div class="paragraph">
<p>Identifiers in cADL texts correspond to entities - types and attributes - in an information model. The latter is typically an object-oriented model, but may just as easily be an entity-relationship model or any other typed model of information. A UML model compatible with the example above is shown in <a href="#uml_model_of_person">UML Model of Person</a>. Note that there can be more than one model compatible with a given fragment of cADL syntax, and in particular, there are usually more properties and classes in the reference model than are mentioned in the cADL constraints. In other words, a cADL text includes constraints <em>only for those parts of a model that are useful or meaningful to constrain</em>.</p>
</div>
<div id="uml_model_of_person" class="imageblock text-center" style="text-align: center">
<div class="content">
<img src="uml_diagrams/ADL-demographics.svg" alt="ADL demographics">
</div>
<div class="title">Figure 2. UML Model of Person</div>
</div>
<div class="paragraph">
<p>Constraints expressed in cADL cannot be stronger than those from the information model. For example, the <code>PERSON</code>.<code><em>family_name</em></code> attribute is mandatory in the model in the above <code>PERSON</code> model, so it is not valid to express a constraint allowing the attribute to be optional. In general, a cADL archetype can only further constrain an existing information model. However, it must be remembered that for very generic models consisting of only a few classes and a lot of optionality, this rule is not so much a limitation as a way of adding meaning to information. Thus, for a demographic information model which has only the types <code>PARTY</code> and <code>PERSON</code>, one can write cADL which defines the concepts of entities such as <code>COMPANY</code> , <code>EMPLOYEE</code> , <code>PROFESSIONAL</code> , and so on, in terms of constraints on the types available in the information model.</p>
</div>
<div class="paragraph">
<p>This general approach can be used to express constraints for instances of any information model. The following example shows how to express a constraint on the <em>value</em> property of an <code>ELEMENT</code> class to be a <code>DV_QUANTITY</code> with a suitable range for expressing blood pressure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id10] matches {          -- diastolic blood pressure
        value matches {
            DV_QUANTITY[id11] matches {
                magnitude matches {|0..1000|}
                property matches {&quot;pressure&quot;}
                units matches {&quot;mm[Hg]&quot;}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this specification, the terms underlying information model and <em>reference model</em> are equivalent and refer to the information model on which a cADL text is based.</p>
</div>
<div class="sect4">
<h5 id="_information_model_identifiers">Information Model Identifiers</h5>
<div class="paragraph">
<p>Identifiers from the underlying information model are used to introduce all cADL nodes. Identifiers obey the same rules as in ODIN: type names commence with an upper case letter, while attribute and function names commence with a lower case letter. In cADL, names of types and the name of any property (i.e. attribute or parameterless function) can be used.</p>
</div>
<div class="paragraph principle">
<p>A <strong>type name</strong> is any identifier with an initial upper case letter, followed by any combination of letters, digits and underscores. A <strong>generic type name</strong> (including nested forms) additionally may include commas and angle brackets, but no spaces, and must be syntactically correct as per the OMG UML 2.x specification or higher. An <strong>attribute name</strong> is any identifier with an initial lower case letter, followed by any combination of letters, digits and underscores. Any convention that obeys this rule is allowed.</p>
</div>
<div class="paragraph">
<p>Type identifiers are shown in this document in all uppercase, e.g. <code>PERSON</code> , while attribute identifiers are shown in all lowercase, e.g. <code>home_address</code> . In both cases, underscores are used to represent word breaks. This convention is used to improve the readability of this document, and other conventions may be used, such as the common programmer’s mixed-case convention exemplified by <code>Person</code> and <code>homeAddress</code>. The convention chosen for any particular cADL document should be based on that used in the underlying information model.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_node_identifiers">4.2.5. Node Identifiers</h4>
<div class="paragraph">
<p>Node identifier codes appear after all type identifiers in a cADL text. They take the form of an ‘id-code’ in brackets, e.g. <code>[id3]</code>. The id-code of a root object in a structure is always <code>id1</code>, or for specialised archetypes, <code>id1.1</code>, <code>id1.1.1</code> etc. The rules and use of node identifiers is described in more detail below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_matches_operator">4.2.6. The matches Operator</h4>
<div class="paragraph">
<p>The <code>matches</code> or <code>is_in</code> operator deserves special mention, since it is the key operator in cADL. This operator can be understood mathematically as set membership. When it occurs between an identifier and a block delimited by braces, the meaning is: the set of values allowed for the entity referred to by the name (either an object, or parts of an object - attributes) is specified between the braces. What appears between any matching pair of braces can be thought of as a <em>specification for a set of values</em>. Since blocks can be nested, this approach to specifying values can be understood in terms of nested sets, or in terms of a value space for instances of a type. Thus, in the following example, the <code>matches</code> operator links the name of an entity to a linear value space (i.e. a list), consisting of all words ending in 'ion'.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    aaa `matches` {/\w*ion[\s\n\t ]/} -- the set of words ending in ‘ion’  </code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example links the name of a type <code>XXX</code> with a hierarchical value space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    XXX[id2] matches {
        xxx_attr1 matches {
            YYY[id3] matches {
                yyy_attr1 matches {0..3}
            }
        }
        xxx_attr2 matches {
            ZZZ[id4] matches {
                zzz_attr1 matches {&gt;1992-12-01}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of the syntax above is: data matching the constraints conssists of an instance of type <code>XXX</code> , or any subtype allowed by the underlying information model, for which the value of attribute <em>aaa</em> is of type <code>YYY</code> , or any subtype allowed by the underlying information model, and so on, recursively until leaf level constraints are reached.</p>
</div>
<div class="paragraph">
<p>Occasionally the <code>matches</code> operator needs to be used in the negative, usually at a leaf block. Any of the following can be used to constrain the value space of the attribute <code>aaa</code> to any number except 5:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    aaa ~matches {5}
    aaa ~is_in {5}
    aaa ∉ {5}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The choice of whether to use <code>matches</code> or <code>is_in</code> is a matter of taste and background; those with a mathematical background will probably prefer <code>is_in</code> , while those with a data processing background may prefer <code>matches</code> .</p>
</div>
</div>
<div class="sect3">
<h4 id="_natural_language">4.2.7. Natural Language</h4>
<div class="paragraph">
<p>cADL is completely independent of all natural languages. The only potential exception is where constraints include literal values from some language, and this is easily and routinely avoided by the use of separate language and terminology definitions, as used in ADL archetypes. However, for the purposes of readability, comments in English have been included in this document to aid the reader. In real cADL documents, comments are generated from the archetype terminology in the language of the locale.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constraints_on_complex_types">4.3. Constraints on Complex types</h3>
<div class="paragraph">
<p>This section describes the semantics for constraining objects of complex, i.e. non-primitive types. The semantics apply recursively through a constraint structure until leaf nodes constraining primitive types are reached.</p>
</div>
<div class="sect3">
<h4 id="_attribute_constraints">4.3.1. Attribute Constraints</h4>
<div class="paragraph">
<p>In any information model, attributes are either single-valued or multiply-valued, i.e. of a generic container type such as <code>List&lt;Contact&gt;</code> . Both have <em>existence</em> , while multiply-valued attributes also have <em>cardinality</em> .</p>
</div>
<div class="sect4">
<h5 id="_existence">Existence</h5>
<div class="paragraph">
<p>The existence constraint may be used with any attribute to further constrain the existence defined by the underlying reference model. An existence constraint indicates whether an attribute value is mandatory or optional, and is indicated by "0..1" or "1" markers at line ends in UML diagrams (and often mistakenly referred to as a "cardinality of 1..1"). Attributes defined in the reference model have an effective existence constraint, defined by the invariants (or lack thereof) of the relevant class. For example, the <em>protocol</em> attribute in the openEHR <code>OBSERVATION</code> class <a href="#EHR_IM">[EHR_IM]</a> is defined in the reference model as being optional, i.e. <code>0..1</code>. An archetype may redefine this to <code>{1..1}</code>, making the attribute mandatory. Existence constraints are expressed in cADL as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    OBSERVATION matches {
        protocol existence matches {1..1} matches {
            -- details
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of an existence constraint is to indicate whether a value - i.e. an object - is mandatory or optional (i.e. obligatory or not) in runtime data for the attribute in question. The same logic applies whether the attribute is of single or multiple cardinality, i.e. whether it is a container type or not. For container attributes, the existence constraint indicates whether the whole container (usually a list or set) is mandatory or not; a further cardinality constraint (described below) indicates how many members in the container are allowed.</p>
</div>
<div class="paragraph principle">
<p>An existence constraint may be used directly after any attribute identifier, and indicates whether the object to which the attribute refers is mandatory or optional in the data.</p>
</div>
<div class="paragraph">
<p>Existence is shown using the same constraint language as the rest of the archetype definition. Existence constraints can take the values <code>{0}</code> , <code>{0..0}</code> , <code>{0..1}</code> , <code>{1}</code> , or <code>{1..1}</code> . The first two of these constraints may not seem initially obvious, but can be used to indicate that an attribute must not be present in the particular situation modelled by the archetype. This may be reasonable in some cases.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_single_valued_attributes">4.3.2. Single-valued Attributes</h4>
<div class="paragraph">
<p>A single-valued attribute is an attribute whose type as declared in the underlying class model is of a single object type rather than a container type such as a list or set. Single-valued attributes can be constrained with a single object constraint as shown in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value matches {
        DV_QUANTITY[id22] matches {
            magnitude matches {|0..55|}
            property matches {&quot;velocity&quot;}
            units matches {&quot;mph&quot;}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple alternative object constraints can also be defined, using a number of sibling blocks, as shown in the following example. Each block defines an alternative constraint, only one of which needs to be matched by the data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value matches {
        DV_QUANTITY[id22] matches { -- miles per hour
            magnitude matches {|0..55|}
            property matches {&quot;velocity&quot;}
            units matches {&quot;mph&quot;}
        }
        DV_QUANTITY[id23] matches { -- km per hour
            magnitude matches {|0..100|}
            property matches {&quot;velocity&quot;}
            units matches {&quot;km/h&quot;}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the occurrences of both <code>DV_QUANTITY</code> constraints is not stated, leading to the result that only one <code>DV_QUANTITY</code> instance can appear in runtime data, matching either one of the constraints.</p>
</div>
<div class="paragraph principle">
<p>Two or more object constraints introduced by type names appearing after a single-valued attribute (i.e. one for which there is no cardinality constraint) are taken to be alternative constraints, only one of which is matched by the data.</p>
</div>
</div>
<div class="sect3">
<h4 id="_container_attributes">4.3.3. Container Attributes</h4>
<div class="sect4">
<h5 id="_cardinality">Cardinality</h5>
<div class="paragraph">
<p>The cardinality of container attributes may be constrained in cADL with the <em>cardinality</em> constraint. Cardinality indicates limits on the number of instance members of a container types such as lists and sets. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    HISTORY[id2] occurrences ∈ {1} ∈ {
        periodic ∈ {False}
        events cardinality ∈ {*} ∈ {
            EVENT[id3] occurrences ∈ {0..1} ∈ {    }           -- 1 min sample
            EVENT[id4] occurrences ∈ {0..1} ∈ {    }           -- 2 min sample
            EVENT[id5] occurrences ∈ {0..1} ∈ {    }           -- 3 min sample
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>cardinality</code> keyword implies firstly that the property events must be of a container type, such as <code>List&lt;T&gt;</code> , <code>Set&lt;T&gt;</code> , <code>Bag&lt;T&gt;</code> . The integer range indicates the valid membership of the container; a single '<strong>' means the range '0..</strong>', i.e. '0 to many'. The type of the container is not explicitly indicated, since it is usually defined by the information model. However, the semantics of a logical set (unique membership, ordering not significant), a logical list (ordered, non-unique membership) or a bag (unordered, non-unique membership) can be constrained using the additional keywords <code>ordered</code> , <code>unordered</code> , <code>unique</code> and <code>non-unique</code> within the cardinality constraint, as per the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">        events cardinality ∈ {*; ordered} ∈ {                   -- logical list
        events cardinality ∈ {*; unordered; unique} ∈ {         -- logical set
        events cardinality ∈ {*; unordered} ∈ {                 -- logical bag</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no numeric or ordering constraint on the cardinality of a container attribute is required, the keyword is used on its own, and simply indicates that the attribute is a container, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    events cardinality ∈ { -- indicates ‘events’ is a container</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although this is not strictly ncessary for the purpose of expressing valid archetypes if the Reference Model can usually be referred to, it enables early stage parsing to generate the correct type of attributes without referring to a Reference Model schema, which in any case may not always be available. This in turn enables more faithful visualisation at an earlier point in the archetype compilation process.</p>
</div>
<div class="paragraph">
<p>In theory, no cardinality constraint can be stronger than the semantics of the corresponding container in the relevant part of the reference model. However, in practice, developers often use lists to facilitate data integration, when the actual semantics are intended to be of a set; in such cases, they typically ensure set-like semantics in their own code rather than by using an <code>Set&lt;T&gt;</code> type. How such constraints are evaluated in practice may depend somewhat on knowledge of the software system.</p>
</div>
<div class="paragraph principle">
<p>A cardinality constraint must be used after any Reference Model container attribute name (or after its existence constraint, if there is one) in order to designate it as a container attribute. Additionally, it may constrain the number of member items it may have in the data, and whether it has "list", "set", or "bag" semantics, via the use of the keywords ‘ordered’, ‘unordered’, ‘unique’ and ‘non-unique’.</p>
</div>
<div class="paragraph">
<p>The numeric part of the cardinality contraint can take the values <code>{0}</code>, <code>{0..0}</code>, <code>{0..n}</code>, <code>{m..n}</code>, <code>{0..<strong>}</code>, or <code>{</strong>}</code>, or a syntactic equivalent. The first two of these constraints are unlikely to be useful, but there is no reason to prevent them. There is no default cardinality, since if none is shown, the relevant attribute is assumed to be single-valued (in the interests of uniformity in archetypes, this holds even for smarter parsers that can access the reference model and determine that the attribute is in fact a container.</p>
</div>
<div class="paragraph">
<p>Cardinality and existence constraints can co-occur, in order to indicate various combinations on a container type property, e.g. that it is optional, but if present, is a container that may be empty, as in the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    events existence ∈ {0..1} cardinality ∈ {0..*} ∈ {-- etc --}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_object_constraints">4.3.4. Object Constraints</h4>
<div class="sect4">
<h5 id="_node_identifiers_2">Node Identifiers</h5>
<div class="paragraph">
<p>In cADL, an entity in brackets of the form <code>[idN]</code> following a type name is used to identify an object node, i.e. a node constraint delimiting a set of instances of the type as defined by the reference model. Object nodes always commence with a type name. Although any node identifier format could be supported, the current version of ADL assumes that node identifiers are of the form of an archetype term identifier, i.e. <code>[idN]</code> , e.g. <code>[id42]</code> . Node identifiers are shown in magenta in this document.</p>
</div>
<div class="paragraph">
<p>The structural function of node identifiers is to allow the formation of paths:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>enable cADL nodes in an archetype definition to be unambiguously referred to within the same archetype;</p>
</li>
<li>
<p>enable data created using a given archetype to be matched at runtime;</p>
</li>
<li>
<p>to enable cADL nodes in a parent archetype to be unambiguously referred to from a specialised child archetype;</p>
</li>
<li>
<p>to enable unique paths to be formed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All object nodes require a node identifier, guaranteeing the ability to generate unique paths, and to process specialised archetypes with respect to inheritance parents.</p>
</div>
<div class="paragraph principle">
<p>A Node identifier is required for every object node in an archetype.</p>
</div>
<div class="paragraph">
<p>The node identifier can also perform a semantic function, that of giving a design-time meaning to the node, by equating the node identifier to some description. The use of node identifiers in archetypes is the main source of their expressive power. Each node identifier acts as a ‘semantic marker’ or ‘override’ on the node. Thus, in the example shown in <a href="#_the_underlying_information_model">The Underlying Information Model</a>, the <code>ELEMENT</code> node is identified by the code <code>[id10]</code> , which can be designated elsewhere in an archetype as meaning "diastolic blood pressure". In this way rich meaning is given to data constructed from a limited number of object types.</p>
</div>
<div class="paragraph">
<p>Not every node identifier needs to be defined in the archetype terminology: it is only mandatory for nodes defined under container attributes. Nodes defined under single-valued attributes may have terminology definitions, but don’t typically need them, since the meaning is obvious from the attribute.</p>
</div>
</div>
<div class="sect4">
<h5 id="_occurrences">Occurrences</h5>
<div class="paragraph">
<p>A constraint on occurrences is used only with cADL object nodes, to indicate how many times in data an instance conforming to the constraint can occur. It is usually only defined on objects that are children of a container attribute, since by definition, the occurrences of an object that is the value of a single-valued attribute can only be <code>0..1</code> or <code>1..1</code>, and this is already defined by the attribute’s <code>existence</code>. However, it may be used in specialised archetypes to exclude a possibility defined in a parent archetype (see <a href="#_attribute_redefinition">Attribute Redefinition</a>).</p>
</div>
<div class="paragraph">
<p>In the example below, three <code>EVENT</code> constraints are shown; the first one ("1 minute sample") is shown as mandatory, while the other two are optional.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    events cardinality ∈ {*} ∈ {
        EVENT[id2] occurrences ∈ {1..1} ∈ {    }          -- 1 min sample
        EVENT[id3] occurrences ∈ {0..1} ∈ {    }          -- 2 min sample
        EVENT[id4] occurrences ∈ {0..1} ∈ {    }          -- 3 min sample
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example expresses a constraint on instances of <code>GROUP</code> such that for <code>GROUPs</code> representing tribes, clubs and families, there can only be one "head", but there may be many members.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    GROUP[id103] ∈ {
        kind ∈ {/tribe|family|club/}
        members cardinality ∈ {*} ∈ {
            PERSON[id104] occurrences ∈ {1} ∈ {
                title ∈ {&quot;head&quot;}
                -- etc --
            }
            PERSON[id105] occurrences ∈ {0..*} ∈ {
                title ∈ {&quot;member&quot;}
                -- etc --
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first <code>occurrences</code> constraint indicates that a <code>PERSON</code> with the title <code>"head"</code> is mandatory in the <code>GROUP</code> , while the second indicates that at runtime, instances of <code>PERSON</code> with the title <code>"member"</code> can number from none to many. Occurrences may take the value of any range including <code>{0..*}</code>, meaning that any number of instances of the given type may appear in data, each conforming to the one constraint block in the archetype. A single positive integer, or the infinity indicator, may also be used on its own, thus: <code>{2}</code> , <code>{*}</code> . A range of <code>{0..0}</code> or <code>{0}</code> indicates that no occurrences of this object are allowed in this archetype. If no occurrences constraint is stated, the occurrences of the object is define by the underlying reference model.</p>
</div>
<div class="paragraph principle">
<p>An occurrences constraint may appear directly after the type name of any object constraint within a container attribute, in order to indicate how many times data objects conforming to the block may occur in the data.</p>
</div>
<div class="paragraph">
<p>Where cardinality constraints are used (remembering that occurrences is always there by default, if not explicitly specified), cardinality and occurrences must always be compatible. The rules for this are formally stated in the Archetype Object Model specification. The key elements of these rules are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>where a cardinality constraint is stated with a finite upper bound:</p>
<div class="ulist">
<ul>
<li>
<p>any child object with either stated occurrences with an open upper bound (typically <code>0..*</code> or <code>1..\*</code>) or else inferred occurrences (<code>0..*</code>) is legal, since the occurrences open upper bound is interpreted to mean the maximum value allowed by the cardinality upper bound.</p>
</li>
<li>
<p>the sum of all child object occurrences lower bounds must be less than the cardinality upper bound;</p>
</li>
</ul>
</div>
</li>
<li>
<p>no ‘orphans’: at least instance of one optional child object (occurrences lower bound = 0), and one instance of every mandatory child object (occurrences lower bound &gt; 0) must be includable within the cardinality range.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="__any_constraints">4.3.5. "Any" Constraints</h4>
<div class="paragraph">
<p>There are two cases where it is useful to state a completely open, or ‘any’, constraint. The first is when it is desired to override the existence or cardinality of a property, such as in the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id2] ∈ {
        name existence ∈ {1}
        -- etc --
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, no further <code>matches {}</code> part is required in the statement, since no more constraints are to be stated.</p>
</div>
<div class="paragraph">
<p>The second use of "any" as a constraint value is for types, such as in the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id4] ∈ {          -- speed limit
        value ∈ {
            DV_QUANTITY[id5]  -- type was ‘DATA_VALUE’ in RM
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of this constraint is that in the data at runtime, the <em>value</em> property of <code>ELEMENT</code> must be of type <code>DV_QUANTITY</code> , but can have any value internally. This is most useful for constraining objects to be of a certain type, without further constraining value, and is especially useful where the information model contains subtyping, and there is a need to restrict data to be of certain subtypes in certain contexts.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In ADL 1.4, ‘any’ constraints were represented with an additional <code>matches {*}</code> at the end of the statement. This is deprecated. It is recommended that parsers silently accept this form, but output the modern ADL 1.5 form.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_reference_model_type_matching">4.3.6. Reference Model Type Matching</h4>
<div class="paragraph">
<p>All cADL object constraints state a type from an underlying reference model. This may be an abstract type or a concrete type. The part of the data conforming to the constraint can be of any concrete type from the reference model that conforms to the type mentioned in the constraint, i.e. the same type if it is concrete, or any subtype. Correctly evaluating data/archetype conformance is up to tools to implement, and requires access to a formal description of the reference model.</p>
</div>
<div class="paragraph">
<p>One of the consequences of subtype-based type matching is that semantics are needed for when more than one reference model subtype is declared under the same attribute node in cADL. Consider the reference model inheritance structure shown below, in which the abstract <code>PARTY</code> class has abstract and concrete descendants including <code>ACTOR</code>, <code>ROLE</code>, and so on.</p>
</div>
<div id="rm_subtypes" class="imageblock text-center" style="text-align: center">
<div class="content">
<img src="uml_diagrams/ADL-demographics-parties.svg" alt="ADL demographics parties">
</div>
<div class="title">Figure 3. Reference Model Sub-type Hierarchy</div>
</div>
<div class="sect4">
<h5 id="_narrowed_subtype_constraints">Narrowed Subtype Constraints</h5>
<div class="paragraph">
<p>The following cADL statement defines an instance space that includes instances of any of the concrete subtypes of the <code>PARTY</code> class within an instance of the class <code>XXXX</code> in the figure (the ellipsis indicates particular constrraints not shown here).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    counter_party ∈ {
        PARTY[id4] ∈ { ... }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in some circumstances, it may be desirable to define a constraint that will match a particular subtype in a specific way, while other subtypes are matched by the more general rule. Under a single-valued attribute, this can be done as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    counter_party ∈ {
        PARTY[id4] ∈ { ... }
        PERSON[id5] ∈ {
            date_of_birth ∈ { ... }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This cADL text says that the instance value of the <em>counter_party</em> attribute in the data can either be a <code>PERSON</code> object matching the <code>PERSON</code> block, with a <em>date_of_birth</em> matching the given range, or else any other kind of <code>PARTY</code> object.</p>
</div>
<div class="paragraph">
<p>Under a multiply-valued attribute, the alternative subtypes are included as identified child members. The following example illustrates a constraint on the <em>counter_parties</em> attribute of instances of the class <code>YYYY</code> in <a href="#Reference model with abstract and concrete subtypes">[Reference model with abstract and concrete subtypes]</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    counter_parties ∈ {
        PERSON[id4] ∈ {
            date_of_birth ∈ { ... }
        }
        ORGANISATION[id5] ∈ {
            date_of_registration ∈ { ... }
        }
        PARTY[id6] ∈ { ... }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above says that <code>ORGANISATION</code> and <code>PERSON</code> instances in the data can only match the <code>ORGANISATION</code> and <code>PERSON</code> constraints stated above, while an instance any other subtype of <code>PARTY</code> must match the <code>PARTY</code> constraint.</p>
</div>
</div>
<div class="sect4">
<h5 id="_remove_specified_subtypes">Remove Specified Subtypes</h5>
<div class="paragraph">
<p>In some cases it is required to remove some subtypes altogether. This is achieved by stating a constraint on the specific subtypes with <code>occurrences</code> limited to zero. The following example matches any <code>PARTY</code> instance with the exception of instances of <code>COMPANY</code> or <code>GROUP</code> subtypes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    counter_party ∈ {
        PARTY[id4] ∈ { ... }
        COMPANY[id5] occurrences ∈ {0}
        GROUP[id6] occurrences ∈ {0}
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_paths">4.3.7. Paths</h4>
<div class="sect4">
<h5 id="_archetype_path_formation">Archetype Path Formation</h5>
<div class="paragraph">
<p>The use of identified object nodes allows the formation of archetype paths, which can be used to unambiguously reference object nodes within the same archetype or within a specialised child. The syntax of archetype paths is designed to be close to the W3C Xpath syntax, and can be directly converted to it for use in XML.</p>
</div>
<div class="paragraph principle">
<p>Archetype paths are paths extracted from the definition section of an archetype, and refer to object nodes within the definition. A path is constructed as a concatenation of ‘/’ characters and attribute names, with the latter including node identifiers as predicates where required for disambiguation.</p>
</div>
<div class="paragraph">
<p>In the following example, the <code>PERSON</code> constraint node is the sole object constraint under the single-valued attribute manager:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    manager ∈ {
        PERSON[id104] ∈ {
            title ∈ {&quot;head of finance&quot;, &quot;head of engineering&quot;}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two valid paths to the object under the <em>title</em> attribute are possible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    manager[id104]/title manager/title  </code></pre>
</div>
</div>
<div class="paragraph">
<p>Where there are more than one sibling node, node identifiers must be used to ensure unique referencing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    employees ∈ {
        PERSON[id104] ∈ {
            title ∈ {&quot;head&quot;}
        }
        PERSON[id105] matches {
            title ∈ {&quot;member&quot;}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The paths to the respective <em>title</em> attributes are now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    employees[id104]/title
    employees[id105]/title</pre>
</div>
</div>
<div class="paragraph">
<p>The following gives another example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    HISTORY[id1] occurrences ∈ {1} ∈ {
        periodic ∈ {False}
        events cardinality ∈ {*} ∈ {
            EVENT[id2] occurrences ∈ {0..1} ∈ {    }           -- 1 min sample
            EVENT[id3] occurrences ∈ {0..1} ∈ {    }           -- 2 min sample
            EVENT[id4] occurrences ∈ {0..1} ∈ {    }           -- 3 min sample
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following paths can be constructed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    /                      -- the HISTORY (root) object
    /periodic              -- the HISTORY.periodic attribute
    /events[id2]           -- the 1 minute event object
    /events[id3]           -- the 2 minute event object
    /events[id4]           -- the 3 minute event object</pre>
</div>
</div>
<div class="paragraph">
<p>The above paths can all be used to reference the relevant nodes within the archetype in which they are defined, or within any specialised child archetype.</p>
</div>
<div class="paragraph">
<p>Paths used in cADL are expressed in the ADL path syntax, described in detail in <a href="#_adl_paths">ADL Paths</a>. ADL paths have the same alternating object/attribute structure implied in the general hierarchical structure of cADL, obeying the pattern <code>TYPE/attribute/TYPE/attribute/</code> &#8230;&#8203; .</p>
</div>
<div class="paragraph">
<p>The examples above are <em>physical</em> paths because they refer to object nodes using node identifier codes such as "id4". Physical paths can be converted to <em>logical</em> paths by adding the code meanings as annotations for node identifiers, if defined. Thus, the following two paths might be equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    /events[id4]                       -- the 3 minute event object
    /events[id4|3 minute event|]       -- the 3 minute event object</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_external_use_of_paths">External Use of Paths</h5>
<div class="paragraph">
<p>None of the paths shown above are valid outside the cADL text in which they occur, since they do not include an identifier of the enclosing artefact, normally an archetype. To reference a cADL node in an archetype from elsewhere (e.g. another archetype or a template), the identifier of the containing itself must be prefixed to the path, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    [openehr-ehr-entry.apgar-result.v]/events[id2]</pre>
</div>
</div>
<div class="paragraph">
<p>This kind of path expression is necessary to form the paths that occur when archetypes are composed to form larger structures.</p>
</div>
</div>
<div class="sect4">
<h5 id="_runtime_paths">Runtime Paths</h5>
<div class="paragraph">
<p>Paths for use with runtime data can be constructed in the same way as archetype paths, and are the same except for single-valued attributes. Since in data only a single instance can appear as the value of a single-valued attribute, there is never any ambiguity in referencing it, whereas an archetype path to or through the same attribute may require a node identifier due to he possible presence of multiple alternatives. Consider the example from above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    items cardinality matches {*} matches
        ELEMENT[id4] matches {  -- speed limit
            value matches {
                DV_QUANTITY[id22] matches {                       -- miles per hour
                    magnitude matches {|0..55|}
                    property matches {&quot;velocity&quot;}
                    units matches {&quot;mph&quot;}
                }
                DV_QUANTITY[id23] matches {                       -- km per hour
                    magnitude matches {|0..100|}
                    property matches {&quot;velocity&quot;}
                    units matches {&quot;km/h&quot;}
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following archetype paths can be constructed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    items[id4]/value[id22]
    items[id4]/value[id23]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For instance data created according to this archetype, the following runtime path can be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    items[id4]/value               -- since there is only one DV_QUANTITY in the data</code></pre>
</div>
</div>
<div class="paragraph">
<p>A query using this path will match the data regardless of which type of <code>DV_QUANTITY</code> object is there. However, in some circumstances, queries may need to be specific, in which case they will use the full archetype path, i.e. <code>items[id4]/value[id22]</code> or <code>items[id4]/value[id23]</code> to select only ‘miles’ or ‘kilometres’ data. This will only work if the node ids (id-codes) are in fact stored in all types of the reference model data. If for example this was not the case with the <code>DV_QUANTITY</code> type, another facet of the <code>DV_QUANTITY</code> objects from the archetype such as ‘units = "km/h"’ would need to be used in the query to correctly locate only metric <code>DV_QUANTITY</code> objects.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_internal_references_proxy_constraint_objects">4.3.8. Internal References (Proxy Constraint Objects)</h4>
<div class="paragraph">
<p>It is possible to define a constraint structure at a certain point to be the same as a structure defined elsewhere in the archetype, rather than copying the desired structure. This is achieved using a proxy constraint object, using the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_node TYPE[idN] archetype_path</code></pre>
</div>
</div>
<div class="paragraph">
<p>This statement defines a node of type <code>TYPE</code>, whose definition is the same as the one found at path <code>archetype_path</code>. The type mentioned in the <code>use_node</code> reference must always be the same type as the referenced type.</p>
</div>
<div class="paragraph">
<p>The path must not be in the parent path of the proxy object itself, but may be a sibling of the proxy object. The sibling case is a special case, and the meaning of the proxy constraint is that the target object’s children should be re-used, but not the target itself (since that would illegally create two siblings with the same identifier). The general case is that the proxy object and target object locations are different, and the meaning is that the proxy object is logically replaced by a deep copy of the target object. (In theory the sibling case could be banned, and proxies defined one level further down with targets of the children of the originally intended target, but this creates inconvenience for the archetype author, and can easily be dealt with in tools).</p>
</div>
<div class="paragraph">
<p>Occurrences from the target are also assumed, or may be explicitly overridden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_node TYPE[id4] occurrences ∈ {occ} archetype_path</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proxy objects provide an internal reuse mechanism. Specialised archetypes may redefine structures on such nodes as if they had been defined inline. This is described in more detail in <a href="#_internal_reference_proxy_object_redefinition">Internal Reference (Proxy Object) Redefinition</a> in the <a href="#_specialisation">Specialisation</a> section.</p>
</div>
<div class="paragraph principle">
<p>A proxy constraint object allows object constraints defined elsewhere to be re-used within the same archetype or a specialised child.</p>
</div>
<div class="paragraph">
<p>The following example shows the definitions of the <code>ADDRESS</code> nodes for phone, fax and email for a home <code>CONTACT</code> being reused for a work <code>CONTACT</code> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] ∈ {
        identities ∈ {
            -- etc --
        }
        contacts cardinality ∈ {0..*} ∈ {
            CONTACT[id2] ∈ {      -- home address
                purpose ∈ {-- etc --}
                addresses ∈ {-- etc --}
            }
            CONTACT[id3] ∈ {      -- postal address
                purpose ∈ {-- etc --}
                addresses ∈ {-- etc --}
            }
            CONTACT[id4] ∈ {      -- home contact
                purpose ∈ {-- etc --}
                addresses cardinality ∈ {0..*} ∈ {
                    ADDRESS[id5] ∈ {                            -- phone
                        type ∈ {-- etc --}
                        details ∈ {-- etc --}
                    }
                    ADDRESS[id6] ∈ {                            -- fax
                        type ∈ {-- etc --}
                        details ∈ {-- etc --}
                    }
                    ADDRESS[id7] ∈ {                            -- email
                        type ∈ {-- etc --}
                        details ∈ {-- etc --}
                    }
                }
            }
            CONTACT[id8] ∈ {                                    -- work contact
                purpose ∈ {-- etc --}
                addresses cardinality ∈ {0..*} ∈ {
                    use_node ADDRESS[id9] /contacts[id4]/addresses[id5]    -- phone
                    use_node ADDRESS[id10] /contacts[id4]/addresses[id6]   -- fax
                    use_node ADDRESS[id11] /contacts[id4]/addresses[id7]   -- email
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the occurrences being overridden in the referring node, to enable the specification for ‘phone’ to be re-used, but with a different occurrences constraint.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PERSON[id1] ∈ {
        contacts cardinality ∈ {0..*} ∈ {
            CONTACT[id4] ∈ {                                   -- home contact
                addresses cardinality ∈ {0..*} ∈ {
                    ADDRESS[id5] occurrences ∈ {1} ∈ { ...}   -- phone
                }
            }
            CONTACT[id8] ∈ {                                  -- work contact
                addresses cardinality ∈ {0..*} ∈ {
                    use_node ADDRESS[id9] occurrences ∈ {0..*}
                            /contacts[id4]/addresses[id5]      -- phone
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_paths_and_proxy_objects">Paths and Proxy Objects</h5>
<div class="paragraph">
<p>In forming paths through the proxy and to nodes below the target, two cases can be identified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if the proxy object is a sibling of the target object, the proxy object node identifier is used in paths, and the node id of the target object is not;</p>
</li>
<li>
<p>otherwise, paths are formed using the identifier from the proxy target object.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_external_references">4.3.9. External References</h4>
<div class="paragraph">
<p>Another kind of reference in an archetype is to another archetype. There are two ways this can be done: using a direct reference, and using an archetype ‘slot’. The first is used when the need is to refer to one specific archetype (or to a template from another template), while the second is a constraint that allows for various archetypes matching specified criteria to be used. The slot concept is described in the next section.</p>
</div>
<div class="paragraph principle">
<p>An external reference defines a fixed compositional connection between two archetypes.</p>
</div>
<div class="paragraph">
<p>Direct references, or external references as they will be denoted here occur for two main reasons: re-use and templating. In the first case, an archetype has originally been built using inline constraints when it is discovered that another archetype contains the same or very similar inline constraints at a similar point. As would be normal in software design, a refactoring exercise is conducted that results in the common part being created as its own, new archetype, and both original archetypes ‘referring’ to it. They do this using an external reference, which has syntax of the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_archetype TYPE[idN, archetype_id] [occurrences constraint]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the <code>archetype_id</code> is included with the usual archetype node identifier (id-code). The usual occurrence constraints can be applied at the end.</p>
</div>
<div class="paragraph">
<p>The following example shows sections of two parent archetypes both referring to the same child archetype. The first section is from an openEHR <code>INSTRUCTION</code> archetype to do with a medication order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    INSTRUCTION[id1] ∈ {                                       -- Medication order
        activities cardinality ∈ {0..*; unordered} matches {
            ACTIVITY[id2] ∈ {                                  -- Medication activity
                action_archetype_id ∈ {/openEHR-EHR-ACTION\.medication\.v1/}
                description ∈ {
                    use_archetype ITEM_TREE[id3, openEHR-EHR-ITEM_TREE.medication.v1]
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This section is from an openEHR <code>ACTION</code> archetype defining medication administration actions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ACTION[id1] ∈ {                          -- Medication action
        ism_transition ∈ {
            ISM_TRANSITION[id2] ∈ { ... }
            ...
        }
        description ∈ {
            use_archetype ITEM_TREE[id3, openEHR-EHR-ITEM_TREE.medication.v1]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of these archetypes refers to the openEHR <code>ITEM_TREE</code> archetype <code>openEHR-EHR-ITEM_TREE.medication.v1</code> , which is a normal archetype describing medication.</p>
</div>
<div class="paragraph">
<p>Following the standard object-oriented semantics of type substitutability, and also the ontological subsumption notion, specialisations of the referenced archetype (including templates) are also valid substitutions at design or runtime. At design time, this takes the form of a redefinition, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    description ∈ {
        use_archetype ITEM_TREE[id3.1, openEHR-EHR-ITEM_TREE.vaccine.v1]
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>where the ‘vaccine’ archetype is a specialisation of the ‘medication’ archetype. Redefinitions of this kind are described in more detail in the section <a href="#_external_reference_redefinition">External Reference Redefinition</a>.</p>
</div>
<div class="paragraph">
<p>External references can of course also be defined under container attributes.</p>
</div>
<div class="paragraph">
<p>The second use of external references is typically in templates, to specify an archetype or sub-template of a template for an attribute where no slot has been defined. This use is described in the openEHR Template specification.</p>
</div>
<div class="sect4">
<h5 id="_paths_2">Paths</h5>
<div class="paragraph">
<p>Paths that terminate in external reference nodes in source-form archetypes will include only the id-codes, as in the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    /activities[id2]/description[id3]
    /description[id2]</pre>
</div>
</div>
<div class="paragraph">
<p>Howver, in flattened archetypes, the corresponding paths will include the archetype identifier(s) rather than the id-codes, and may continue down through the structure of the included archetypes, as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    /activities[id2]/description[openEHR-EHR-ITEM_TREE.medication.v1]/...
    /description[openEHR-EHR-ITEM_TREE.medication.v1]/...</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_archetype_slots">4.3.10. Archetype Slots</h4>
<div class="paragraph">
<p>At any point in a cADL definition, a constraint can be defined that allows other archetypes to be used, rather than defining the desired constraints inline. This is known as an archetype ‘slot’, i.e. a connection point whose allowable ‘fillers’ are constrained by a set of statements, written in the ADL assertion language (defined in the <a href="#_assertions">Assertions</a> section.</p>
</div>
<div class="paragraph principle">
<p>An archetype slot defines a constrained compositional chaining point in an archetype at which other archetypes can be inserted, if they are in the set defined by the slot constraint.</p>
</div>
<div class="paragraph">
<p>An archetype slot is introduced with the keyword <code>allow_archetype</code> and defined in terms of two lists of assertion statements defining which archetypes are allowed and/or which are excluded from filling that slot, introduced with the keywords <code>include</code> and <code>exclude</code> , respectively. The following example illustrates the general form of an archetype slot.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype SECTION[id5] occurrences ∈ {0..*} ∈ {
        include
            -- constraints for inclusion
        exclude
            -- constraints for exclusion
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A slot constraint evaluates to a set of archetype identifiers from whatever is considered in the current model environment to be the total available set of archetypes.</p>
</div>
<div class="paragraph">
<p>The simplest possible slot has no includes or excludes, and effectively imposes no constraint. However, it is allowed in order to enable authoring tools to create a slot whose actual constraint definition will be defined at a later point in time.</p>
</div>
<div class="paragraph">
<p>A slot is designed to be ‘filled’, i.e. to have one of the allowed archetypes chosen for use. This is done in a child archetype, almost always a template. A slot can also be ‘closed’, meaning no further fillers can be added.</p>
</div>
<div class="paragraph">
<p>The actual specification of slot fillers, and also the ‘closing’ of slots is done in specialised archetypes, and is described in the section <a href="#_slot_filling_and_redefinition">Slot Filling and Redefinition</a>, in the chapter on specialisation.</p>
</div>
<div class="sect4">
<h5 id="_formal_semantics_of_include_and_exclude_constraints">Formal Semantics of include and exclude Constraints</h5>
<div class="paragraph">
<p>The semantics of the <code>include</code> and <code>exclude</code> lists are somewhat subtle. They are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The meaning of the ‘set of all archetypes’ in any given environment is evaluable (and evaluated) to a finite set consisting of all archetypes available within the current archetype Library, not some notional virtual / global set of archetypes, or theoretical possible set.</p>
</li>
<li>
<p>Either the <code>include</code> or <code>exclude</code> constraint, but not both, may be ‘substantive’, i.e. define a particular set of archetypes that would be matched within a given slot, or ‘open’, i.e. matching all possible archetypes.</p>
</li>
<li>
<p>A slot constraint may consist of a single <code>include</code> or <code>exclude</code> constraint, or of an <code>include</code> / <code>exclude</code> pair.</p>
</li>
<li>
<p>If an <code>include</code> or <code>exclude</code> constraint is present on its own, it is understood as a recommendation, i.e. it does not constitute a formal constraint for matching or exclusion, but tools and applications may use the recommended match set in an intelligent way. The result set for such an <code>include</code> or <code>exclude</code> is the whole current archetype set.</p>
</li>
<li>
<p>If a substantive <code>include</code> or <code>exclude</code> constraint is present with a corresponding open <code>exclude</code> or <code>include</code> , respectively, the substantive constraint is considered formally binding.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The meaning of the slot constraint overall is that only archetypes matching the <code>include</code> constraint are allowed, and no others. The same logic applies in the reverse sense when the <code>exclude</code> constraint is substantive.</p>
</div>
</div>
<div class="sect4">
<h5 id="_semantic_slot_definition">Semantic Slot Definition</h5>
<div class="paragraph">
<p>There are various ways to define any other form of slot. The preferred approach is to define the set of allowable archetypes in terms of subsumption hierarchies within the archetype model space of the working Archetype Library. Such a constraint is formed from one or more expressions of the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    archetype_id matches {&lt;subsumption_expression&gt;}</pre>
</div>
</div>
<div class="paragraph">
<p>where subsumption_expression is one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an archetype ontology entity</p>
</li>
<li>
<p><code>'&lt;'</code> | <code>'&lt;&lt;'</code> an archetype ontology entity</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>and the unary operators ‘&lt;‘ and ‘&lt;&lt;‘ have the following meanings:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;</code> : descendant-of</p>
</li>
<li>
<p><code>&lt;&lt;</code> : descendant-of-or-self</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An archetype ontology entity is either a Reference Model class name or an Archetype semantic identifier.</p>
</div>
<div class="paragraph">
<p>A simple slot definition of this form is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype ENTRY[id4] occurrences matches {0..*} matches {
        include
            archetype_id matches {&lt; openEHR-EHR-OBSERVATION}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This constrains the archetype that can be used in the slot to being any based on the openEHR ` OBSERVATION` class.</p>
</div>
<div class="paragraph">
<p>The following example shows a more typical slot definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype CLUSTER[id26] ∈ {
        include
            archetype_id ∈ {&lt;&lt; openEHR-EHR-CLUSTER.medical_device.v1}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the archetype openEHR-EHR-CLUSTER.medical_device.v1 or any child can be used.</p>
</div>
<div class="paragraph">
<p>More complex constraints can be created using Boolean expressions containing subsumption terms, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype CLUSTER[id26] ∈ {
        include
            archetype_id ∈ {
                (&lt;&lt;openEHR-EHR-CLUSTER.medical_device.v1 or &lt;&lt;openEHR-EHR-CLUSTER.method.v1) and
                not &lt;&lt; openEHR-EHR-CLUSTER.protocol.v1
            }
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_slots_based_on_lexical_archetype_identifiers">Slots based on Lexical Archetype Identifiers</h5>
<div class="paragraph">
<p>Prior to ADL2, slots were defined using regular expressions on the archetype lexical identifier. This form remains legal in ADL2.0.x, but will be deprecated in future.</p>
</div>
<div class="paragraph">
<p>In this kind of slot constraint, the core expression type is of the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    archetype_id/value ∈ {/openEHR-EHR-\.SECTION\..*\..*/}</code></pre>
</div>
</div>
<div class="paragraph">
<p>where archetype_id/value stands for the literal String value of the archetype identifier, and the regular expression is recognised as occurring between two slash delimiters (//).</p>
</div>
<div class="paragraph">
<p>The following example shows how the "Objective" <code>SECTION</code> in a problem/SOAP headings archetype defines two slots, indicating which <code>OBSERVATION</code> and <code>SECTION</code> archetypes are allowed and excluded under the <code><em>items</em></code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION [at2000] occurrences ∈ {0..1} ∈ {                      -- objective
        items cardinality ∈ {0..*} ∈ {
            allow_archetype SECTION[at2002] occurrences ∈ {0..*} ∈ {
                include
                    archetype_id/value ∈ {/.*/}
                exclude
                    archetype_id/value ∈
                                {/openEHR-EHR-SECTION\.patient_details\..+/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, every constraint inside the block starting on an <code>allow_archetype</code> line contains constraints that must be met by archetypes in order to fill the slot. In the examples above, the constraints are in the form of regular expressions on archetype identifiers. In cADL, the PERL regular expression syntax is assumed.</p>
</div>
<div class="paragraph">
<p>There are two ways in which <em>archetype_id</em> regular expressions patterns can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>as a pattern against which to test a particular archetype identifier being proposed for that slot;</p>
</li>
<li>
<p>as a pattern to use against a population of archetypes (e.g. all archetypes in a particular repository) in order to generate a list of all possible archetypes for filling the slot.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Due to the second use, it is required that the regular expression pattern always cover a full archetype identifier rather than only sub-parts. As a consequence, a ‘meta-pattern’ can be defined to check <em>archetype_id</em> regular expressions for validity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    ^.+-.+-.+\..*\..+$</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because identifier matching is an inherently lexical operation, subtypes of mentioned types are not matched unless explicitly stated. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype ENTRY[id2] ∈ {    -- any kind of ENTRY
        include
            archetype_id/value ∈ {/openEHR-EHR-ENTRY..+\.v1/}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The intention is to allow any kind of <code>ENTRY</code> , but the above constraint won’t have the desired effect, because the pattern <code>openEHR-EHR-ENTRY</code> is unlikely to match any actual archetypes. Instead the following kind of constraint should be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype ENTRY[id2] ∈ {    -- any kind of ENTRY
        include
            archetype_id/value ∈ {
                /openEHR-EHR-EVALUATION\..+\.v1|openEHR-EHR-OBSERVATION\..+\.v1/
            }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above would allow any <code>EVALUATION</code> and any <code>OBSERVATION</code> archetypes to be used in the slot. Note that since no exclude clause was used, the above slot definition constitutes a recommendation. To make it a hard constraint, the following would be needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype ENTRY[id2] ∈ {    -- any kind of ENTRY
        include
            archetype_id/value ∈ {/openEHR-EHR-EVALUATION\..+\.v1|openEHR-EHR-OBSERVATION\..+\.v1/}
        exclude
            archetype_id/value ∈ {/.*/}
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_slots_based_on_other_constraints">Slots based on other Constraints</h5>
<div class="paragraph">
<p>Other constraints are possible as well, including that the allowed archetype must contain a certain keyword, or a certain path. The latter allows archetypes to be linked together on the basis of content. For example, under a "genetic relatives" heading in a Family History Organiser archetype, the following slot constraint might be used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    allow_archetype EVALUATION[id2] occurrences ∈ {0..*} matches {
        include
            archetype_id ∈ {openEHR-EHR-EVALUATION.family_history.v1}
                ∧ ∃ /subject/relationship/defining_code -&gt;
                ∼ ( [openehr::0] ∈ /subject/relationship/defining_code) -- self
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This says that the slot allows archetypes on the <code>EVALUATION</code> class, which either have as their concept ‘family_history’ or, if there is a constraint on the subject relationship, then it may not include the code <code>[openehr::0]</code> (the openEHR term for "self") - i.e. it must be an archetype designed for family members rather than the subject of care his/herself.</p>
</div>
</div>
<div class="sect4">
<h5 id="_slot_filling">Slot-filling</h5>
<div class="paragraph">
<p>Slots are ‘filled’ in specialised archetypes or templates by the use of use_archetype statements, i.e. the same construct as for an external reference described above. The typical form of a filled slot is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id1] ∈ {    -- Past history
        /items ∈ {
            use_archetype EVALUATION[id2, org.openehr::openEHR-EHR-EVALUATION.problem.v1]
            use_archetype EVALUATION[id2, org.openehr::openEHR-EHR-EVALUATION.clin_synopsis.v1]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In ADL, slot-filling is considered a kind of specialisation of a slot, which enables slots to be filled by the same mechanism as any other kind of specialisation found in a child archetype. Slot-filling and other forms of slot redefinition are described in more detail in the section <a href="#_slot_filling_and_redefinition">Slot Filling and Redefinition</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_mixed_structures">4.3.11. Mixed Structures</h4>
<div class="paragraph">
<p>Four types of structure representing constraints on complex objects have been presented so far:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">complex object structures</dt>
<dd>
<p>any node introduced by a type name and followed by {} containing constraints on attributes;</p>
</dd>
<dt class="hdlist1">internal references</dt>
<dd>
<p>any node introduced by the keyword <code>use_node</code> , followed by a type name; such nodes indicate re-use of a complex object constraint that has already been expressed elsewhere in the archetype;</p>
</dd>
<dt class="hdlist1">archetype slots</dt>
<dd>
<p>any node introduced by the keyword <code>allow_archetype</code> , followed by a type name; such nodes indicate a complex object constraint which is expressed in some other archetype;</p>
</dd>
<dt class="hdlist1">placeholder constraints</dt>
<dd>
<p>any node whose constraint is of the form <code>[acNNNN]</code> .</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>At any given node, any combination of these types can co-exist, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id2000] ∈ {
        items cardinality ∈ {0..*; ordered} ∈ {
            ENTRY[id2001] ∈ {-- etc --}
            allow_archetype ENTRY[id2002] ∈ {-- etc --}
            use_node ENTRY[id2003] /some_path[id4]
            ENTRY[id2004] ∈ {-- etc --}
            use_node ENTRY[id2005] /[id1002]/some_path[id1012]/
            use_node ENTRY[id2006] /[id1005]/some_path[id1052]/
            ENTRY[id2007] ∈ {-- etc --}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have a constraint on an attribute called <code><em>items</em></code> (of cardinality 0..*), expressed as a series of possible constraints on objects of type <code>ENTRY</code>. The 1st, 4th and 7th are described ‘in place’; the 3rd, 5th and 6th are expressed in terms of internal references to other nodes earlier in the archetype, while the 2nd is an archetype slot, whose constraints are expressed in other archetypes matching the include/exclude constraints appearing between the braces of this node. Note also that the <code>ordered</code> keyword has been used to indicate that the list order is intended to be significant.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_second_order_constraints">4.4. Second-order Constraints</h3>
<div class="sect3">
<h4 id="_tuple_constraints">4.4.1. Tuple Constraints</h4>
<div class="paragraph">
<p>In realistic data, it is not uncommon to need to constrain object properties in a covarying way. A simple example is the need to state range constraints on a temperature, represented as a <code>DV_QUANTITY</code> type, for both Centigrade and Fahrenheit scales. The default way to do this in ADL is (assuming a simple <code>DV_QUANTITY</code> class consisting of <code><em>property</em></code>, <code><em>units</em></code> and <code><em>magnitude</em></code> properties):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {
        DV_QUANTITY [id14] ∈ {
            property ∈ {[openehr::151|temperature|]}
            units ∈ {&quot;deg F&quot;}
            magnitude ∈ {|32.0..212.0|}
        }
        DV_QUANTITY [id15] ∈ {
            property ∈ {[openehr::151|temperature|]}
            units ∈ {&quot;deg C&quot;}
            magnitude ∈ {|0.0..100.0|}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>What we logically want to do is to state a single constraint on a ` DV_QUANTITY` that sets the magnitude range constraint dependent on the units constraint.</p>
</div>
<div class="paragraph">
<p>The covarying requirement could be met using rules of the form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value/units = &quot;deg F&quot; ® magnitude ∈ {|32.0..212.0|}
    .../value/units = &quot;deg C&quot; ® magnitude ∈ {|0.0..100.0|}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this seems obscure for what is logically a very simple kind of constraint.</p>
</div>
<div class="paragraph">
<p>A generic solution involves treating covarying properties formally as tuples, and providing syntax to express ‘constraints on tuples’. The following syntax achieves this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {
        DV_QUANTITY[id4] ∈ {
            property ∈ {[openehr::151]}                       -- temperature
            [units, magnitude] ∈ {
                [{&quot;deg F&quot;}, {|32.0..212.0|}] ,
                [{&quot;deg C&quot;}, {|0.0..100.0|}]
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>{}</code> surrounding each leaf level constraint are needed because although such constraints are typically atomic, as above, they may also take other standard ADL forms such as a list of strings, list of integers etc. In the latter case, the ',' characters from such lists will be conflated with the ',' separator of the distinct constraints in the tuple. Use of {} is also logically justified: each such entity is indeed a 'constraint' in the ADL sense, and all constraints are delimited by {}.</p>
</div>
<div class="paragraph">
<p>The above is actually short-hand for the following structure, with the added constraint that only corresponding units and magnitude leaf level constraints can occur together, while other combinations like <code>"deg F"</code> and <code>|0.0..100.0|</code> would be illegal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {
        DV_QUANTITY[id4] ∈ {
                property ∈ {[openehr::151]} -- temperature
                units ∈ {
                    String ∈ {&quot;deg F&quot;}
                    String ∈ {&quot;deg C&quot;}
                }
                magnitude ∈ {
                    Integer ∈ {|32.0..212.0|}
                    Integer ∈ {|0.0..100.0|}
                }
            }
        }</code></pre>
</div>
</div>
<div class="paragraph tbd">
<p><strong>TBD</strong>: need to check path semantics to leaf nodes in tuples.</p>
</div>
<div class="paragraph">
<p>The above defines constraints on units and magnitude together, as tuples like <code>[{"deg F"}, {|32.0..212.0|}]</code> .</p>
</div>
<div class="paragraph deprecated">
<p><strong>Deprecated</strong>: In the openEHR ADL 1.4 Archetype Profile, a custom constrainer type <code>C_DV_QUANTITY</code> was used to to provide the above constraint. However, this is specific to the Reference Model type, and does not solve similar constraints occurring in other types. This type and also the <code>C_DV_ORDINAL</code> type have been removed from ADL 1.5 altogether.</p>
</div>
<div class="paragraph">
<p>This same syntax will work for tuples of 3 or more co-varying properties, and is mathematically clean. It does involve some extra work for compiler implementers, but this only needs to be performed once to support any use of tuple constraints, regardless of Reference Model type.</p>
</div>
<div class="paragraph">
<p>If we look at the <code>DV_ORDINAL</code> data type constraint in the same light. First, doing a typical ordinal constraint (a scale of <code>+</code>, <code>`, `+</code>) with just standard ADL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ordinal_attr ∈ {
        DV_ORDINAL[id3] ∈ {
            value ∈ {0}
            symbol ∈ {
                DV_CODED_TEXT[id4] ∈ {
                    code ∈ {&quot;at1&quot;}              -- +
                }
            }
        }
        DV_ORDINAL[id5] ∈ {
            value ∈ {1}
            symbol ∈ {
                DV_CODED_TEXT[id6] ∈ {
                    code ∈ {&quot;at2&quot;}             -- ++
                        }
                    }
                }
            }
        }
        DV_ORDINAL[id7] ∈ {
            value ∈ {2}
            symbol ∈ {
                DV_CODED_TEXT[id8] ∈ {
                    code ∈ {&quot;at3&quot;}            -- +++
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This hides the <code>DV_ORDINAL</code> type altogether, but as for the <code>C_DV_QUANTITY</code> example above, it was a custom solution.</p>
</div>
<div class="paragraph">
<p>By the use of tuple constraint, almost the same thing can be chieved much more efficiently. We can now write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ordinal_attr ∈ {
        DV_ORDINAL[id3] ∈ {
            [value ,symbol] ∈ {
                [{0}, {[at1]}], -- +
                [{1}, {[at2]}], -- ++
                [{2}, {[at3]}] -- +++
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph deprecated">
<p>Deprecated: in the openEHR profiled version of ADL 1.4, a custom syntax was used, below, which is now replaced by the above generic form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    ordinal_attr ∈ {
        0|[local::at1],                   -- +
        1|[local::at2],                   -- ++
        2|[local::at3]                    -- +++
    }</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_group_constraints">4.4.2. Group Constraints</h4>
<div class="paragraph">
<p>Within a container attribute, any number of object constraints may be defined. The cardinality and occurrences constraints described above show how to control respectively, the overall container contents, and the occurrence of any particular object constraint within data. However, sometimes finer control is needed on repetition and grouping of members within the container. This can be achieved by the <code>group</code> construct, which provides an interior block where a sub-group of the overall container can be treated as a sub-group. The following example shows a typical used of the group construct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ITEM_TREE[id1] ∈ {
        items matches {
            ELEMENT[id2] occurrences ∈ {1} ∈ {...}              -- Investigation type
            ELEMENT[id3] occurrences ∈ {0..1} ∈ {...}           -- reason
            group cardinality ∈ {1} occurrences ∈ {0..1} ∈ {   -- Methodology
                ELEMENT[id6] occurrences ∈ {0..1} ∈ {...}       -- as Text
                ELEMENT[id7] occurrences ∈ {0..1} ∈ {...}       -- Coded
                CLUSTER[id8] occurrences ∈ {0..1} ∈ {...}       -- structured
            }
            ELEMENT[id11] occurrences ∈ {0..1} ∈ {...}          -- (other details)
            CLUSTER[id12] occurrences ∈ {0..1} ∈ {...}          -- (other details)
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the group is used to state a logical choice of methodology representations, each defined by one of the three constraints within the group. The group construct includes both cardinality and occurrences qualifier constraints. The former indicates the size and ordering of the group, in the same way as the cardinality constraint does for the overall contents of a container attribute. The latter defines the repeatability of the group. If the group occurrences upper limit is above 1, it means that the sub group may repeat, with each repetition respecting the order and size defined by the group cardinality.</p>
</div>
<div class="paragraph principle">
<p>A group constraint may be used to delimit a sub-list of objects within the total list of object constraints defined within a container attribute. A cardinality, defining size, ordering and uniqueness of the sub-list must be defined. An occurrences defining the repeatbility of the sub-list must also be defined. Group constraints can be nested.</p>
</div>
<div class="paragraph">
<p>The use of group cardinality and occurrences constraints, coupled with the occurrences constraints on each group member provide a means of specifying a number of logical constraint types found in other formalisms, including XML, as follows.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33%;">
<col style="width: 33%;">
<col style="width: 16%;">
<col style="width: 16%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Logical constraint</th>
<th class="tableblock halign-left valign-top">Group<br>
 cardinality</th>
<th class="tableblock halign-left valign-top">Group<br>
 occurrences</th>
<th class="tableblock halign-left valign-top">Item<br>
 occurrences</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 of N choice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper = 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 of N choice, repeating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1..1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N of M choice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper = 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">N of M choice, repeating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N..N</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0..1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence, repeating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1, ordered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sub-group, repeating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1, unordered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">upper &gt; 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">any</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Group blocks can be nested, enabling sub-lists of sub-lists to be defined, as illustrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    items ∈ {
        ELEMENT[id2] occurrences ∈ {1} ∈ {...}                -- Investigation type
        ELEMENT[id3] occurrences ∈ {0..1} ∈ {...}             -- Investigation reason
        group cardinality ∈ {2} occurrences ∈ {*} ∈ {         -- pick any 2 &amp; repeat
            ELEMENT[id6] occurrences matches {0..1} ∈ {...}
            ELEMENT[id7] occurrences matches {0..1} ∈ {...}
            CLUSTER[id8] occurrences matches {0..1} ∈ {...}
            group cardinality ∈ {1} occurrences ∈ {0..1} ∈ {  -- at least one
                ELEMENT[id9] occurrences ∈ {0..1} ∈ {...}
                CLUSTER[id10] occurrences ∈ {0..1} ∈ {...}
            }
        }
        ELEMENT[id11] occurrences ∈ {0..1} ∈ {...}            -- (other details)
        CLUSTER[id12] occurrences ∈ {0..1} ∈ {...}            -- (other details)
    }</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_slots_and_grouping">Slots and Grouping</h5>
<div class="paragraph">
<p>The group constraint is often useful with a slot definition, in order to control the ordering and occurrences of items defined by other archetypes, within an overall container. Consider the example of data of the general structure: 'any number of problem and diagnosis Entries, followed by one or more plan &amp; treatment Entries'. An example of data following this structure would be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>EVALUATION</code> : problem #1</p>
</li>
<li>
<p><code>EVALUATION</code> : diagnosis #1</p>
</li>
<li>
<p><code>EVALUATION</code> : problem #2</p>
</li>
<li>
<p><code>EVALUATION</code> : problem #3</p>
</li>
<li>
<p><code>EVALUATION</code> : plan</p>
</li>
<li>
<p><code>INSTRUCTION</code> : medication #1</p>
</li>
<li>
<p><code>INSTRUCTION</code> : therapy #1</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It might be expected that the slot constraints needed to define this are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id2] occurrences ∈ {0..1} ∈ {                           -- Subjective
        items cardinality ∈ {0..*; ordered} ∈ {
            allow_archetype EVALUATION[id6] occurrences ∈ {*} ∈ {   -- Problem
                include
                    archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.problem\.v*/}
            }
            allow_archetype EVALUATION[id7] occurrences ∈ {*} ∈ {   -- Diagnosis
                include
                    archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.problem-diagnosis\.v*/}
            }
            allow_archetype EVALUATION[id8] occurrences ∈ {1} ∈ {   -- Plan
                include
                    archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.plan\.v*/}
            }
            allow_archetype INSTRUCTION[id9] occurrences ∈ {*} ∈ {  -- Intervention
                include
                    archetype_id/value ∈ {/openEHR-EHR-INSTRUCTION\.plan\.v*/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above says that the <code>SECTION</code>.<code><em>items</em></code> attribute is an ordered list, and that its contents include multiple <code>EVALUATION</code> objects representing problem, diagnosis and plan, and also multiple <code>INSTRUCTION</code> objects representing interventions. The problem is now apparent. Each slot definition is set of possibilities, but we do not necessarily want to follow the slot ordering for the ordering of the archetypes chosen to fill the slots. To impose the required ordering and occurrences, we can use the group construct as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id2] occurrences ∈ {0..1} ∈ {                             -- Subjective
        items cardinality ∈ {0..*; ordered} ∈ {
            group cardinality ∈ {0..1} occurrences ∈ {0..*} ∈ {
                                    -- sub-group of any number of problems &amp; diagnoses
                allow_archetype EVALUATION[id6] occurrences ∈ {1} ∈ {  --Problem
                    include
                      archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.problem\.v*/}
                }
                allow_archetype EVALUATION[id7] occurrences ∈ {1} ∈ {  -- Diagnosis
                    include
                      archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.diagnosis\.v*/}
                }
            }
            allow_archetype EVALUATION[id8] occurrences ∈ {1} ∈ {      -- Plan
                include
                    archetype_id/value ∈ {/openEHR-EHR-EVALUATION\.plan\.v*/}
            }
            allow_archetype INSTRUCTION[id9] occurrences ∈ {*} ∈ {     -- Intervention
                include
                    archetype_id/value ∈ {/openEHR-EHR-INSTRUCTION\.plan\.v*/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above has the desired result in data: a group of any number of problems and diagnoses, followed by a plan, followed by one or more Interventions.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_constraints_on_primitive_types">4.5. Constraints on Primitive Types</h3>
<div class="paragraph">
<p>At the leaf nodes in a cADL text, constraints can be expressed on the following primitive types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Boolean;</p>
</li>
<li>
<p>Character, String;</p>
</li>
<li>
<p>Integer, Real;</p>
</li>
<li>
<p>Date, Time, Date_time, Duration;</p>
</li>
<li>
<p>Terminology_code;</p>
</li>
<li>
<p>lists and intervals of some of the above.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>While constraints on complex types follow the rules described so far, constraints on attributes of primitive types in cADL are expressed without type names, and omitting one level of braces, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    some_attr matches {some_pattern}</code></pre>
</div>
</div>
<div class="paragraph">
<p>rather than:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    some_attr matches {
        PRIMITIVE_TYPE[id3] matches {
            some_pattern
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is made possible because the syntax patterns of all primitive type constraints are mutually distinguishable, i.e. the type can always be inferred from the syntax alone. Since all leaf attributes of all object models are of primitive types, or lists or sets of them, cADL archetypes using the brief form for primitive types are significantly less verbose overall, as well as being more directly comprehensible to human readers. Currently the cADL grammar only supports the brief form used in this specification since no practical reason has been identified for supporting the more verbose version. Theoretically however, there is nothing to prevent it being used in the future, or in some specialist application.</p>
</div>
<div class="sect3">
<h4 id="_assumed_values">4.5.1. Assumed Values</h4>
<div class="paragraph">
<p>In an archetype containing optional data elements, an ability to define ‘assumed’ values is useful. For example, an archetype for ‘blood pressure measurement’ might include an optional data element describing the patient position, with choices ‘lying’, ‘sitting’ and ‘standing’. Since this element is optional, data could be created according to the archetype that does not contain it. However, a blood pressure cannot be taken without the patient in some position, so clearly there is an implied value.</p>
</div>
<div class="paragraph">
<p>The archetype allows this to be explicitly stated so that all users/systems know what value to assume when optional items are not included in the data. Assumed values are definable on any primitive type, and are expressed after the constraint expression, by a semi-colon (';') followed by a value of the same type as that implied by the preceding part of the constraint. Example constraints containing assumed values are shown in the sections below.</p>
</div>
<div class="paragraph">
<p>If no assumed value is stated, no reliable assumption can be made by the receiver of the archetyped data about what the values of removed optional parts might be, from inspecting the archetype. However, this usually corresponds to a situation where the assumed value does not even need to be stated - the same value will be assumed by all users of this data, if its value is not transmitted. In most cases, if an element specified as optional in the archetype, data users only care about the value if it is actually present. The ‘assumed value’ concept is therefore not likely to be needed in most cases.</p>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_string">4.5.2. Constraints on String</h4>
<div class="paragraph">
<p>Strings can be constrained in two ways: using a list of fixed strings, and using using a regular expression. All constraints on strings are case-sensitive.</p>
</div>
<div class="sect4">
<h5 id="_list_of_strings">List of Strings</h5>
<div class="paragraph">
<p>A String-valued attribute can be constrained by a list of strings (using the ODIN syntax for string lists), including the simple case of a single string. Examples are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    species ∈ {&quot;platypus&quot;}
    species ∈ {&quot;platypus&quot;, &quot;kangaroo&quot;}
    species ∈ {&quot;platypus&quot;, &quot;kangaroo&quot;, &quot;wombat&quot;}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first example constraints the runtime value of the <code><em>species</em></code> attribute of some object to take the value "platypus"; the second constrains it be either "platypus" or "kangaroo", and so on. In almost all cases, this kind of string constraint should be avoided, since it usually renders the body of the archetype language-dependent. Exceptions are proper names (e.g. "NHS", "Apgar"), product tradenames (but note even these are typically different in different language locales, even if the different names are not literally translations of each other). The preferred way of constraining string attributes in a language independent way is with value sets of terminology codes. See Section <a href="#_terminology_constraints">Terminology Constraints</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_regular_expression">Regular Expression</h5>
<div class="paragraph">
<p>The second way of constraining strings is with regular expressions, a widely used syntax for expressing patterns for matching strings. The regular expression syntax used in cADL is a proper subset of that used in the Perl language (see <a href="#Perl_regex">[Perl_regex]</a> for a full specification of the regular expression language of Perl). Two uses of it are accepted in cADL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    string_attr matches {/regular expression/}
    string_attr matches {!~ /regular expression/}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first indicates that the attribute value must match the supplied regular expression. The last indicates that the value must not match the expression. If the delimiter character is required in the pattern, it must be quoted with the backslash (‘\’) character, or else alternative delimiters can be used, enabling more comprehensible patterns. A typical example is regular expressions including units. The following two patterns are equivalent:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    units ∈ {/km\/h|mi\/h/}
    units ∈ {^km/h|mi/h^}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rules for including special characters within strings are described in <a href="file_encoding.htm#13178">See File Encoding and Character Quoting</a>.</p>
</div>
<div class="paragraph">
<p>The regular expression patterns supported in cADL are as follows.</p>
</div>
<div class="sect5">
<h6 id="_character_class">Character Class</h6>
<div class="ulist">
<ul>
<li>
<p><code>.</code> match any single character. E.g. <code>&#8230;&#8203;</code> matches any 3 characters;</p>
</li>
<li>
<p><code>[xyz]</code> match any of the characters in the set <code>xyz</code> (case sensitive). E.g. <code>[0-9]</code> matches any string containing a single decimal digit;</p>
</li>
<li>
<p><code>[a-m]</code> match any of the characters in the set of characters formed by the continuous range from <code>a</code> to ` m` (case sensitive). E.g. <code>[0-9]</code> matches any single character string containing a single decimal digit, <code>[S-Z]</code> matches any single character in the range <code>S</code> - <code>Z</code> ;</p>
</li>
<li>
<p><code>[^a-m]</code> match any character except those in the set of characters formed by the continuous range from ` a` to <code>m</code> . E.g. <code>[^0-9]</code> matches any single character string as long as it does not contain a single decimal digit;</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_grouping">Grouping</h6>
<div class="ulist">
<ul>
<li>
<p><code>(pattern)</code> parentheses are used to group items; any pattern appearing within parentheses is treated as an atomic item for the purposes of the occurrences operators. E.g. <code>([1-9][0-9])</code> matches any 2-digit number.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_occurrences_2">Occurrences</h6>
<div class="ulist">
<ul>
<li>
<p><code>*</code> match 0 or more of the preceding atomic item. E.g. <code>.*</code> matches any string; <code>[a-z][a-z0-9]*</code> matches any alphanumeric string starting with a letter;</p>
</li>
<li>
<p><code>+</code> match 1 or more occurrences of the preceding atomic item. E.g. <code>a[^\s]+</code> matches any string starting with ‘a’, followed by at least one further non-whitespace character;</p>
</li>
<li>
<p><code>?</code> match 0 or 1 occurrences of the preceding atomic item. E.g. <code>ab?</code> matches the strings <code>"a"</code> and <code>"ab"</code> ;</p>
</li>
<li>
<p><code>{m,n}</code> match m to n occurrences of the preceding atomic item. E.g. <code>ab{1,3}</code> matches the strings <code>"ab"</code> and <code>"abb"</code> and <code>"abbb"</code> ; <code>[a-z]{1,3}</code> matches all lower-case alphabetic strings of one to three characters in length;</p>
</li>
<li>
<p><code>{m,}</code> match at least m occurrences of the preceding atomic item;</p>
</li>
<li>
<p><code>{,n}</code> match at most n occurrences of the preceding atomic item;</p>
</li>
<li>
<p><code>{m}</code> match exactly m occurrences of the preceding atomic item;</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_special_character_classes">Special Character Classes</h6>
<div class="ulist">
<ul>
<li>
<p><code>\d</code> , <code>\D</code> match a decimal digit character; match a non-digit character;</p>
</li>
<li>
<p><code>\s</code> , <code>\S</code> match a whitespace character; match a non-whitespace character;</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_alternatives">Alternatives</h6>
<div class="ulist">
<ul>
<li>
<p><code>pattern1|pattern2</code> match either pattern1 or pattern2. E.g. <code>lying|sitting|standing</code> matches any of the words <code>"lying"</code> , <code>"sitting"</code> and <code>"standing"</code> .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A similar warning should be noted for the use of regular expressions to constrain strings: they should be limited to non-linguistically dependent patterns, such as proper and scientific names. The use of regular expressions for constraints on normal words will render an archetype linguistically dependent, and potentially unusable by others.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_integer">4.5.3. Constraints on Integer</h4>
<div class="paragraph">
<p>Integers can be constrained using a list of integer values, and using an integer interval.</p>
</div>
<div class="sect4">
<h5 id="_list_of_integers">List of Integers</h5>
<div class="paragraph">
<p>Lists of integers expressed in the syntax from ODIN can be used as a constraint, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    length matches {1000}       -- fixed value of 1000
    magnitude matches {0, 5, 8} -- any of 0, 5 or 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first constraint requires the attribute length to be 1000, while the second limits the value of magnitude to be 0, 5, or 8 only. A list may contain a single integer only:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    magnitude matches {0} -- matches 0</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_interval_of_integer">Interval of Integer</h5>
<div class="paragraph">
<p>Integer intervals are expressed using the interval syntax from ODIN (described in the ODIN specification). Examples of 2-sided intervals include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    length matches {|1000|}                       -- point interval of 1000 (=fixed value)
    length matches {|950..1050|}                  -- allow 950 - 1050
    length matches {|0..1000|}                    -- allow 0 - 1000
    length matches {|0..&lt;1000|}                   -- allow 0&gt;= x &lt;1000
    length matches {|0&gt;..&lt;1000|}                  -- allow 0&gt; x &lt;1000
    length matches {|100+/-5|}                    -- allow 100 +/- 5, i.e. 95 - 105</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examples of one-sided intervals include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    length matches {|&lt;10|}                        -- allow up to 9
    length matches {|&gt;10|}                        -- allow 11 or more
    length matches {|&lt;=10|}                       -- allow up to 10
    length matches {|&gt;=10|}                       -- allow 10 or more
    length matches {|&gt;=10|;5}                     -- allow 10 or more; assumed value = 5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_real">4.5.4. Constraints on Real</h4>
<div class="paragraph">
<p>Constraints on Real values follow exactly the same syntax as for Integers, in both list and interval forms. The only difference is that the real number values used in the constraints are indicated by the use of the decimal point and at least one succeeding digit, which may be 0. Typical examples are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    magnitude ∈ {5.5}                             -- list of one (fixed value)
    magnitude ∈ {|5.5|}                           -- point interval (=fixed value)
    magnitude ∈ {|5.5..6.0|}                      -- interval
    magnitude ∈ {5.5, 6.0, 6.5}                   -- list
    magnitude ∈ {|0.0..&lt;1000.0|}                  -- allow 0&gt;= x &lt;1000.0
    magnitude ∈ {|&lt;10.0|}                         -- allow anything less than 10.0
    magnitude ∈ {|&gt;10.0|}                         -- allow greater than 10.0
    magnitude ∈ {|&lt;=10.0|}                        -- allow up to 10.0
    magnitude ∈ {|&gt;=10.0|}                        -- allow 10.0 or more
    magnitude ∈ {|80.0+/-12.0|}                   -- allow 80 +/- 12</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_boolean">4.5.5. Constraints on Boolean</h4>
<div class="paragraph">
<p>Boolean runtime values can be constrained to be True, False, or either, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    some_flag matches {True}
    some_flag matches {False}
    some_flag matches {True, False}
    some_flag matches {True, False; False}         -- with assumed value</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_character">4.5.6. Constraints on Character</h4>
<div class="paragraph">
<p>Characters can be constrained in two ways: using a list of characters, and using a regular expression.</p>
</div>
<div class="sect4">
<h5 id="_list_of_characters">List of Characters</h5>
<div class="paragraph">
<p>The following examples show how a character value may be constrained using a list of fixed character values. Each character is enclosed in single quotes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    color_name matches {‘r’}
    color_name matches {‘r’, ‘g’, ‘b’}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_regular_expression_2">Regular Expression</h5>
<div class="paragraph">
<p>Character values can also be constrained using a single-character regular expression character class, also enclosed in single quotes, as per the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    color_name matches {‘[rgbcmyk]’}
    color_name matches {‘[^\s\t\n]’}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only allowed elements of the regular expression syntax in character expressions are the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>any item from the <a href="CDL.htm#88236">See Character Class</a> list above;</p>
</li>
<li>
<p>any item from the <a href="CDL.htm#75085">See Special Character Classes</a> list above;</p>
</li>
<li>
<p>an alternative expression whose parts are any item types, e.g. ` ‘a’|‘b’|[m-z]`</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_dates_times_and_durations">4.5.7. Constraints on Dates, Times and Durations</h4>
<div class="paragraph">
<p>Dates, times, date/times and durations may all be constrained in three ways: using a list of values, using intervals, and using patterns. The first two ways allow values to be constrained to actual date, time etc values, while the last allows values to be constrained on the basis of which parts of the date, time etc are present or missing, regardless of value. The pattern method is described first, since patterns can also be used in lists and intervals.</p>
</div>
<div class="sect4">
<h5 id="_date_time_and_date_time">Date, Time and Date/Time</h5>
<div class="sect5">
<h6 id="_patterns">Patterns</h6>
<div class="paragraph">
<p>Dates, times, and date/times (i.e. timestamps), can be constrained using patterns based on the ISO 8601 date/time syntax, which indicate which parts of the date or time must be supplied. A constraint pattern is formed from the abstract pattern <code>yyyy-mm-ddThh:mm:ss</code> (itself formed by translating each field of an ISO 8601 date/time into a letter representing its type), with either <code>?</code> (meaning optional) or <code>X</code> (not allowed) characters substituted in appropriate places. The syntax of legal patterns is shown by the following regular expressions:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">date_pattern</dt>
<dd>
<p><code>yyyy-(mm|??|XX)-(dd|??|XX)</code></p>
</dd>
<dt class="hdlist1">time_pattern</dt>
<dd>
<p><code>hh:(mm|??|XX):(ss|??|XX)</code></p>
</dd>
<dt class="hdlist1">time_in_date_pattern</dt>
<dd>
<p><code>T(hh|??|XX):(mm|??|XX):(ss|??|XX)</code></p>
</dd>
<dt class="hdlist1">date_time_pattern</dt>
<dd>
<p><code>date_constraint time_in_date_pattern</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>All expressions generated by these patterns must also satisfy the validity rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>where <code>??</code> appears in a field, only <code>??</code> or <code>XX</code> can appear in fields to the right</p>
</li>
<li>
<p>where <code>XX</code> appears in a field, only <code>XX</code> can appear in fields to the right</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following table shows the valid patterns that can be used, and the types implied by each pattern.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 16%;">
<col style="width: 33%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Implied Type</th>
<th class="tableblock halign-left valign-top">Pattern</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-dd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">full date must be specified</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-??</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional day;<br>
 e.g. day in month forgotten</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-??-??</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional month, optional day;<br>
 i.e. any date allowed; e.g. mental health questionnaires which include well known historical dates</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mandatory month, no day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-??-XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional month, no day</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hh:mm:ss</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">full time must be specified</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hh:mm:XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no seconds;<br>
 e.g. appointment time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hh:??:XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional minutes, no seconds;<br>
 e.g. normal clock times</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hh:??:??</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional minutes, seconds;<br>
 i.e. any time allowed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-ddThh:mm:ss</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">full date/time must be specified</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-ddThh:mm:??</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">optional seconds;<br>
 e.g. appointment date/time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-ddThh:mm:XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no seconds;<br>
 e.g. appointment date/time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-mm-ddThh:??:XX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no seconds, minutes optional;<br>
 e.g. in patient-recollected date/times</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yyyy-??-??T??:??:??</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">minimum valid date/time constraint</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>An assumed value can be used with any of the above as follows: <code>yyyy-??-??; 1970-01-01</code>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_intervals">Intervals</h6>
<div class="paragraph">
<p>Dates, times and date/times can also be constrained using intervals. Each date, time etc in an interval may be a literal date, time etc value, or a value based on a pattern. In the latter case, the limit values are specified using the patterns from the above table, but with numbers in the positions where <code>X</code> and <code>?</code> do not appear. For example, the pattern <code>yyyy-??-XX</code> could be transformed into <code>1995-??-XX</code> to mean any partial date in 1995. Examples of such constraints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    |1995-??-XX|                                   -- any partial date in 1995
    |09:30:00|                                     -- exactly 9:30 am
    |&lt; 09:30:00|                                   -- any time before 9:30 am
    |&lt;= 09:30:00|                                  -- any time at or before 9:30 am
    |&gt; 09:30:00|                                   -- any time after 9:30 am
    |&gt;= 09:30:00|                                  -- any time at or after 9:30 am
    |2004-05-20..2004-06-02|                       -- a date range
    |2004-05-20T00:00:00..2005-05-19T23:59:59|     -- a date/time range
    |&gt;= 09:30:00|;09:30:00                         -- any time at or after 9:30 am; assume 9:30 am</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_duration_constraints">Duration Constraints</h5>
<div class="sect5">
<h6 id="_patterns_2">Patterns</h6>
<div class="paragraph">
<p>Patterns based on ISO 8601 can be used to constraint durations in the same way as for Date/time types. The general form of a pattern is (EBNF; all tokens are literals):</p>
</div>
<div class="literalblock">
<div class="content">
<pre>P[Y|y][M|m][W|w][D|d][T[H|h][M|m][S|s]]</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Note that allowing the ‘W’ designator to be used with the other designators corresponds to a deviation from the published ISO 8601 standard used in openEHR, namely:</p>
</li>
<li>
<p>durations are supposed to take the form of PnnW or PnnYnnMnnDTnnHnnMnnS, but in openEHR, the W (week) designator can be used with the other designators, since it is very common to state durations of pregnancy as some combination of weeks and days.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The use of this pattern indicates which "slots" in an ISO duration string may be filled. Where multiple letters are supplied in a given pattern, the meaning is 'or', i.e. any one or more of the slots may be supplied in the data. This syntax allows specifications like the following to be made:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    Pd            -- a duration containing days only, e.g. P5d
    Pm            -- a duration containing months only, e.g. P5m
    PTm           -- a duration containing minutes only, e.g. PT5m
    Pwd           -- a duration containing weeks and/or days only, e.g. P4w
    PThm          -- a duration containing hours and/or minutes only, e.g. PT2h30m</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_list_and_intervals">List and Intervals</h6>
<div class="paragraph">
<p>Durations can also be constrained by using absolute ISO 8601 duration values, or ranges of the same, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    PT1m              -- 1 minute
    P1dT8h            -- 1 day 8 hrs
    |PT0m..PT1m30s|   -- Reasonable time offset of first apgar sample</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_mixed_pattern_and_interval">Mixed Pattern and Interval</h6>
<div class="paragraph">
<p>In some cases there is a need to be able to limit the allowed units as well as state a duration interval. This is common in obstetrics, where physicians want to be able to set an interval from say 0-50 weeks and limit the units to only weeks and days. This can be done as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    PWD/|P0W..P50W|   -- 0-50 weeks, expressed only using weeks and days</pre>
</div>
</div>
<div class="paragraph">
<p>The general form is a pattern followed by a slash (‘/’) followed by an interval, as follows:</p>
</div>
<div class="paragraph">
<p>duration_pattern ‘/’ duration_interval</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terminology_constraints">4.5.8. Terminology Constraints</h4>
<div class="sect4">
<h5 id="_overview_3">Overview</h5>
<div class="paragraph">
<p>Terminology constraints deal with a special category of data values typically known as ‘coded terms’ or ‘terminology’. Coded data values are both textual (e.g. "diastolic blood pressure") and semantic (may have relationships to each other). The idea is that instead of using text, the possible values are represented in structured vocabularies, terminologies or ontologies that define both the possible text (including translations) and also the relationships, if any, between the terms (sometimes known as ‘concepts’). In health, typical examples include ‘terminology’ resources such as WHO ICDx (<a href="#WHO_ICD">[WHO_ICD]</a> and SNOMED (<a href="#IHTSDO">[IHTSDO]</a>) terminologies and drug databases.</p>
</div>
<div class="paragraph">
<p>Coded terms are treated as a primitive type in ADL in order to enable the formalism and tools to work with terminology constraints<a href="#pgfId-1169358">3</a>. Unlike other primitive constraints, terminology constraints may be complex, because they refer to external resources, either directly or via ‘bindings’ defined elsewhere in the archeype. This section describes the syntactical representations and relationships between these. The full semantics, including binding and resolution are described in the section <a href="#_terminology_integration">Terminology Integration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_requirement">Requirement</h5>
<div class="paragraph">
<p>There are two general categories of terminology constraint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>‘inline’ terminology value or value set;</p>
</li>
<li>
<p>external terminology value set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the first, it is the constraint locally in the archetype that establishes the term or set of possible terms to be used for a given purpose, e.g. ‘position of patient when measuring blood pressure’. This is true even if each term in the value set is mapped individually to a term in an external terminology.</p>
</div>
<div class="paragraph">
<p>In the second, the value set is defined and maintained by an external party, and the archetype references it via a reliable URI.</p>
</div>
<div class="paragraph">
<p>The general form of a terminology constraint in cADL is shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ENTRY[id1] ∈ {                         -- blood pressure measurement
        name ∈ {                           -- any synonym of BP
            DV_CODED_TEXT[id2] ∈ {
                defining_code ∈ {[ac1]}    -- terminology constraint
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the constraint on ` DV_CODED_TEXT` . <em>defining_code</em> is defined as a terminology constraint containing an ‘ac’ code ` [acN]` , which acts as an internal identifier of a value set. The various types of terminology constraint are described below.</p>
</div>
</div>
<div class="sect4">
<h5 id="_design_basis">Design Basis</h5>
<div class="paragraph">
<p>A fully qualified coded term primitive data item is assumed by ADL to consist of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a terminology identifier</p>
</li>
<li>
<p>optionally, a terminology version identifier</p>
</li>
<li>
<p>a code or ‘code string’ (an expression made from codes, permitted in some terminologies).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The special terminology identifier "local" is understood as meaning ‘this archetype’. The qualified form of the term ‘at4’ from within the same archetype is "local::at4". An archetype term referenced from an external context where the archetype identifier is not otherwise known uses the archetype identifier as the terminology identifier. Thus the term ` at4` can be referenced externally as: <code>org.openehr::openEHR-EHR-OBSERVATION.bp_measurement.v1::at4</code></p>
</div>
<div class="paragraph">
<p>Terminology constraints in an archetype can be in three <code>forms</code>: <code>source</code>, <code>expanded</code>, <code>substituted</code> and <code>resolved</code>.</p>
</div>
<div class="paragraph">
<p>Currently an archetype may contain terminology constraints in more than one form.</p>
</div>
</div>
<div class="sect4">
<h5 id="_source_form">Source Form</h5>
<div class="paragraph">
<p>A ‘source form’ terminology constraint is the form used to define value sets in source archetypes, i.e. it is the authored form of constraint, prior to any further tool processing. The lexical form is a single ac-code, optionally with an at-code denoting an assumed value, i.e.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>[acN]</code></p>
</li>
<li>
<p><code>[acN; atN]</code>&#8201;&#8212;&#8201;with assumed value</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The ac-code is defined in the archetype terminology. Associated with the ac-code must be a local value set, and/or a binding to an external value set. If both a local value set and a binding exist, tooling and configuration parameters are used to decide how to generate the resolved form (below).</p>
</div>
<div class="paragraph">
<p>This type of constraint is used when there is a proproper value set, i.e. a set of coded values with more than one member. For the degenerate case of a constraint consisting of a single term, the first expanded form below is used, i.e. there is no ac-coded source form.</p>
</div>
</div>
<div class="sect4">
<h5 id="_expanded_form">Expanded Form</h5>
<div class="paragraph">
<p>The expanded form of a terminology constraint is a form in which archetype-local terms or sets of terms forming the constraint are inlined in the constraint definition. In this form, all source form ac-coded constraints are replaced by the archetype-local value set they define. This can be thought of as converting a source form value set constraint to an ‘inline’ value set constraint. Single-value constraints are also represented this way, and in fact don’t have a source form (since it would serve no useful purpose to define an ac-code and value set containing a single at-code).</p>
</div>
<div class="paragraph">
<p>The syntax for the expanded form is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    [local::atN]                           -- single term
    [local::atN, atN, ... , atN]           -- value set
    [local::atN, atN, ... , atN; atN]      -- with assumed value</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first variant is the single value case. This type is used when the constraint is intended to fix single coded value only, e.g. the code for a physical property like ‘mass’ in a constraint that defines possible mass values.</p>
</div>
<div class="paragraph">
<p>The second variant represents an expanded value set, and the third is the same with an assumed value. For purely practical purposes, a multi-line form with interpolated comments is often used (e.g. by ADL serialisers, documentation), to make the constraint more comprehensible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    defining_code matches {
        [local::
            at31,     -- Naked
            at32,     -- Reduced clothing/bedding
            at33,     -- Appropriate clothing/bedding
            at34]     -- Increased clothing/bedding
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>or with assumed value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    defining_code matches {
        [local::
            at31,     -- Naked
            at32,     -- Reduced clothing/bedding
            at33,     -- Appropriate clothing/bedding
            at34;     -- Increased clothing/bedding
            at33]     -- assumed value
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>An archetype whose terminology constraints are all in expanded form will contain only at-codes in those constraints.</p>
</div>
</div>
<div class="sect4">
<h5 id="_substituted_form">Substituted Form</h5>
<div class="paragraph">
<p>The next form is ‘substituted’ form, which is used to represent terminology constraints in the final concrete form intended at point of use. The substituted form is create by replacing each terminology constraint in its expanded form with the appropriate one of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the single external term bound to an internal at-code, e.g. an ISO term for the property ‘mass’;</p>
</li>
<li>
<p>the set of terms from the intended external resource (e.g. a terminology like SNOMED CT or LOINC) - typically for small value sets;</p>
</li>
<li>
<p>an external reference to which the value set ac-code is bound in the archetype terminology - typically for large and changing value sets. This includes the logical constraint ‘any term in terminology X’.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The concrete form for all substituted form terms is one or more URIs. The URI syntax is normally an http reference to a real resource. The lexical form for the single code case is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    [http://terminology_publisher_domain/terminology_specifier/code_string]
    [http://terminology_publisher_domain/terminology_specifier/teminology_version_specifier/code_string]</pre>
</div>
</div>
<div class="paragraph">
<p>For the inline value set case, it will be a comma-separated list of these within [], optionally with a final URI representing an assumed value, i.e.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    [uri, uri, ... , uri]
    [uri, uri, ... , uri]; uri</pre>
</div>
</div>
<div class="paragraph">
<p>In the external value set reference case, a single URI will be used that denotes the external value set, rather than individual terminology codes, i.e.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    [uri]</pre>
</div>
</div>
<div class="paragraph">
<p>The exact form of the URIs will value across industries, and will eventually be standardised by appropriate standards organisations or industry groups. In the health domain, this is done by the <a href="#IHTSDO">[IHTSDO]</a> organisation.</p>
</div>
</div>
<div class="sect4">
<h5 id="_resolved_form">Resolved Form</h5>
<div class="paragraph">
<p>A final ‘resolved’ form of a terminology constraint specified by a binding reference to an externally defined value set, can be generated by attempting to resolve the reference against the target terminology and returning the actual terms in the value set according to the terminology. This form would be used in flattened archetypes, operational templates and documentation for local use.</p>
</div>
<div class="paragraph">
<p>Since an archetype might not contain external terminology bindings for all (or even any) of its terminological constraints, a ‘resolved’ archetype might still contain at-codes in its cADL definition. These at-codes would be treated as real coded terms in any implementation that was creating data, and as a consequence, archetype at-codes could occur in real data.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_lists_of_primitive_types">4.5.9. Constraints on Lists of Primitive types</h4>
<div class="paragraph">
<p>In many cases, the type in the information model of an attribute to be constrained is a list or set of primitive types, e.g. <code>List&lt;Integer&gt;</code>, <code>Set&lt;String&gt;</code> etc. As for complex types, this is indicated in cADL using the <code>cardinality</code> keyword, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    some_attr cardinality ∈ {0..*} ∈ {some_constraint}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pattern to match in the final braces will then have the meaning of a list or set of value constraints, rather than a single value constraint. Any constraint described above for single-valued attributes, which is commensurate with the type of the attribute in question, may be used. However, as with complex objects, the meaning is now that every item in the list is constrained to be any one of the values implied by the constraint expression. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    speed_limits cardinality ∈ {0..*; ordered} ∈ {50, 60, 70, 80, 100, 130}</code></pre>
</div>
</div>
<div class="paragraph">
<p>constrains each value in the list corresponding to the value of the attribute <code>speed_limits</code> (of type <code>List&lt;Integer&gt;</code> ), to be any one of the values 50, 60, 70 etc.</p>
</div>
</div>
<div class="sect3">
<h4 id="_constraints_on_enumerated_types">4.5.10. Constraints on Enumerated Types</h4>
<div class="paragraph">
<p>Enumeration types in the reference model are assumed to have the semantics defined in UML and mainstream programming languages, i.e. to be a distinct type based on a primitive type, normally Integer or String. Each such type consists of a set of values from the domain of its underlying type, thus, a set of Integer, String or other primitive values. Each of these values is assumed to be named in the manner of a symbolic constant. Although stricly speaking UML doesn’t require an enumerated type to be based on an underlying primitive type, programming languages do, hence the assumption here that values from the domain of such a type are involved.</p>
</div>
<div class="paragraph">
<p>In ADL, constraints on enumerated types are represented by constraints on the underlying primitive values. The following example shows 2 constraints on an attribute of the type <code>PROPORTION_KIND</code> from the openEHR Reference Model.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ITEM_TREE[id4] ∈ {
        items ∈ {
            ELEMENT[id5] occurrences ∈ {0..1} matches {    -- test enum 1
                value ∈ {
                    DV_PROPORTION[id6] ∈ {
                        numerator ∈ {|0.0..1.0|; 0.0}
                        type ∈ {1}                         -- pk_unitary
                    }
                }
            }
            ELEMENT[id7] ∈ {                               -- test enum 2
                value ∈ {
                    DV_PROPORTION[id8] ∈ {
                        numerator ∈ {|0.0..1.0|; 0.0}
                        type ∈ {2, 3}                      -- pk_percent, pk_fraction
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PROPORTION_KIND</code> is defined as <code>{pk_ratio = 0; pk_unitary = 1; pk_percent = 2; pk_fraction = 3; pk_integer_fraction = 4}</code> in its reference model. Modelling tools are relied on to visualise enumeration constraints in a suitable way, by inferring the type based on inspection of the reference model on which the archetype is based.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_syntax_validity_rules">4.6. Syntax Validity Rules</h3>
<div class="paragraph">
<p>Various coded syntax rules have been defined for the cADL syntax, for use by parser and compiler authors. These can be found on at the GitHub location <a href="https://github.com/openEHR/adl-resources/blob/master/messages/ADL/adl_syntax_errors.txt" class="bare">https://github.com/openEHR/adl-resources/blob/master/messages/ADL/adl_syntax_errors.txt</a>.</p>
</div>
<div class="paragraph">
<p>The state of this file at the issue of this document is as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    ["SUNK"] = &lt;"Syntax error (unknown cause)"&gt;
    ["SARID"] = &lt;"Syntax error in artefact identification clause; expecting archetype id (format = model_issuer-package-class.concept.version)"&gt;
     
    ["SASID"] = &lt;"Syntax error in 'specialise' clause; expecting parent archetype id (model_issuer-ref_model-model_class.concept.version)"&gt;
     
    ["SACO"] = &lt;"Syntax error in 'concept' clause; expecting TERM_CODE reference"&gt;
    ["SALA"] = &lt;"Syntax error in language section"&gt;
    ["SALAN"] = &lt;"Syntax error no language section found"&gt;
    ["SADS"] = &lt;"Syntax error in description section"&gt;
    ["SADF"] = &lt;"Syntax error in definition section"&gt;
    ["SAIV"] = &lt;"Syntax error in invariant section"&gt;
    ["SAON"] = &lt;"Syntax error in terminology section"&gt;
    ["SAAN"] = &lt;"Syntax error in annotations section"&gt;
     
    ["SDSF"] = &lt;"Syntax error: differential syntax not allowed in top-level archetype"&gt;
    ["SDINV"] = &lt;"Syntax error: invalid ODIN section; error: $1"&gt;
    ["SCCOG"] = &lt;"Syntax error: expecting a new node definition, primitive node definition, 'use' path, or 'archetype' reference"&gt;
    ["SUAID"] = &lt;"Syntax error: expecting [archetype_id] in use_archetype statement"&gt;
    ["SUAIDI"] = &lt;"Syntax error: invalid archetype id $1"&gt;
    ["SOCCF"] = &lt;"Syntax error: expecting an 'occurrences expression', e.g. 'occurrences matches {n..m}'"&gt;
    ["SUNPA"] = &lt;"Syntax error: expecting absolute path in use_node statement"&gt;
    ["SCOAT"] = &lt;"Syntax error: expecting attribute definition(s)"&gt;
    ["SUAS"] = &lt;"Syntax error: error after 'use_archetype' keyword; expecting Object node definition"&gt;
    ["SCAS"] = &lt;"Syntax error: expecting a 'any' node, 'leaf' node, or new node definition"&gt;
    ["SINVS"] = &lt;"Syntax error: illegal invariant expression at identifier $1"&gt;
    ["SEXPT"] = &lt;"Syntax error: expecting absolute path after exists keyword"&gt;
    ["SEXLSG"] = &lt;"Syntax error: existence single value must be 0 or 1"&gt;
    ["SEXLU1"] = &lt;"Syntax error: existence upper limit must be 0 or 1 when lower limit is 0"&gt;
    ["SEXLU2"] = &lt;"Syntax error: existence upper limit must be 1 when lower limit is 1"&gt;
    ["SEXLMG"] = &lt;"Syntax error: existence must be one of 0..0, 0..1, or 1..1"&gt;
     
    ["SCIAV"] = &lt;"Syntax error: invalid assumed value; must be an integer"&gt;
    ["SCRAV"] = &lt;"Syntax error: invalid assumed value; must be a real number"&gt;
    ["SCDAV"] = &lt;"Syntax error: invalid assumed value; must be an ISO8601 date"&gt;
    ["SCTAV"] = &lt;"Syntax error: invalid assumed value; must be an ISO8601 time"&gt;
    ["SCDTAV"] = &lt;"Syntax error: invalid assumed value; must be an ISO8601 date/time"&gt;
    ["SCDUAV"] = &lt;"Syntax error: invalid assumed value; must be an ISO8601 duration"&gt;
    ["SCSAV"] = &lt;"Syntax error: invalid assumed value; must be a string"&gt;
    ["SCBAV"] = &lt;"Syntax error: invalid assumed value; must be a 'True' or 'False'"&gt;
    ["SCOAV"] = &lt;"Syntax error: invalid assumed value; must be an ordinal integer value"&gt;
     
    ["SCDPT"] = &lt;"Syntax error: invalid date constraint pattern '$1'; allowed patterns: $2"&gt;
    ["SCTPT"] = &lt;"Syntax error: invalid time constraint pattern '$1'; allowed patterns: $2"&gt;
    ["SCDTPT"] = &lt;"Syntax error: invalid date/time constraint pattern '$1'; allowed patterns: $2"&gt;
    ["SCDUPT"] = &lt;"Syntax error: invalid duration constraint pattern '$1'; legal pattern: P[Y|y][M|m][W|w][D|d][T[H|h][M|m][S|s]] or P[W|w] [/duration_interval]"&gt;
     
    ["SCSRE"] = &lt;"Syntax error: regular expression compile error '$1' is not a valid regular expression"&gt;
    ["STCCP"] = &lt;"Syntax error: invalid term code constraint pattern '$1': $2"&gt;
    ["STCDC"] = &lt;"Syntax error: duplicate code(s) found in code list"&gt;
    ["STCAC"] = &lt;"Syntax error: assumed value code $1 not found in code list"&gt;
    ["STCNT"] = &lt;"Syntax error: terminology not specified"&gt;</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_assertions">5. Assertions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_4">5.1. Overview</h3>
<div class="paragraph">
<p>This section describes the assertion sub-language of archetypes. Assertions are used in archetype "slot" clauses in the cADL ` definition` section, and in the ` rules` section. The following simple assertion in the ` rules` section of an archetype says that the speed in kilometres of some node is related to the speed-in-miles by a factor of 1.6:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="expr">    validity: /speed[id2]/kilometres[id14]/magnitude = /speed[id4]/miles[id14]/magnitude * 1.6</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_requirements">5.1.1. Requirements</h4>
<div class="paragraph">
<p>Assertions are needed in archetypes to express rules in two locations in an archetype. In an archetype slot, assertions can be stated to control what archetypes are allowed in the slot, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    CLUSTER[id3] occurrences matches {0..1} matches {   -- Detail
        items cardinality matches {0..*; unordered} matches {
            allow_archetype CLUSTER[id9] occurrences matches {0..1} matches {
                include
                    archetype_id/value matches {/openEHR-EHR-CLUSTER.exam-.+\.v1/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the statement following the <code>include</code> keyword expresses a condition on the value found at the path <code>archetype_id/value</code> , using the familiar ADL <code>matches</code> operator, and a regular expression on archetype identifiers. Most slot statements are of this kind, with some requiring slightly more complex expressions. See <a href="#_archetype_slots">Archetype Slots</a> for more details.</p>
</div>
<div class="paragraph">
<p>The main requirement for assertions in archetypes is for expressing rules that cannot be expressed uding the standard cADL syntax. Types of rules include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>constraints involving more than one node in an archetype, such as a rule stating that the sum of the five 0-2 value scores in an Apgar test (heartrate, breathing, muscle tone, reflex, colour) correspond to the Apgar total, recorded in a sixth node;</p>
</li>
<li>
<p>rules involving predefined variables such as ‘current_date’;</p>
</li>
<li>
<p>rules involving query results from a data or knowledge context, allowing values such as ‘patient date of birth’ to be referenced.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The semantic requirements are for expressions including arithmetic, boolean, and relational operators, some functions, quantifier operators, a notion of operator precedence, parentheses, constant values, and certain kinds of variables. However, there is no requirement for procedural semantics, type declarations or many of the other complexities of full-blown programming languages.</p>
</div>
</div>
<div class="sect3">
<h4 id="_design_basis_2">5.1.2. Design Basis</h4>
<div class="paragraph">
<p>The archetype assertion language is a small language of its own. Formally it is a reduced first-order predicate logic language with various operators. It has similarities with OMG’s OCL (Object Constraint Language) syntax, and is also similar to the assertion syntax which has been used in the Object-Z <a href="#Object_Z">[Object_Z]</a> and Eiffel <a href="#Eiffel">[Eiffel]</a> languages and tools for over a decade (see <a href="#Sowa">[Sowa]</a>, <a href="#Hein">[Hein]</a>, <a href="#Kilov_Ross">[Kilov_Ross]</a> for an explanation of predicate logic in information modelling). None of these languages has been used directly, for reasons including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>OCL has a complex type system, and includes some undecidable procedural semantics;</p>
</li>
<li>
<p>none have adequate variable referencing mechanisms, such as to paths and external queries;</p>
</li>
<li>
<p>they are too powerful, and would introduce unnecessary complexity into archetypes and templates.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are also similarities with other languages developed in the health arena for expressing ‘medical logic’ (Arden), guidelines (GLIF and many others) and decision support (GELLO and many others). These languages were not directly used either, for reasons including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>none have a path referencing mechanism;</p>
</li>
<li>
<p>some are too procedural (Arden, GLIF);</p>
</li>
<li>
<p>current versions of some of these languages have been made specific to the HL7v3 RIM, a particular model of health information designed for message representation (GLIF 3.x, GELLO);</p>
</li>
<li>
<p>all in their published form are too powerful for the needs identified here.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The design approach used here was to create a small concrete syntax allowing for a core subset of first-order predicate logic, which could easily be parsed into a typical parse-tree form, defined in the openEHR Archetype Object Model. Many different variations on syntax elements are possible (as evidenced by the many formal logic syntaxes used in mathematics and computing theory); the elements used here were chosen for ease of expression using normal kebyoard characters and intuitiveness.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keywords_2">5.2. Keywords</h3>
<div class="paragraph">
<p>The syntax of the invariant section is a subset of first-order predicate logic. In it, the following keywords can be used:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>exists</code> , <code>for_all</code> ,</p>
</li>
<li>
<p><code>and</code> , <code>or</code> , <code>xor</code> , <code>not</code> , <code>implies</code></p>
</li>
<li>
<p><code>true</code> , <code>false</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Symbol equivalents for some of the above are given in the following table.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Textual<br>
 Rendering</th>
<th class="tableblock halign-left valign-top">Symbolic<br>
 Rendering</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches, is_in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∈</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Set membership, "p is in P"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">exists</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∃</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Existential quantifier, "there exists &#8230;&#8203;"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">for_all</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∀</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Universal quantifier, "for all x&#8230;&#8203;"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">implies</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Material implication, "p implies q", or "if p then q"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">and</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∧</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logical conjunction, "p and q"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">or</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logical disjunction, "p or q"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">xor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∨</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exclusive or, "only one of p or q"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">not, ~</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">∼, ¬</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Negation, "not p"</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_typing">5.3. Typing</h3>
<div class="paragraph">
<p>The assertion language is fully typed. All operators, variables and constants have either assumed or declared type signatures.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operators">5.4. Operators</h3>
<div class="paragraph">
<p>Assertion expressions can include arithmetic, relational and boolean operators, plus the existential and universal quantifiers.</p>
</div>
<div class="sect3">
<h4 id="_arithmetic_operators">5.4.1. Arithmetic Operators</h4>
<div class="paragraph">
<p>The supported arithmetic operators are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>addition: <code>+</code></p>
</li>
<li>
<p>subtraction: <code>-</code></p>
</li>
<li>
<p>multiplication: <code>*</code></p>
</li>
<li>
<p>division: <code>/</code></p>
</li>
<li>
<p>exponent: <code>^</code></p>
</li>
<li>
<p>modulo division: <code>%</code>&#8201;&#8212;&#8201;remainder after integer division</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_equality_operators">5.4.2. Equality Operators</h4>
<div class="paragraph">
<p>The supported equality operators are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>equality: <code>=</code></p>
</li>
<li>
<p>inequality: <code>!=</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The semantics of these operators are of value comparison.</p>
</div>
</div>
<div class="sect3">
<h4 id="_relational_operators">5.4.3. Relational Operators</h4>
<div class="paragraph">
<p>The supported relational operators are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>less than: <code>&lt;</code></p>
</li>
<li>
<p>less than or equal: <code>&#8656;</code></p>
</li>
<li>
<p>greater than: <code>&gt;</code></p>
</li>
<li>
<p>greater than or equal: <code>&gt;=</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The semantics of these operators are of value comparison on entities of Comparable types (see openEHR Support IM, Assumed Types section). All generate a Boolean result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_boolean_operators">5.4.4. Boolean Operators</h4>
<div class="paragraph">
<p>The supported boolean operators are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>not: <code>not</code></p>
</li>
<li>
<p>and: <code>and</code></p>
</li>
<li>
<p>xor: <code>xor</code></p>
</li>
<li>
<p>implies: <code>implies</code></p>
</li>
<li>
<p>set membership: <code>matches</code>, <code>is_in</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The boolean operators also have symbolic equivalents shown earlier. All boolean operators take Boolean operands and generate a Boolean result. The <code>not</code> operator can be applied as a prefix operator to all operators returning a boolean result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_quantifiers">5.4.5. Quantifiers</h4>
<div class="paragraph">
<p>The two standard logical quantifier operators are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>existential quantifier: <code>exists</code></p>
</li>
<li>
<p>universal quantifier: <code>for_all</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These operators also have the usual symbolic equivalents shown earlier. The <code>exists</code> operator can be used on an variable, including paths referring to a node or value within an archetype. The <code>for_all</code> operator can be applied to sets and lists, such as referred to by a path to a multiply-valued attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="_functions">5.4.6. Functions</h4>
<div class="paragraph">
<p>The following functions are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>sum (x, y, &#8230;&#8203;.)</code>: equivalent to <code>x + y + &#8230;&#8203;.</code></p>
</li>
<li>
<p><code>mean (x, y, &#8230;&#8203;)</code>: the mean (average) value of x, y, &#8230;&#8203;</p>
</li>
<li>
<p><code>max (x, y, &#8230;&#8203;)</code>: the maximum value among x, y, &#8230;&#8203;</p>
</li>
<li>
<p><code>min (x, y, &#8230;&#8203;)</code>: the minimum value among x, y, &#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of the above functions have the signature <code>func(Real, &#8230;&#8203;):Real</code> , but will also perform as though having the signature <code>func(Integer, &#8230;&#8203;):Integer</code> , due to automatic numeric type promotion/demotion rules.</p>
</div>
<div class="paragraph">
<p>Other functions may be added in the future.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operands">5.5. Operands</h3>
<div class="paragraph">
<p>Operands in an assertion expression are typed and are of four kinds, as described in the following sub-sections.</p>
</div>
<div class="sect3">
<h4 id="_constants">5.5.1. Constants</h4>
<div class="paragraph">
<p>Constant values are of any primitive type defined in the openEHR Support IM Assumed Types, and expressed according in the ODIN syntax (see the ODIN specification), i.e.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Character</code>, e.g. <code>‘x’</code> ;</p>
</li>
<li>
<p><code>String</code>, e.g. <code>"this is a string"</code> ;</p>
</li>
<li>
<p><code>Boolean</code>, e.g. <code>True</code> , ` False` ;</p>
</li>
<li>
<p><code>Integer</code>, e.g. <code>5</code> ;</p>
</li>
<li>
<p><code>Real</code>, e.g. <code>5.2</code> ;</p>
</li>
<li>
<p><code>ISO8601_DATE</code>, e.g. <code>2004-08-12</code> ;</p>
</li>
<li>
<p><code>ISO8601_TIME</code>, e.g. <code>12:00:59</code> ;</p>
</li>
<li>
<p><code>ISO8601_DATE_TIME</code>, e.g. <code>2004-08-12T12:00:59</code> ;</p>
</li>
<li>
<p><code>ISO8601_DURATION</code>, e.g. <code>P39W</code> ;</p>
</li>
<li>
<p><code>URI</code>, e.g. <code><a href="http://en.wikipedia.org/wiki/Everest" class="bare">http://en.wikipedia.org/wiki/Everest</a></code> ;</p>
</li>
<li>
<p>coded term, e.g. [snomed_ct::2004950];</p>
</li>
<li>
<p>Intervals of any numeric type, according to ODIN syntax e.g. <code>|70..130|</code> ;</p>
</li>
<li>
<p>List of any primitive type, e.g. <code>"string1", "string2", "string3"</code> .</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_object_references">5.5.2. Object References</h4>
<div class="paragraph">
<p>A reference to an object in data, including a leaf value, is expressed using an archetype path. All such paths are absolute (i.e. contain a leading ‘/’) and are understood to be with respect to the root of the current archetype. References to archetype nodes have the type defined at the relevant point in the underlying reference model. Examples include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    /data[id2]/items[id3]/value[id35]/value -- Date of initial onset; type ISO8601_DATE</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_built_in_variables">5.5.3. Built-in Variables</h4>
<div class="paragraph">
<p>A small number of built-in variables are available for use in assertions, and are referred to using a ‘$’ symbol, for example ` $current_date` . Built-in variables defined include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $current_date: ISO8601_DATE
    $current_time: ISO8601_TIME
    $current_date_time: ISO8601_DATE_TIME
    $current_year: Integer
    $current_month: Integer</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_archetype_defined_variables">5.5.4. Archetype-defined Variables</h4>
<div class="paragraph">
<p>Variables may be declared within the rules section of an archetype. This is done using the following syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $var_name:Type ::= expression</pre>
</div>
</div>
<div class="paragraph">
<p>This facility can be used to equate a variable name to a path, e.g. the following equates the variable ` $diagnosis` to the code at the path contianing the diagnosis (e.g. in the <code>openEHR-EHR-EVALUATION.problem-diagnosis.v1</code> archetype):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $diagnosis:CODE_PHRASE ::= /data/items[id2.1]/value/defining_code</pre>
</div>
</div>
<div class="paragraph">
<p>The variable can then be used instead of the path in subsequent expressions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_external_queries">5.5.5. External Queries</h4>
<div class="paragraph">
<p>An expression referring to an externally defined query, possibly including arguments, may be defined using the variable declaration syntax. The general pattern is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $varname:Type ::= query(context, query_name, arg1, arg2, ...)</pre>
</div>
</div>
<div class="paragraph">
<p>Examples include:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $date_of_birth:ISO8601_DATE ::= query("ehr", "date_of_birth")
    $has_diabetes:Boolean ::= query("ehr", "has_diagnosis", "snomed_ct::1234567")
    $is_female:Boolean ::= query("ehr", "is_female")</pre>
</div>
</div>
<div class="paragraph">
<p>Any number of arguments can be included.</p>
</div>
<div class="sect4">
<h5 id="_query_contexts">Query Contexts</h5>
<div class="literalblock">
<div class="content">
<pre> </pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_query_names">Query Names</h5>
<div class="literalblock">
<div class="content">
<pre> </pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_precedence_and_parentheses">5.6. Precedence and Parentheses</h3>

</div>
<div class="sect2">
<h3 id="_conditions">5.7. Conditions</h3>
<div class="paragraph">
<p>Example&#8230;&#8203;.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    $is_female implies exists /path/to/xxx</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_natural_language_issues">5.8. Natural Language Issues</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_adl_paths">6. ADL Paths</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_5">6.1. Overview</h3>
<div class="paragraph">
<p>The notion of paths is integral to ADL, and a common path syntax is used to reference nodes in both ODIN and cADL sections of an archetype. The same path syntax works for both, because both ODIN and cADL have an alternating object/attribute structure. However, the interpretation of path expressions in ODIN and cADL differs slightly; the differences are explained in the ODIN and cADL sections of this document. This section describes only the common syntax and semantics.</p>
</div>
<div class="paragraph">
<p>The general form of the path syntax is as follows (see syntax section below for full specification):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code>    path:: ['/'] path_segment { '/' path_segment }+
    path_segment:: attr_name [ '[' object_id ']' ]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Essentially, ADL paths consist of segments separated by slashes (<code>'/'</code>), where each segment is an attribute name with optional object identifier predicate, indicated by brackets ('[]').</p>
</div>
<div class="paragraph principle">
<p>ADL Paths are formed from an alternation of segments made up of an attribute name and optional object node identifier predicate, separated by slash (<code>'/'</code>) characters. Node identifiers are delimited by brackets (i.e. <code>[]</code>).</p>
</div>
<div class="paragraph">
<p>Similarly to paths used in file systems, ADL paths are either absolute or relative, with the former being indicated by a leading slash.</p>
</div>
<div class="paragraph principle">
<p>Paths are absolute or relative with respect to the document in which they are mentioned. Absolute paths commence with an initial slash (‘/’) character.</p>
</div>
<div class="paragraph">
<p>The ADL path syntax also supports the concept of “movable” path patterns, i.e. paths that can be used to find a section anywhere in a hierarchy that matches the path pattern. Path patterns are indicated with a leading double slash ('//') as in Xpath.</p>
</div>
<div class="paragraph principle">
<p>Path patterns are absolute or relative with respect to the document in which they are mentioned. Absolute paths commence with an initial slash (‘/’) character.</p>
</div>
<div class="sect3">
<h4 id="_relationship_with_w3c_xpath">6.1.1. Relationship with W3C Xpath</h4>
<div class="paragraph">
<p>The ADL path syntax is semantically a subset of the Xpath query language, with a few syntactic shortcuts to reduce the verbosity of the most common cases. Xpath differentiates between “children” and “attributes” sub-items of an object due to the difference in XML between Elements (true sub-objects) and Attributes (tag-embedded primitive values). In ADL, as with any pure object formalism, there is no such distinction, and all subparts of any object are referenced in the manner of Xpath children; in particular, in the Xpath abbreviated syntax, the key <code>child::</code> does not need to be used.</p>
</div>
<div class="paragraph">
<p>ADL does not distinguish attributes from children, and also assumes the node_id attribute. Thus, the following expressions are legal for cADL structures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    items[1]                            -- the first member of ‘items’
    items[systolic]                     -- the member of ‘items’ with meaning ‘systolic’
    items[id1]                          -- the member of ‘items’ with node id ‘id1’</pre>
</div>
</div>
<div class="paragraph">
<p>The Xpath equivalents are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    items[1]                           -- the first member of ‘items’
    items[meaning() = ‘systolic’]      -- the member of ‘items’ for which the meaning()
                                       -- function evaluates to “systolic”
    items[@archetype_node_id = ‘id1’]  -- the member of ‘items’ with key ‘id1’</pre>
</div>
</div>
<div class="paragraph">
<p>In the above, <code>meaning()</code> is a notional function is defined for Xpath in openEHR, which returns the rubric for the node_id of the current node. Such paths are only for display purposes, and paths used for computing always use the ‘at’ codes, e.g. items[id1], for which the Xpath equivalent is <code>items[@node_id = ‘id1’]</code>.</p>
</div>
<div class="paragraph">
<p>The ADL movable path pattern is a direct analogue of the Xpath syntax abbreviation for the ‘descendant’ axis.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_default_values">7. Default Values</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_6">7.1. Overview</h3>
<div class="paragraph">
<p>In ADL 2, it is possible to specify a default value for any object node. This almost always limited to use in templates, since default values are usually specific to local contexts or use cases. However they may validly be used in any archetype.</p>
</div>
<div class="paragraph">
<p>Within a template, a default value can be defined to support the situation where only one value is possible for a data item due to the specific nature of the template. For example, a blood pressure archetype may allow a number of possible values for ‘patient position’, such as ‘lying’, and ‘sitting’, ‘standing’. When used in a hospital, the patient will usually be lying so a default value for this can be set, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/events[id6]/state[id7]/items[id8]/value ∈ {
        DV_CODED_TEXT ∈ {
            _default ∈ {
                (DV_CODED_TEXT) &lt;
                    defining_code = &lt;[snomedct::163033001]&gt; -- lying BP
                &gt;
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default values are expressed in ODIN syntax, since they are instances of objects, rather than being constraints. They are introduced using a pseudo-attribute ‘default’, which is detected by the compiler as being a meta-attribute. The example above only sets the default value, but it could have also modified the constraint on the value object as well, as in the following version (where the standing blood pressure possibility from the archetype has been removed):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/events[id6]/state[id7]/items[id8]/value ∈ {
        DV_CODED_TEXT ∈ {
            defining_code ∈ {
                [snomedct::163035008] -- sitting blood pressure
            }
            _default ∈ {
                (DV_CODED_TEXT) &lt;
                    defining_code = &lt;[snomed::163033001]&gt; -- lying BP
                &gt;
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Default values can be set in the same way on container objects, such that one or more container objects distinguished by node identifier or name (if renaming has been used in the template) within the same container can have a default value assigned to them.</p>
</div>
<div class="paragraph tbd">
<p>TBD: example</p>
</div>
<div class="paragraph">
<p>A default value is either of the same type as specified by the corresponding archetype node (<code><em>rm_type_name</em></code> AOM attribute) or any subtype allowed by the reference model.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_adl_archetype_definition_language">8. ADL - Archetype Definition Language</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_2">8.1. Introduction</h3>
<div class="paragraph">
<p>This section describes whole ADL artefacts. The relationship of the cADL-encoded <code>definition</code> section and the ODIN-encoded <code>terminology</code> section is discussed in detail. In this section, only standard ADL (i.e. the standard cADL constructs and types described so far) is assumed.</p>
</div>
<div class="paragraph">
<p>Some syntax valdity rules are defined, but validity in general is defined by the rules stated in the AOM specification, which can be checked by a compiler as soon as an AOM structure is parsed from an ADL document (or other serialsiation format).</p>
</div>
<div class="paragraph">
<p>The general structure of ADL artefacts is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(([flat] archetype | template | template_overlay) |
            operational_template) (qualifiers)
    human-readable id
[specialize
    parent_id]
language
    &lt;ODIN&gt;
description
    &lt;ODIN&gt;
definition
    &lt;cADL&gt;
[rules
    &lt;Expr syntax&gt;]
terminology
    &lt;ODIN&gt;
[annotations
    &lt;ODIN&gt;]
[revision_history
    &lt;ODIN&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>An ADL source template has the structure (<code>template</code> keyword; must be specialised):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[flat] template (qualifiers)
    human-readable id
specialize
    parent_id
language
    &lt;ODIN&gt;
description
    &lt;ODIN&gt;
definition
    &lt;cADL&gt;
[rules
    &lt;Expr syntax&gt;]
terminology
    &lt;ODIN&gt;
[annotations
    &lt;ODIN&gt;]
[revision_history
    &lt;ODIN&gt; section]</pre>
</div>
</div>
<div class="paragraph">
<p>An ADL template overlay has the structure shown below (<code>template_overlay</code> keyword, must be specialised; minimal sections):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>template_overlay (qualifiers)
    id
specialize
    parent_id
definition
    &lt;cADL&gt;
terminology
    &lt;ODIN&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>The structure of an operational template expressed in native ADL is as follows (<code>operational_template</code> keyword; full flattened structure, including <code>component_terminologies</code> section):</p>
</div>
<div class="listingblock">
<div class="content">
<pre>operational_template (qualifiers)
    template_id
language
    &lt;ODIN&gt;
description
    &lt;ODIN&gt;
definition
    &lt;cADL&gt;
[rules
    &lt;Expr syntax&gt;]
terminology
    &lt;ODIN&gt;
[annotations
    &lt;ODIN&gt;]
component_terminologies
    &lt;ODIN&gt;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_file_naming_convention">8.2. File-naming Convention</h3>
<div class="paragraph">
<p>Up until ADL 1.4, archetypes were expressed in ‘flat’ form ADL and were saved in files with the extension <code>.adl</code>. These are now treated as legacy flat format files. Beginning with ADL 1.5, the source file format of an archetype is the ‘differential’ form, with the extension <code>.adls</code>. The flat format being generated by tools, and now has the extension <code>.adlf</code>.</p>
</div>
<div class="paragraph">
<p>For specialised archetypes, differential form follows the object-oriented convention and only includes overridden or new elements but not unchanged inherited elements. Inherited elements are determined by compiling and ‘flattening’ a differential archetype with respect to the parent archetypes in its <em>inheritance lineage</em> .</p>
</div>
<div class="paragraph">
<p>For top-level archetypes the full structure is included in the differential file, but internal references, where they exist, are expanded out in the flat form.</p>
</div>
</div>
<div class="sect2">
<h3 id="_basics_2">8.3. Basics</h3>
<div class="sect3">
<h4 id="_keywords_3">8.3.1. Keywords</h4>
<div class="paragraph">
<p>ADL has a small number of keywords which are reserved for use in archetype declarations, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>archetype</code>, <code>template</code>, <code>template_overlay</code>, <code>operational_template</code>,</p>
</li>
<li>
<p><code>specialise</code> / <code>specialize</code>,</p>
</li>
<li>
<p><code>concept</code> ,</p>
</li>
<li>
<p><code>language</code> ,</p>
</li>
<li>
<p><code>description</code> , <code>definition</code> , <code>rules</code> , <code>terminology</code></p>
</li>
<li>
<p><code>annotations</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these words can safely appear as identifiers in the <code>definition</code> and <code>terminology</code> sections.</p>
</div>
<div class="paragraph">
<p>Deprecated keywords include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>invariant</code>&#8201;&#8212;&#8201;replaced by <code>rules</code></p>
</li>
<li>
<p><code>ontology</code> &#8201;&#8212;&#8201;replaced by <code>terminology</code></p>
</li>
<li>
<p><code>concept</code>  &#8201;&#8212;&#8201;obsolete</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_artefact_declaration">8.3.2. Artefact declaration</h4>
<div class="paragraph">
<p>The first word in a source ADL archetype declares the artefact type, and is one of the following keywords:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>archetype</code>:        signifies an archetype;</p>
</li>
<li>
<p><code>template</code>:         signifies a template;</p>
</li>
<li>
<p><code>template_overlay</code>: signifies an overlay component of a template.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The flattened form of any of the above types starts with the keyword ‘flat’ followed by the artefact type.</p>
</div>
<div class="paragraph">
<p>A fourth artefact type is also possible.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>operational_archetype</code>: signifies an operational archetype, generated by flattening a template.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_node_identifier_codes">8.3.3. Node Identifier Codes</h4>
<div class="paragraph">
<p>In the <code>definition</code> section of an ADL archetype, a specific set of codes is used as node identifiers. Identifier codes always appear in brackets (<code>[]</code> ), and begin with the ‘id’ prefix. Specialisations of locally coded concepts have the same root, followed by ‘dot’ extensions, e.g. <code>[id10.2]</code> . From a terminology point of view, these codes have no implied semantics - the ‘dot’ structuring is used as an optimisation on node identification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_local_term_codes">8.3.4. Local Term Codes</h4>
<div class="paragraph">
<p>In the <code>definition</code> section of an ADL archetype, a second set of codes is used for terms denoting constraints on coded items. Term codes are either local to the archetype, or from an external lexicon. This means that the archetype description is the same in all languages, and is available in any language that the codes have been translated to. All term codes are shown in brackets (<code>[]</code>) and are prefixed with "at", e.g. <code>at10</code> . Codes of any length are acceptable in ADL archetypes. Specialisations of locally coded concepts have the same root, followed by ‘dot’ extensions, e.g. <code>at10.2</code> . From a terminology point of view, these codes have no implied semantics - the ‘dot’ structuring is used as an optimisation on node identification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_local_constraint_codes">8.3.5. Local Constraint Codes</h4>
<div class="paragraph">
<p>A third kind of local code is used to stand for constraints on code text items in the body of the archetype. Although these could be included in the main archetype body, because they are language- and/or terminology-sensitive, they are defined in the terminology section, and referenced by codes prefixed by "ac", e.g. <code>[ac9]</code>.</p>
</div>
<div class="paragraph deprecated">
<p><strong>Deprecated</strong>: In ADL 1.4 and transitional forms of ADL 1.5, 0-padded ‘ac’ codes were used within top-level archetypes. In ADL 2, all such codes are reformatted to remove the 0-padding.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_archetype_identification_section">8.4. Archetype Identification Section</h3>
<div class="paragraph">
<p>This section introduces the archetype with the keyword <code>archetype</code>, <code>template</code>, <code>template_overlay</code> or <code>operational_archetype</code>, followed by a number of items of meta-data in parentheses, and on the next line, a human-readable archetype identifier. The following shows an identification section with all possible meta-data items.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5; provenance_id=15E82D77-7DB7-4F70-8D8E-EED6FF241B2D; build_id=E163E472-3E90-409C-9803-0668A7DA48CE; generated; controlled)
    openEHR-EHR-OBSERVATION.haematology_result.v0.1.9</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_adl_version_indicator">8.4.1. ADL Version Indicator</h4>
<div class="paragraph">
<p>An ADL version identifier is mandatory in all archetypes, and is expressed as a string of the form <code>adl_version=N.M</code> , or <code>N.M.P</code> , where <code>N.M[.P]</code> is the ADL release identifier.</p>
</div>
</div>
<div class="sect3">
<h4 id="_machine_identifiers">8.4.2. Machine Identifiers</h4>
<div class="paragraph">
<p>A unique identifier for the archetype in the form of a GUID can be specified using the syntax below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">    archetype (adl_version=2.0.5; uid=15E82D77-7DB7-4F70-8D8E-EED6FF241B2D)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identifier is set at initial creation or at any time later, and nevre subsequently changes. It acts as an identifier for the physical artefact, regardless of what semantics are changed, including changes to the constituent parts of the multi-axial identifier.</p>
</div>
</div>
<div class="sect3">
<h4 id="_namespaces">8.4.3. Namespaces</h4>
<div class="paragraph">
<p>A namespaced archetype will have an identification section like the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5)
    br.gov.saude::openEHR-EHR-OBSERVATION.haematology_result.v1.0.0

template (adl_version=2.0.5)
    uk.org.primary_care::openEHR-EHR-OBSERVATION.haematology_result.v1.2.15

archetype (adl_version=2.0.5)
    org.openehr::openEHR-EHR-OBSERVATION.haematology_result.v3.22.125-rc.7</code></pre>
</div>
</div>
<div class="paragraph">
<p>Namespaces are used to distinguish locally created artefacts representing a given concept (such as ‘haematology result’) from an artefact created elsewhere intended to represent the same concept.</p>
</div>
<div class="paragraph">
<p>Once a namespace is attached to an archetype, it is considered a part of the identifier, and never changed, even if the archetype moves to a new publishing organisation. This ensures the constant relationship between archetypes and the data created using them.</p>
</div>
</div>
<div class="sect3">
<h4 id="_human_readable_archetype_identifier">8.4.4. Human Readable Archetype Identifier</h4>
<div class="paragraph">
<p>The archetype identifier may include a namespace, in the form of a reverse domain name, which denotes the original authoring organisation. The lack of a namespace in the identifier indicates an ad hoc, uncontrolled artefact, not formally associated with any organisation, typical for experimental archetypes, and pre-ADL 1.5 archetypes not yet upgraded to have a namespace. The main part of the identifier is multi-axial concept identifier.</p>
</div>
<div class="paragraph">
<p>A typical identification sectionfor an ad hoc archetype is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5)
    openEHR-EHR-OBSERVATION.haematology_result.v0.1.9</code></pre>
</div>
</div>
<div class="paragraph deprecated">
<p><strong>Deprecated</strong>: In ADL 1.4 and transitional forms of ADL 1.5, archetype identifiers included only a single version number, and this typically started at 1. Tools that deal with older archetypes should accept these identifiers, and convert the version part to ‘v1.0.0’ or any other appropriate identifier, obeying the openEHR Artefact Knowledge Identification specification.</p>
</div>
<div class="paragraph">
<p>The multi-axial archetype identifier identifies archetypes in a global concept space within a given namespace. It is also known as an ‘ontological’ identifier, since the concept space can be understood as an ontology of informational concepts on which the archetypes are based. The syntax of the identifier is described in the Identification section of the openEHR Support IM specification. The structure of the concept space is essentially two-level, with the first level being a reference model class (e.g. openEHR <code>OBSERVATION</code> class) and the second being a domain concept (e.g. ‘haematology result’).</p>
</div>
<div class="paragraph">
<p>Because namespaces are usually treated hierarchically, higher level namespaces (e.g. ‘.org’ domains) are assumed to be includable by more local namespaces, with the result that the concept definition space is inherited as well.</p>
</div>
<div class="paragraph">
<p>The semantics of the ontological identifier are described in detail in <a href="#knowledge_artefact_identification">[knowledge_artefact_identification]</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specialised_archetype_identification">8.4.5. Specialised Archetype Identification</h4>
<div class="paragraph">
<p>The archetype identifier of any specialised archetype, including all templates, follows the same rules as for non-specialised archetypes.</p>
</div>
<div class="paragraph deprecated">
<p><strong>Deprecated</strong>: in previous versions of ADL, the archetype identifier of a specialised archetype had a concept part that consisted of the concept part of the parent followed by ‘-’ and a further specialised concept. For example, <code>openEHR-EHR-OBSERVATION.haematology-cbc. v1</code> was a valid child of <code>openEHR-EHR-OBSERVATION.haematology.v1</code>. This restriction is no longer the case. The previous style of identifier is still legal, but the ‘-’ no longer has any significance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_version_identifiers">8.4.6. Version Identifiers</h4>
<div class="paragraph">
<p>ADL 2 Archetypes contain 3-part version identifiers, with optional qualifiers, following the openEHR Artefact Knowledge Identification specification. Examples below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    br.ms::openEHR-EHR-OBSERVATION.haematology_result.v1.0.0
    br.ms::openEHR-EHR-OBSERVATION.haematology_result.v1.2.15-alpha.45
    br.ms::openEHR-EHR-OBSERVATION.haematology_result.v3.22.125-rc.7</pre>
</div>
</div>
<div class="paragraph">
<p>The version identifier variants are summarised as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>N.M.P</code>         - 3-part version id with no qualifier indicates major.minor.path version</p>
</li>
<li>
<p><code>N.M.P-alpha.N</code> - a <code>-alpha.N</code> qualifier indicates uncontrolled changes on <code>N.M.P</code> , leading to a new version that is yet to be decided</p>
</li>
<li>
<p><code>N.M.P-rc.N</code>    - a <code>-rc.N</code> qualifier indicates a release candidate.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_validity">8.4.7. Validity</h4>
<div class="paragraph">
<p>The following syntax validity rule applies in the identification section:</p>
</div>
<div class="paragraph rule">
<p>SARID: archetype identifier validity. the identifier of the artefact must conform to the ARCHETYPE_ID identifier syntax defined in the openEHR.Support IM Specification.</p>
</div>
</div>
<div class="sect3">
<h4 id="_generated_indicator">8.4.8. Generated Indicator</h4>
<div class="paragraph">
<p>A flag indicating whether the archetype was generated or authored can be included after the version, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5; generated)
    org.openehr::openEHR-EHR-OBSERVATION.haematology.v1.2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>This marker is used to support the migration to differential archetype representation introduced in ADL 1.5, to enable proper representation of specialised archetypes. The ‘generated’ marker can be used on specialised archetypes - i.e. ADL 1.5 style .adls files - generated from flat archetypes - ADL 1.4 .adl files - and also in flat archetypes generated from differential files, by an inheritance-flattening process.</p>
</div>
</div>
<div class="sect3">
<h4 id="_controlled_indicator">8.4.9. Controlled Indicator</h4>
<div class="paragraph">
<p>A flag indicating whether the archetype is change-controlled or not can be included after the version, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5; controlled)
    org.openehr::openEHR-EHR-OBSERVATION.haematology.v1.2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>This flag may have the two values "controlled" and "uncontrolled" only, and is an aid to software. Archetypes that include the "controlled" flag should have the revision history section included, while those with the "uncontrolled" flag, or no flag at all, may omit the revision history. This enables archetypes to be privately edited in an early development phase without generating large revision histories of little or no value.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specialise_section">8.5. Specialise Section</h3>
<div class="paragraph">
<p>This optional section indicates that the archetype is a specialisation of some other archetype, whose identity must be given. Only one specialisation parent is allowed, i.e. an archetype cannot ‘multiply-inherit’ from other archetypes. An example of declaring specialisation is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">archetype (adl_version=2.0.5)
    openEHR-EHR-OBSERVATION.cbc.v1
specialise
    openEHR-EHR-OBSERVATION.haematology.v1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the identifier of the new archetype is derived from that of the parent by adding a new section to its domain concept section. See the <code>ARCHETYPE_ID</code> definition in the identification package in the openEHR Support IM specification.</p>
</div>
<div class="paragraph">
<p>Note that both the US and British English versions of the word "specialise" are valid in ADL.</p>
</div>
<div class="paragraph">
<p>The following syntax validity rule applies in the specialisation section:</p>
</div>
<div class="paragraph rule">
<p>SASID: archetype specialisation parent identifier validity. for specialised artefacts, the identifier of the specialisation parent must conform to the ARCHETYPE_ID identifier syntax defined in the openEHR Support IM Specification.</p>
</div>
</div>
<div class="sect2">
<h3 id="_language_section">8.6. Language Section</h3>
<div class="paragraph">
<p>The <code>language</code> section includes meta-data describing the original language in which the archetype was authored (essential for evaluating natural language quality), and the total list of languages available in the archetype. There can be only one <code>original_language</code> . The <code>translations</code> list must be updated every time a translation of the archetype is undertaken. The following shows a typical example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">language
    original_language = &lt;[iso_639-1::en]&gt;
    translations = &lt;
        [&quot;de&quot;] = &lt;
            language = &lt;[iso_639-1::de]&gt;
            author = &lt;
                [&quot;name&quot;] = &lt;&quot;Frederik Tyler&quot;&gt;
                [&quot;email&quot;] = &lt;&quot;freddy@something.somewhere.co.uk&quot;&gt;
            &gt;
            accreditation = &lt;&quot;British Medical Translator id 00400595&quot;&gt;
        &gt;
        [&quot;ru&quot;] = &lt;
            language = &lt;[iso_639-1::ru]&gt;
            author = &lt;
                [&quot;name&quot;] = &lt;&quot;Nina Alexandrovna&quot;&gt;
                [&quot;organisation&quot;] = &lt;&quot;Dostoevsky Media Services&quot;&gt;
                [&quot;email&quot;] = &lt;&quot;nina@translation.dms.ru&quot;&gt;
            &gt;
            accreditation = &lt;&quot;Russian Translator id 892230-3A&quot;&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Archetypes must always be translated completely, or not at all, to be valid. This means that when a new translation is made, every language dependent section of the <code>description</code> and <code>terminology</code> sections has to be translated into the new language, and an appropriate addition made to the ` translations` list in the language section.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
some non-conforming ADL tools in the past created archetypes without a language section, relying on the terminology section to provide the original_language (there called primary_language) and list of languages (languages_available). In the interests of backward compatibility, tool builders should consider accepting archetypes of the old form and upgrading them when parsing to the correct form, which should then be used for serialising/saving.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_description_section">8.7. Description Section</h3>
<div class="paragraph">
<p>The <code>description</code> section of an archetype contains descriptive information, or what some people think of as document "meta-data", i.e. items that can be used in repository indexes and for searching. The ODIN syntax is used for the description, as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">description
    original_author = &lt;
        [&quot;name&quot;] = &lt;&quot;Dr J Joyce&quot;&gt;
        [&quot;organisation&quot;] = &lt;&quot;NT Health Service&quot;&gt;
        [&quot;date&quot;] = &lt;2003-08-03&gt;
    &gt;
    lifecycle_state =  &lt;&quot;initial&quot;&gt;
    resource_package_uri =  &lt;&quot;http://www.aihw.org.au/data_sets/diabetic_archetypes.html&quot;&gt;

    details = &lt;
        [&quot;en&quot;] = &lt;
            language = &lt;[iso_639-1::en]&gt;
            purpose =  &lt;&quot;archetype for diabetic patient review&quot;&gt;
            use = &lt;&quot;used for all hospital or clinic-based diabetic reviews,
                including first time. Optional sections are removed according to the particular review&quot;
            &gt;
            misuse = &lt;&quot;not appropriate for pre-diagnosis use&quot;&gt;
            original_resource_uri = &lt;&quot;http://www.healthdata.org.au/data_sets/diabetic_review_data_set_1.html&quot;&gt;
            other_details = &lt;...&gt;
        &gt;
        [&quot;de&quot;] = &lt;
            language = &lt;[iso_639-1::de]&gt;
            purpose =  &lt;&quot;Archetyp für die Untersuchung von Patienten mit Diabetes&quot;&gt;
            use = &lt;&quot;wird benutzt für alle Diabetes-Untersuchungen im
                    Krankenhaus, inklusive der ersten Vorstellung. Optionale
                    Abschnitte werden in Abhängigkeit von der speziellen
                    Vorstellung entfernt.&quot;
            &gt;
            misuse = &lt;&quot;nicht geeignet für Benutzung vor Diagnosestellung&quot;&gt;
            original_resource_uri = &lt;&quot;http://www.healthdata.org.au/data_sets/diabetic_review_data_set_1.html&quot;&gt;
            other_details = &lt;...&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A number of details are worth noting here. Firstly, the free hierarchical structuring capability of ODIN is exploited for expressing the ‘deep’ structure of the <code>details</code> section and its subsections. Secondly, the ODIN qualified list form is used to allow multiple translations of the <code>purpose</code> and <code>use</code> to be shown. Lastly, empty items such as <code>misuse</code> (structured if there is data) are shown with just one level of empty brackets. The above example shows meta-data based on the openEHR Archetype Object Model (AOM).</p>
</div>
<div class="paragraph">
<p>The <code>description</code> section is technically optional according to the AOM, but in any realistic use of ADL for archetypes, it will be required. A minimal description section satisfying to the AOM is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">description
    original_author = &lt;
        [&quot;name&quot;] = &lt;&quot;Dr J Joyce&quot;&gt;
        [&quot;organisation&quot;] = &lt;&quot;NT Health Service&quot;&gt;
        [&quot;date&quot;] = &lt;2003-08-03&gt;
    &gt;
    lifecycle_state = &lt;&quot;initial&quot;&gt;
    details = &lt;
        [&quot;en&quot;] = &lt;
            language = &lt;[iso_639-1::en]&gt;
            purpose = &lt;&quot;archetype for diabetic patient review&quot;&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deprecated_sections">8.8. Deprecated Sections</h3>
<div class="sect3">
<h4 id="_concept_section">8.8.1. Concept Section</h4>
<div class="paragraph">
<p>A ‘concept’ section was required up until ADL 1.4. In ADL 1.5, the concept section is deprecated, but allowed, enabling ADL 1.4 archetypes to be treated as valid. It will be removed in a future version of ADL, since it is completely redundant.</p>
</div>
<div class="paragraph">
<p>All archetypes represent some real world concept, such as a "patient", a "blood pressure", or an "ante-natal examination". The concept is always coded, ensuring that it can be displayed in any language the archetype has been translated to. A typical <code>concept</code> section is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>concept [at0000] -- haematology result</pre>
</div>
</div>
<div class="paragraph">
<p>In this concept definition, the term definition of <code>[at0000]</code> is the proper description corresponding to the "haematology-cbc" section of the archetype identifier above.</p>
</div>
<div class="paragraph">
<p>The following syntax validity rule applies to the concept section, if present, allowing parsers to correctly ignore it:</p>
</div>
<div class="paragraph rule">
<p>SACO: archetype concept validity: if a concept section is present, it must consist of the ‘concept’ keyword and a single local term.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definition_section">8.9. Definition Section</h3>
<div class="paragraph">
<p>The <code>definition</code> section contains the main formal definition of the archetype, and is written in the Constraint Definition Language (cADL). A typical <code>definition</code> section is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">definition
    OBSERVATION[id1] ∈ {                                                 -- blood pressure measurement
        name ∈ {                                                         -- any synonym of BP
            DV_CODED_TEXT[id2] ∈ {
                defining_code ∈ {
                    CODE_PHRASE[id3] ∈ {[ac1]}
                }
            }
        }
        data ∈ {
            HISTORY[id4] ∈ {                                              -- history
                events cardinality ∈ {1..*} ∈ {
                    POINT_EVENT[id5] occurrences ∈ {0..1} ∈ {            -- baseline
                        name ∈ {
                            DV_CODED_TEXT[id6] ∈ {
                                defining_code ∈ {
                                    CODE_PHRASE[id7] ∈ {[ac2]}
                                }
                            }
                        }
                        data ∈ {
                            ITEM_LIST[id8] ∈ {                              -- systemic arterial BP
                                items cardinality ∈ {2..*} ∈ {
                                    ELEMENT[id9] ∈ {                        -- systolic BP
                                        name ∈ {                            -- any synonym of &#39;systolic&#39;
                                            DV_CODED_TEXT[id10] ∈ {
                                                defining_code ∈ {
                                                    CODE_PHRASE[id11] ∈ {[ac2]}
                                                }
                                            }
                                        }
                                        value ∈ {
                                            DV_QUANTITY[id12] ∈ {
                                                magnitude ∈ {0..1000}
                                                property ∈ {[properties::944]}  -- &quot;pressure&quot;
                                                units ∈ {[units::387]}          -- &quot;mm[Hg]&quot;
                                            }
                                        }
                                    }
                                    ELEMENT[id79] ∈ {                            -- diastolic BP
                                        name ∈ {                             -- any synonym of &#39;diastolic&#39;
                                            DV_CODED_TEXT[id14] ∈ {
                                                defining_code ∈ {
                                                    CODE_PHRASE[id15] ∈ {[ac3]}
                                                }
                                            }
                                        }
                                        value ∈ {
                                            DV_QUANTITY[id16] ∈ {
                                                magnitude ∈ {0..1000}
                                                property ∈ {[properties::944]}   -- &quot;pressure&quot;
                                                units ∈ {[units::387]}           -- &quot;mm[Hg]&quot;
                                            }
                                        }
                                    }
                                    ELEMENT[id17] occurrences ∈ {0..*} ∈ {*}    -- unknown new item
                                }
                            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This definition expresses constraints on instances of the types <code>ENTRY</code> , <code>HISTORY</code> , <code>EVENT</code> , <code>ITEM_LIST</code> , <code>ELEMENT</code> , <code>QUANTITY</code> , and <code>CODED_TEXT</code> so as to allow them to represent a blood pressure measurement, consisting of a history of measurement events, each consisting of at least systolic and diastolic pressures, as well as any number of other items (expressed by the <code>[at9000]</code> "any" node near the bottom).</p>
</div>
<div class="sect3">
<h4 id="_design_time_and_run_time_paths">8.9.1. Design-time and Run-time paths</h4>
<div class="paragraph">
<p>All archetype object constraint nodes require a node identifier. When data are created according to the <code>definition</code> section of an archetype, the archetype node identifiers can be written into the data, providing a reliable way of finding data nodes, regardless of what other runtime names might have been chosen by the user for the node in question. There are two reasons for doing this. Firstly, querying cannot rely on runtime names of nodes (e.g. names like "sys BP", "systolic bp", "sys blood press." entered by a doctor are unreliable for querying); secondly, it allows runtime data retrieved from a persistence mechanism to be re-associated with the cADL structure which was used to create it.</p>
</div>
<div class="paragraph">
<p>An example which shows the difference between design-time meanings associated with node identifiers and runtime names is the following, from a <code>SECTION</code> archetype representing the problem/SOAP headings (a simple heading structure commonly used by clinicians to record patient contacts under top-level headings corresponding to the patient’s problem(s), and under each problem heading, the headings "subjective", "objective", "assessment", and "plan").</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id1] matches {                          -- problem
        name matches {
            DV_CODED_TEXT[id2] matches {
                defining_code matches {[ac1]}       -- any clinical problem type
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above, the node identifier <code>[id1]</code> is assigned a meaning such as "clinical problem" in the archetype terminology section. The subsequent lines express a constraint on the runtime <em>name</em> attribute, using the internal code <code>[ac1]</code> . The constraint <code>[ac1]</code> is also defined in the archetype terminology section with a formal statement meaning "any clinical problem type", which could clearly evaluate to thousands of possible values, such as "diabetes", "arthritis" and so on. As a result, in the runtime data, the node identifier corresponding to "clinical problem" and the actual problem type chosen at runtime by a user, e.g. "diabetes", can both be found. This enables querying to find all nodes with meaning "problem", or all nodes describing the problem "diabetes". Internal <code>[acNNNN]</code> codes are described in he section <a href="#_local_constraint_codes">Local Constraint Codes</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rules_section">8.10. Rules Section</h3>
<div class="paragraph">
<p>The <code>rules</code> section in an ADL archetype introduces assertions which relate to the entire archetype, and can be used to make statements which are not possible within the block structure of the <code>definition</code> section. Any constraint which relates more than one property to another is in this category, as are most constraints containing mathematical or logical formulae. Rules are expressed in the archetype assertion language, described in the <a href="#_assertions">Assertions</a> Section.</p>
</div>
<div class="paragraph">
<p>An assertion is a first order predicate logic statement which can be evaluated to a boolean result at runtime. Objects and properties are referred to using paths.</p>
</div>
<div class="paragraph">
<p>The following simple example says that the speed in kilometres of some node is related to the speed-in-miles by a factor of 1.6:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">rules
    validity: /speed[id2]/kilometres[id13]/magnitude = /speed[id4]/miles[id14]/magnitude * 1.6</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_terminology_section">8.11. Terminology Section</h3>
<div class="sect3">
<h4 id="_adl_1_4_1_5_version_compatibility">8.11.1. ADL 1.4 / 1.5 Version Compatibility</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    term_definitions = &lt;
        [&quot;en&quot;] = &lt;
            items = &lt;
                [&quot;at0001&quot;] = &lt;...&gt;
                [&quot;at0002&quot;] = &lt;...&gt;
            &gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_overview_7">8.11.2. Overview</h4>
<div class="paragraph">
<p>The <code>terminology</code> section of an archetype is expressed in ODIN, and is where codes representing node IDs, constraints on text or terms, and bindings to terminologies are defined. Linguistic language translations are added in the form of extra blocks keyed by the relevant language. The following example shows the layout of this section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">terminology
    term_definitions = &lt;
        [&quot;en&quot;] = &lt;
            [&quot;id1&quot;] = &lt;...&gt;
            [&quot;at1&quot;] = &lt;...&gt;
            [&quot;ac1&quot;] = &lt;...&gt;
        &gt;
        [&quot;de&quot;] = &lt;
            [&quot;id1&quot;] = &lt;...&gt;
            [&quot;at1&quot;] = &lt;...&gt;
            [&quot;ac1&quot;] = &lt;...&gt;
        &gt;
    &gt;
    term_bindings = &lt;
        [&quot;snomed_ct&quot;] = &lt;
            [&quot;id4&quot;] = &lt;...&gt;
            [&quot;ac1&quot;] = &lt;...&gt;
            ...
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ` term_definitions` section is mandatory, and must be defined for each translation carried out.</p>
</div>
</div>
<div class="sect3">
<h4 id="_term_definitions_section">8.11.3. Term_definitions Section</h4>
<div class="paragraph">
<p>This section is where all archetype local terms (including all at-codes, ac-codes, and at least the id-codes attached to container attribute children) are defined. The following example shows an extract from the English and German term definitions for the archetype local terms in a problem/SOAP headings archetype. Each term is defined using a structure of name/value pairs, and mustat least include the names "text" and "description", which are akin to the usual rubric, and full definition found in terminologies like SNOMED-CT. Each term object is then included in the appropriate language list of term definitions, as shown in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    term_definitions = &lt;
        [&quot;en&quot;] = &lt;
            [&quot;id1&quot;] = &lt;
                text = &lt;&quot;problem&quot;&gt;
                description = &lt;&quot;The problem experienced by the subject of care to which the contained information relates&quot;&gt;
            &gt;
            [&quot;id2&quot;] = &lt;
                text = &lt;&quot;problem/SOAP headings&quot;&gt;
                description = &lt;&quot;SOAP heading structure for multiple problems&quot;&gt;
            &gt;
            ...
            [&quot;id3&quot;] = &lt;
                text = &lt;&quot;plan&quot;&gt;
                description = &lt;&quot;The clinician&#39;s professional advice&quot;&gt;
            &gt;
        &gt;
        [&quot;de&quot;] = &lt;
            [&quot;id1&quot;] = &lt;
                    text = &lt;&quot;klinisches Problem&quot;&gt;
                    description = &lt;&quot;Das Problem des Patienten worauf sich diese Informationen beziehen&quot;&gt;
            &gt;
            [&quot;id2&quot;] = &lt;
                    text = &lt;&quot;Problem/SOAP Schema&quot;&gt;
                    description = &lt;&quot;SOAP-Schlagwort-Gruppierungsschema fuer mehrfache Probleme&quot;&gt;
            &gt;
            [&quot;id3&quot;] = &lt;
                    text = &lt;&quot;Plan&quot;&gt;
                    description = &lt;&quot;Klinisch-professionelle Beratung des Pflegenden&quot;&gt;
            &gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In some cases, term definitions may have been lifted from existing terminologies (only a safe thing to do if the definitions exactly match the need in the archetype). To indicate where definitions come from, a "provenance" tag can be used, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    [&quot;id3&quot;] = &lt;
        text = &lt;&quot;plan&quot;&gt;; description = &lt;&quot;The clinician&#39;s professional advice&quot;&gt;; provenance = &lt;&quot;ACME_terminology(v3.9a)&quot;&gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this does not indicate a <em>binding</em> to any term, only its origin. Bindings are described in the sectoin <a href="#Term_bindings">[Term_bindings]</a>.</p>
</div>
<div class="paragraph">
<p>The <code>term_definitions</code> section also includes definitions for archetype-local constraint codes, which are of the form <code>[acN]</code> . Each such code refers to some constraint such as "any term which is a subtype of ‘hepatitis’ in the ICD9AM terminology"; the constraint definitions do not provide the constraints themselves, but define the <em>meanings</em> of such constraints, in a manner comprehensible to human beings, and usable in GUI applications. This may seem a superfluous thing to do, but in fact it is quite important. Firstly, term constraints can only be expressed with respect to particular terminologies - a constraint for "kind of hepatitis" would be expressed in different ways for each terminology which the archetype is bound to. For this reason, the actual constraints are defined in the <code>term_bindings</code> section. An example of a constraint term definition for the hepatitis constraint is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    [&quot;ac1015&quot;] = &lt;
        text = &lt;&quot;type of hepatitis&quot;&gt;
        description = &lt;&quot;any term which means a kind of viral hepatitis&quot;&gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that while it often seems tempting to use classification codes, e.g. from the ICD vocabularies, these will rarely be much use in terminology or constraint definitions, because it is nearly always <em>descriptive</em> , not classificatory terms which are needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="_term_bindings_section">8.11.4. Term_bindings Section</h4>
<div class="paragraph">
<p>This section is used to describe the equivalences between archetype local terms and terms and value sets found in external terminologies. Bindings are expressed as URIs.</p>
</div>
<div class="paragraph tbd">
<p><strong>TBD</strong>: note that the actual URIs here are probably not yet correct; refer to IHTSDO / Mayo / CTS2 etc</p>
</div>
<div class="paragraph">
<p>The main purpose for allowing query engines to search for an instance of some external term to determine what equivalent to use in the archetype.</p>
</div>
<div class="sect4">
<h5 id="_global_term_bindings">Global Term Bindings</h5>
<div class="paragraph">
<p>There are two types of term bindings that can be used, ‘global’ and path-based. The former is where an external term is bound directly to an archetype local term, and the binding holds globally throughout the archetype. In many cases, archetype terms only appear once in an archetype, but in some archetypes, at-codes are reused throughout the archetype. In such cases, a global binding asserts that the correspondence is true in all locations. A typical global term binding section resembles the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    term_bindings = &lt;
        [&quot;umls&quot;] = &lt;
            [&quot;id1&quot;] = &lt;http://umls.nlm.edu/id/C124305&gt; -- apgar result
            [&quot;id2&quot;] = &lt;http://umls.nlm.edu/id/0000000&gt; -- 1-minute event
            [&quot;id4&quot;] = &lt;http://umls.nlm.edu/id/C234305&gt; -- cardiac score
            [&quot;id5&quot;] = &lt;http://umls.nlm.edu/id/C232405&gt; -- respiratory score
            [&quot;id6&quot;] = &lt;http://umls.nlm.edu/id/C254305&gt; -- muscle tone score
            [&quot;id7&quot;] = &lt;http://umls.nlm.edu/id/C987305&gt; -- reflex response score
            [&quot;id8&quot;] = &lt;http://umls.nlm.edu/id/C189305&gt; -- color score
            [&quot;id9&quot;] = &lt;http://umls.nlm.edu/id/C187305&gt; -- apgar score
            [&quot;id10&quot;] = &lt;http://umls.nlm.edu/id/C325305&gt; -- 2-minute apgar
            [&quot;id11&quot;] = &lt;http://umls.nlm.edu/id/C725354&gt; -- 5-minute apgar
            [&quot;id12&quot;] = &lt;http://umls.nlm.edu/id/C224305&gt; -- 10-minute apgar
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each entry indicates which term in an external terminology is equivalent to the archetype internal codes. Note that not all internal codes necessarily have equivalents: for this reason, a terminology binding is assumed to be valid even if it does not contain all of the internal codes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_path_based_bindings">Path-based Bindings</h5>
<div class="paragraph">
<p>The second kind of binding is one between an archetype path and an external code. This occurs commonly for archetypes where a term us re-used at the leaf level. For example, in the binding example below, the id4 code represents ‘temperature’ and the codes <code>id3</code>, <code>id5</code>, <code>id6</code> etc correspond to various times such as ‘any’, 1-hour average, 1-hour maximum and so on. Some terminologies (notably LOINC, the laboratory terminology in this example) define ‘pre-coordinated’ codes, such as ‘1 hour body temperature’; these clearly correspond not to single codes such as <code>id4</code> in the archetype, but to whole paths. In such cases, the key in each term binding row is a full path rather than a single term.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    term_bindings = &lt;
        [&quot;LNC205&quot;] = &lt;   -- LNC205 is a namespace corresponding to LOINC 205
            [&quot;/data[id2]/events[id3]/data[id1]/item[id4]&quot;] = &lt;http://loinc.org/id/8310-5&gt;
            [&quot;/data[id2]/events[id5]/data[id1]/item[id4]&quot;] = &lt;http://loinc.org/id/8321-2&gt;
            [&quot;/data[id2]/events[id6]/data[id1]/item[id4]&quot;] = &lt;http://loinc.org/id/8311-3&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bindings to external value sets are also included in the bindings section, also as URIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="odin">    term_bindings = &lt;
        [&quot;snomed_ct&quot;]    = &lt;
            [&quot;ac1&quot;] = &lt;http://snomed.info/id/12345&gt;
            [&quot;ac2&quot;] = &lt;http://snomed.info/id/678910&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, each local constraint code is formally defined to refer to a value set whose identifier is known in the SNOMED-CT terminology.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_deprecated_elements">8.11.5. Deprecated Elements</h4>
<div class="paragraph">
<p>In the 1.4 release of ADL, there were two separate bindings sections, <code>term_bindings ` and `constraint_bindings</code> . These have been merged into one section, <code>bindings</code> .</p>
</div>
<div class="paragraph">
<p>Additionally in ADL 1.4, a <code>terminologies_available</code> header statement was required to identify all terminologies for which <code>term_bindings</code> sections have been written. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    terminologies_available = &lt;"snomed_ct", "loinc"&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>This is no longer required. In archetypes that have it, it is ignored, and should not be included in ADL 1.5 or later syntax output serialisation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_annotations_section">8.12. Annotations Section</h3>
<div class="paragraph">
<p>The annotations section of an archetype or template provides a place for node-level meta-data to be added to the archetype. This can be used during the design phase to track dependencies, design decisions, and specific resource references. Each annotation is keyed by the path of the node being annotated, or a pure RM path, and may have any number of tagged elements. A typical annotations section looks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">annotations
    items = &lt;
        [&quot;en&quot;] = &lt;
            items = &lt;
                [&quot;/data/items[at0.37]/items[at0.38]/value&quot;] = &lt; -- Clin st. / stage
                    items = &lt;
                        [&quot;messaging requirement&quot;] = &lt;&quot;= ‘staging’ field in msg type 2345&quot;&gt;
                        [&quot;guideline&quot;] = &lt;&quot;http://guidelines.org/gl24.html#staging&quot;&gt;
                        [&quot;data dict equivalent&quot;] = &lt;&quot;NHS data item aaa.1&quot;&gt;
                    &gt;
                &gt;
                [&quot;/data/items[at0.37]/items[at0.39]/value&quot;] = &lt; -- Clin st. / Tumour
                    items = &lt;
                        [&quot;message requirement&quot;] = &lt;&quot;tumour field in msg type 2345&quot;&gt;
                        [&quot;guideline&quot;] = &lt;&quot;http://guidelines.org/gl24.html#mass&quot;&gt;
                        [&quot;data dict equivalent&quot;] = &lt;&quot;NHS data item aaa.2&quot;&gt;
                    &gt;
                &gt;
            &gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotations are defined as a separate section that can be easily removed in production versions of an archetype or template, and/or ignored in the generation of digital signatures.</p>
</div>
<div class="paragraph">
<p>Typically annotations are used to document a particular node within an archetype, specified by its (unique) archetype path. In some cases, the archetype (or tempate) author wants to document the use of a reference model attribute that is not constrained in the archetype (and therefore does not have an archetype path as such). In this case, the path will just be a valid RM path, i.e. a path relative to the top-level object of the archetype, and containing no at-codes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_revision_history_section_2">8.13. Revision History Section</h3>
<div class="paragraph">
<p>The revision history section of an archetype shows the audit history of changes to the archetype, and is expressed in ODIN syntax. It is optional, and is included at the end of the archetype, since it does not contain content of direct interest to archetype authors, and will monotonically grow in size. Where archetypes are stored in a version-controlled repository such as CVS or some commercial product, the revision history section would normally be regenerated each time by the authoring software, e.g. via processing of the output of the ‘prs’ command used with SCCS files, or ‘rlog’ for RCS files. The following shows a typical example, with entries in most-recent-first order (although technically speaking, the order is irrelevant to ADL).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="adl">revision_history
    revision_history = &lt;
        [&quot;1.57&quot;] = &lt;
            committer = &lt;&quot;Miriam Hanoosh&quot;&gt;
            committer_organisation = &lt;&quot;AIHW.org.au&quot;&gt;
            time_committed = &lt;2004-11-02 09:31:04+1000&gt;
            revision = &lt;&quot;1.2&quot;&gt;
            reason = &lt;&quot;Added social history section&quot;&gt;
            change_type = &lt;&quot;Modification&quot;&gt;
        &gt;
        -- etc
        [&quot;1.1&quot;] = &lt;
            committer = &lt;&quot;Enrico Barrios&quot;&gt;
            committer_organisation = &lt;&quot;AIHW.org.au&quot;&gt;
            time_committed = &lt;2004-09-24 11:57:00+1000&gt;
            revision = &lt;&quot;1.1&quot;&gt;
            reason = &lt;&quot;Updated HbA1C test result reference&quot;&gt;
            change_type = &lt;&quot;Modification&quot;&gt;
        &gt;
        [&quot;1.0&quot;] = &lt;
            committer = &lt;&quot;Enrico Barrios&quot;&gt;
            committer_organisation = &lt;&quot;AIHW.org.au&quot;&gt;
            time_committed = &lt;2004-09-14 16:05:00+1000&gt;
            revision = &lt;&quot;1.0&quot;&gt;
            reason = &lt;&quot;Initial Writing&quot;&gt;
            change_type = &lt;&quot;Creation&quot;&gt;
        &gt;
    &gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_terminology_integration">9. Terminology Integration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how archetype constraints on terminological entities can be expressed in their various forms, and how these constraints are resolved to concrete sets of terms.</p>
</div>
<div class="sect2">
<h3 id="_source_form_constraints">9.1. Source-form Constraints</h3>
<div class="literalblock">
<div class="content">
<pre> </pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_expanded_constraints">9.2. Expanded Constraints</h3>

</div>
<div class="sect2">
<h3 id="_constraint_resolution">9.3. Constraint Resolution</h3>
<div class="paragraph">
<p>Terminology constraints are an alternative to enumeration of value sets within an archetype. Inline enumeration will work perfectly well in a technical sense, but has at least two limitations. Firstly, the intended set of values allowed for the attribute may change over time (e.g. as has happened with ‘types of hepatitis’ since 1980), and since the authoritative resource is elsewhere, the archetype has to be continually updated. With a large repository of archetypes, each containing inline coded term constraints, this approach is likely to be unsustainable and error-prone. Secondly, the best means of defining the value set is in general not likely to be via enumeration of the individual terms, but in the form of a semantic expression that can be evaluated against the external resource. This is because the value set is typically logically specified in terms of inclusions, exclusions, conjunctions and disjunctions of general categories.</p>
</div>
<div class="paragraph discussion">
<p>Consider for example the value set logically defined as “any bacterial infection of the lung”. The possible values would be codes from a target terminology, corresponding to numerous strains of pneumococcus, staphlycoccus and so on, but not including species that are never found in the lung. Rather than enumerate the list of codes corresponding to this value set (which is likely to be quite large), the archetype author is more likely to rely on semantic links within the external terminology to express the set; a query such as <code>is-a bacteria and has-site lung</code> is definable against the SNOMED-CT <a href="#IHTSDO">[IHTSDO]</a> terminology for example.</p>
</div>
<div class="paragraph discussion">
<p>In a similar way, other value sets, including for quantitative values, are likely to be specified by queries or formal expressions, and evaluated by an external knowledge service. Examples include "any unit of pressure" and "normal range values for serum sodium".</p>
</div>
<div class="paragraph discussion">
<p>In such cases, expressing the terminology constraint could be done by including the query or other formal expression directly within the archetype itself. However, experience shows that this is problematic in various ways. Firstly, there is little if any standardisation in such formal value set expressions or queries for use with knowledge services - two archetype authors could easily create competing syntactical expressions for the same logical constraint. A second problem is that errors might be made in the query expression itself, or the expression may be correct at the time of authoring, but need subsequent adjustment as the relevant knowledge resource grows and changes. The consequence of this is the same as for a value set enumerated inline - it is unlikely to be sustainable for large numbers of archetypes.</p>
</div>
<div class="paragraph discussion">
<p>These problems are not accidental: a query with respect to a terminological, ontological or other knowledge resource is most likely to be authored correctly by maintainers or experts of the knowledge resource, rather than archetype authors; it may well be altered over time due to improvements in the query formalism itself.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_specialisation">10. Specialisation</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_8">10.1. Overview</h3>
<div class="paragraph">
<p>Archetypes can be specialised in a similar way to classes in object-oriented programming languages. Common to both situations is the use of a differential style of declaration, i.e. the contents of a specialised entity are expressed as differences with respect to the parent - previously defined elements from the parent that are not changed are not repeated in the descendant. Two extra constructs are included in the ADL syntax to support redefinition in specialised archetypes or templates.</p>
</div>
<div class="paragraph">
<p>The basic test that must be satisfied by a specialised archetype is as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>All possible data instance arrangements that conform to the specialised archetype must also conform to all of its parents, recursively to the ultimate parent.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This condition ensures that data created by a specialised archetype that is not itself shared by two systems can be processed by the use of a more general parent that is shared.</p>
</div>
<div class="paragraph">
<p>The semantics that allow this are similar to the ‘covariant redefinition’ (see <a href="#cov_contra">[cov_contra]</a>) notion used in some object-oriented programming languages, and can be summarised as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A non-specialised (i.e. top-level) archetype defines an instance space that is a subset of the space defined by the class in the reference information model on which the archetype is based.</p>
</li>
<li>
<p>A specialised archetype can specialise only one parent archetype, i.e. single inheritance.</p>
</li>
<li>
<p>A specialised archetype specifies an instance space defined by the following elements:</p>
</li>
<li>
<p>unchanged object and attribute constraints inherited from the parent archetype;</p>
</li>
<li>
<p>and one or more redefinitions, additions and removals.</p>
</li>
<li>
<p>All elements defined in a parent archetype are either inherited unchanged or redefined in a specialised child.</p>
</li>
<li>
<p>Specialised archetypes are expressed differentially with respect to the parent, i.e. they do not mention purely inherited elements, only redefinitions and extensions.</p>
</li>
<li>
<p>Extensions always define an additional subset of the instance space defined by the reference model element being extended (i.e. to which the ‘new’ objects belong). The extension capability allows archetypes to remain extensible without having to know in advance how or if they will be extended.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To understand specialisation properly, the object-oriented notion of flattening is required. This term refers to the operation of overlaying the (differential) definition of a specialised archetype on its ‘flat parent’, which is a flattened archetype obtained by a previous invocation of this process. The first invocation creates a flat archetype from overlaying a specialised archetype on a ‘top-level’ non-specialised archetype.</p>
</div>
<div class="paragraph">
<p>The contents of the definition of any specialised archetype are therefore understood as differences with respect to the <em>flat parent</em>, not the differential parent. This is exactly how object-oriented programming languages work.</p>
</div>
<div class="paragraph">
<p>The following sections describe the details of specialisation. The term ‘object’ is used synonymously with ‘object constraint’ since all elements in ADL are constraints unless otherwise indicated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_examples">10.2. Examples</h3>
<div class="paragraph">
<p>The examples below provide a basis for understanding most of the semantics discussed in the subsequent sections.</p>
</div>
<div class="sect3">
<h4 id="_redefinition_for_refinement">10.2.1. Redefinition for Refinement</h4>
<div class="paragraph">
<p>The example shown below is from an older version of the openEHR ‘Problem’ archetype and illustrates the use of redefinition and extension. The first text is the the definition section of the top-level ‘Problem’ archetype, and shows one <code>ELEMENT</code> node in expanded form, with the remaining nodes in an elided form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ------ openEHR-EHR-EVALUATION.problem.v1 ------

    EVALUATION[id1] ∈ {-- Problem
        data ∈ {
            ITEM_TREE[id2] ∈ {
                items cardinality ∈ {0..*; ordered} ∈ {
                    ELEMENT[id3] occurrences ∈ {1} ∈ {-- Problem
                        value ∈ {
                            DV_TEXT[id4]                                 -- *** NODE A
                        }
                    }
                    ELEMENT[id5] occurrences ∈ {0..1} ∈ {..}-- Date of initial onset
                    ELEMENT[id6] occurrences ∈ {0..1} ∈ {..}-- Age at initial onset
                    ELEMENT[id7] occurrences ∈ {0..1} ∈ {..}-- Severity
                    ELEMENT[id8] occurrences ∈ {0..1} ∈ {..}-- Clinical description
                    ELEMENT[id10] occurrences ∈ {0..1} ∈ {..}-- Date clinically received
                    CLUSTER[id11] occurrences ∈ {0..1} ∈ {..}-- Location
                    CLUSTER[id14] occurrences ∈ {0..1} ∈ {..}-- Aetiology
                    -- etc
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second text below is from the ‘problem-diagnosis’ archetype, i.e. a ‘diagnosis’ specialisation of the general notion of ‘problem’. In this situation, the node ` [id2]` , with occurrences of 1, i.e. mandatory non-multiple, has its meaning narrowed to ` [id2.1]` ‘diagnosis’ (diagnosed problems are seen as a subset of all problems in medicine), while new sibling nodes are added to the items attribute to define details particular to recording a diagnosis. The extension nodes are identified by the codes ` [at0.32]` , ` [at0.35]` and ` [at0.37]` , with the latter two shown in elided form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ------ openEHR-EHR-EVALUATION.problem-diagnosis.v1 ------                 -- specialisation of openEHR-EHR-EVALUATION.problem.v1

    EVALUATION[id1.1] ∈ {-- Recording of diagnosis
        /data[id2]/items[id3]/value ∈ {
            DV_CODED_TEXT[id4] ∈ {                                            --
                defining_code ∈ {[ac0.1]} -- X &#39;is_a&#39; diagnosis               -- &lt;&lt; This node is redefined from &#39;NODE A&#39; above
            }                                                                  --
        }
        /data/items cardinality ∈ {0..*; ordered} ∈ {
            before [id5]
            ELEMENT[id0.32] occurrences ∈ {0..1} ∈ { -- Status                -- ++ This node added
                value ∈ {
                    DV_CODED_TEXT[id0.33] ∈ {
                        defining_code ∈ {
                            [local::at0.33, at0.34] -- provisional
                        }
                    }
                }
            }
            after [id31]
            CLUSTER[id0.35] occurrences ∈ {0..1} ∈ {..} -- Diag. criteria     -- ++ This node added
            CLUSTER[id0.37] occurrences ∈ {0..1} ∈ {..} -- Clin. staging      -- ++ This node added
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_redefinition_for_specialisation">10.2.2. Redefinition for Specialisation</h4>
<div class="paragraph">
<p>The example shown below illustrates redefinition in a specialised archetype. The first text is taken from the definition section of the ‘laboratory result’ <code>OBSERVATION</code> archetype (available on <a href="http://www.openehr.org/ckm/#showArchetype_1013.1.350">openEHR.org</a>), and contains an <code>ELEMENT</code> node whose identifier is <code>[id79]</code> , defined as ‘panel item’ in the archetype terminology (sibling nodes are not shown here). The intention is that the <code>id79</code> node be specialised into particular ‘panel items’ or analytes according to particular types of test result. Accordingly, the <code>id79</code> node has occurrences of ` 0..*` and its value is not constrained with respect to the reference model, meaning that the type of the <code><em>value</em></code> attirbute can be any descendant of <code>DATA_VALUE</code> .</p>
</div>
<div id="redefinition-and-extension" class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ------ openEHR-EHR-OBSERVATION.laboratory.v1 ------
    OBSERVATION[id1] ∈ {-- Laboratory Result
        data ∈ {
            HISTORY[id2] ∈ {
                events ∈ {
                    EVENT[id3] ∈ {-- Any event
                        data ∈ {
                            ITEM_TREE[id4] ∈ {
                                items cardinality  {0..*; unordered} ∈ {
                                    CLUSTER[id5] occurrences ∈ {1} ∈ {..} -- Specimen
                                    ELEMENT[id8] occurrences ∈ {0..1} ∈ {..} -- Diagnostic services
                                    CLUSTER[id11] occurrences ∈ {0..*} ∈ {..} -- level 1
                                    ELEMENT[id79] occurrences ∈ {0..*} -- panel item
                                    ELEMENT[id17] occurrences ∈ {0..1} ∈ {..} -- Overall Comment
                                    CLUSTER[id18] occurrences ∈ {0..1} ∈ {..} -- Quality
                                    ELEMENT[id37] occurrences ∈ {0..1} ∈ {..} -- Multimedia rep.
                                }
                            }
                        }
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second text, below, is a specialised version of the laboratory result archetype, defining ‘thyroid function test result’.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ------ openEHR-EHR-OBSERVATION.laboratory-thyroid.v1 ------
    OBSERVATION[id1.1] -- Thyroid function tests
        /data[id2]/events[id3]/data[id4]/items ∈ {
            ELEMENT[id79.2] occurrences ∈ {0..1} ∈ {-- TSH
                value ∈ {
                    DV_QUANTITY[id0.7] ∈ {
                        property ∈ {[at15]}
                        magnitude ∈ {|0.0..100.0|}
                        units ∈ {&quot;mIU/l&quot;}
                    }
                }
            }
            ELEMENT[id79.7] occurrences ∈ {0..1} ∈ {..} -- Free Triiodothyronine (Free T3)
            ELEMENT[id79.8] occurrences ∈ {0..1} ∈ {..} -- Total Triiodothyronine (Total T3)
            ELEMENT[id79.3] occurrences ∈ {0..1} ∈ {..} -- Free thyroxine (Free T4)
            ELEMENT[id79.4] occurrences ∈ {0..1} ∈ {..} -- Total Thyroxine (Total T4)
            ELEMENT[id79.5] occurrences ∈ {0..1} ∈ {..} -- T4 loaded uptake
            ELEMENT[id79.9] occurrences ∈ {0..1} ∈ {..} -- Free Triiodothyronine index (Free T3 index)
            ELEMENT[id79.6] occurrences ∈ {0..1} ∈ {..} -- Free thyroxine index (FTI)
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The redefinitions include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a redefinition of the top-level object node identifier <code>[id1]</code> , with the specialised node identifier <code>[id1.1]</code>;</p>
</li>
<li>
<p>eight nodes redefining the <code>[id79]</code> node are shown, with overridden node identifiers <code>[id79.2]</code> - <code>[id79.9]</code>;</p>
</li>
<li>
<p>reduced occurrences (<code>0..1</code> in each case);</p>
</li>
<li>
<p>redefinition of the <code><em>value</em></code> attribute of each <code>ELEMENT</code> type to <code>DV_QUANTITY</code>, shown in expanded form for node <code>[id79.2]</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This archetype is typical of a class of specialisations that use only redefinition, due to the fact that all objects in the redefined part of the specialised version are semantically specific kinds of a general object, in this case, ‘panel item’.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specialisation_with_cloning">10.2.3. Specialisation with Cloning</h4>
<div class="paragraph">
<p>In the previous example, each of the nodes with identifiers of the form <code>id79.N</code> would be effectively copied to the flat output, since the node being redefined (<code>id79</code>) has no sub-structure, i.e. it is a ‘matches any’ node. However, the general case is that the node in the parent has its own structure, typically some boilerplate nodes that would be used by any specialisation. In that case, an archetype containing nodes that specialise a node with existing structure cause a ‘clone and overlay’ operation. That is, to generate the flat output of the specialised archetype, the parent node is first cloned from the flat parent to the new flat output, and then the specialised node is overlaid on the cloned structure. The following example shows a parent archetype that defines a ‘laboratory result’ structure as a <code>CLUSTER</code> containing a number of <code>ELEMENT</code> objects, defining things like Result value, Reference range guidance and so on. The <code>id2</code> Result value node is intended to be specialised.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    CLUSTER[id1] ∈ {                                                    -- Laboratory test panel
        items ∈ {
            CLUSTER[id3] ∈ {                                            -- Laboratory Result
                items ∈ {
                    ELEMENT[id2] occurrences ∈ {0..1}                   -- Result Value
                    ELEMENT[id4] ∈ {                                    -- Result Comment
                        value ∈ {
                            DV_TEXT[id15]
                        }
                    }
                    ELEMENT[id5] occurrences ∈ {0..1} ∈ {   -- Ref. Range Guidance
                        value ∈ {
                            DV_TEXT[id16]
                        }
                    }
                    ELEMENT[id6] occurrences ∈ {0..1} ∈ {   -- Result Value Status
                        value ∈ {
                            DV_CODED_TEXT[id17] ∈ {
                                defining_code ∈ {[ac1]}
                            }
                        }
                    }
                    ELEMENT[id7] occurrences ∈ {0..1} ∈ {   -- D/T Result Val Status
                        value ∈ {
                            DV_DATE_TIME[id18]
                        }
                    }
                }
            }
            allow_archetype CLUSTER[id14] ∈ {                             -- Other Detail
                include
                    archetype_id/value ∈ {/.*/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    CLUSTER[id1.1] ∈ {                                    -- Lipid studies panel
        /items ∈ {
            CLUSTER[id3.1] ∈ {                            -- LDL
                items ∈ {
                    ELEMENT[id2.2] ∈ {
                        value ∈ {
                            DV_QUANTITY[id0.1] ∈ {
                                property ∈ {[at0.1]}
                                magnitude ∈ {|&gt;=0.0|}
                                units ∈ {&quot;mmol/l&quot;}
                            }
                        }
                    }
                }
            }
            CLUSTER[id3.2] ∈ {                            -- HDL
                items ∈ {
                    ELEMENT[id2.3] ∈ {
                        value matches {
                            DV_QUANTITY[id0.2] ∈ {
                                property ∈ {[at0.1]}
                                magnitude ∈ {|&gt;=0.0|}
                                units ∈ {&quot;mmol/l&quot;}
                            }
                        }
                    }
                }
            }

            CLUSTER[id3.5] ∈ {                     -- Cholesterol Result
                items ∈ {
                    ELEMENT[id2.4] ∈ {
                        value matches {
                            DV_QUANTITY[id0.5] ∈ {
                                property ∈ {[at0.1]}
                                magnitude ∈ {|&gt;=0.0|}
                                units ∈ {&quot;mosmol/l&quot;}
                            }
                        }
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flattened result consists of a number of repetitions of the entire <code>CLUSTER[id3]</code> structure from the parent, corresponding to the specialisations in the child. The ADL source form is tool large to show here, but the ADL Workbench provides a visualisation in <a href="#specialisation_with_cloning">Specialisation with Cloning</a>. In this figure we can see that the <code>CLUSTER</code> / <code>ELEMENT</code> overlays from the child archetype have been overlaid on clones of the <code>CLUSTER[id3]</code> structure from the parent, preserving the <code>id4</code> , <code>id5</code> etc nodes.</p>
</div>
<div id="specialisation_with_cloning" class="imageblock text-center" style="text-align: center">
<div class="content">
<img src="images/specialisation_with_cloning.png" alt="specialisation with cloning" width="70%">
</div>
<div class="title">Figure 4. Specialisation with Cloning</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_specialisation_concepts">10.3. Specialisation Concepts</h3>
<div class="sect3">
<h4 id="_differential_and_flat_forms">10.3.1. Differential and Flat Forms</h4>
<div class="paragraph">
<p>Specialised archetypes in their authored form are represented in ‘differential’ form. The syntax is the same as for non-specialised archetypes, with two additions: specialisation paths (see <a href="#_specialisation_paths">Specialisation Paths</a>) and ordering indicators (see <a href="#_ordering_of_sibling_nodes">Ordering of Sibling Nodes</a>). For a specialised archetype therefore, the lineage of archetypes back to the ultimate parent must be taken into account in order to obtain its complete semantics.</p>
</div>
<div class="paragraph">
<p>Differential form means that the only attributes or objects mentioned are those that redefine corresponding elements in the parent and those that introduce new elements. The differential approach to representation of specialised archetypes give rise to the need for a <em>flat form</em> of a specialised archetype: the equivalent archetype defined by the sum of the (differential) child and its parent, as if the child archetype had been defined standalone. The flat form of archetypes is used for building templates, and subsequently at runtime. It is generated by ‘compressing’ the effects of inheritance of the parent to the specialised child into a single archetype, and applies recursively all the way up an archetype lineage to the ultimate parent, which must be a top-level (non-specialised) archetype. For a top-level archetype, the flat-form is the same as its differential form (i.e. in a top-level archetype, every node is considered to be an extension node).</p>
</div>
</div>
<div class="sect3">
<h4 id="_specialisation_levels">10.3.2. Specialisation Levels</h4>
<div class="paragraph">
<p>In order to talk about archetypes at different levels of specialisation, a standard way of identifying the levels of specialisation is used, as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>level 0: top-level, non-specialised archetypes</p>
</li>
<li>
<p>level 1: specialisations of level 0 archetypes</p>
</li>
<li>
<p>level 2: specialisations of level 1 archetypes</p>
</li>
<li>
<p>etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For nodes carrying a node identifier, the specialisation level is always equal to the number of ‘.’ characters found in the identifier.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specialisation_paths">10.3.3. Specialisation Paths</h4>
<div class="paragraph">
<p>Because ADL is a block-structured language, the redefinition of nodes deep in the parent structure normally requires descending into the structure. Since it is common to want to further constrain only nodes deep within a structure in specialised archetype, a more convenient way is provided in ADL to do this using a <em>specialisation path</em>, illustrated by the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    OBSERVATION[id1.1] ∈ {                                   -- Thyroid function tests
        /data[id2]/events[id3]/data[id4]/items ∈    {
                ELEMENT[id79.2] occurrences ∈ {0..1} ∈ {    -- TSH
                    value ∈ {
                        DV_QUANTITY[id0.7] ∈ {   ... }
                    }
                }
                ELEMENT[id79.7] occurrences ∈ {0..1} ∈ {..} -- Free T3
                ....
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this fragment, a path is used rather than an attribute name. A path can be used in this manner only if no further constraints are required ‘on the way’ into the deep structure, with the exception of id-code overrides (since these can be syntactically accommodated within the path).</p>
</div>
<div class="paragraph">
<p>The rules for specialisation paths are as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A specialisation path is constructed down to the first attribute having any child objects to be further constrained in the present archetype.</p>
</li>
<li>
<p>All path segments must carry an id-code predicate.</p>
</li>
<li>
<p>The shortest useful path that can be used is <code>/</code> followed by an attribute name from the top level class being constrained by the archetype.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_path_congruence">10.3.4. Path Congruence</h4>
<div class="paragraph">
<p>Any node in an archetype can unambiguously be located by its archetype path. For example, the text value of the ‘problem’ node of the <code>openEHR-EHR-EVALUATION.problem.v1</code> archetype shown at the top of <a href="#redefinition-and-extension">[redefinition-and-extension]</a> is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/items[id3]/value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly the path to the redefined version of the same node in the <code>openEHR-EHR-EVALUATION.problem-diagnosis.v1</code> archetype at the bottom of the same figure is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/items[id3.1]/value</code></pre>
</div>
</div>
<div class="paragraph">
<p>By inspection, it can be seen that this path is a variant of the corresponding path in the parent archetype, where a particular object node identifier has been specialised.</p>
</div>
<div class="paragraph">
<p>In general, the path of every redefined node in a specialised archetype will have a direct equivalent in the parent archetype, which can be determined by removing one level of specialisation from any node identifiers within the specialised path that are at the level of specialisation of the specialised archetype (i.e. node identifiers corresponding to higher specialisation levels are not changed). In this way, the nodes in a specialised archetype source can be connected to their counterparts in parent archetypes, for purposes of validation and flattening.</p>
</div>
<div class="paragraph">
<p>Conversely, any given path in an archetype that has children will have congruent paths in the children wherever nodes have been specialised.</p>
</div>
</div>
<div class="sect3">
<h4 id="_redefinition_concepts">10.3.5. Redefinition Concepts</h4>
<div class="paragraph">
<p>A specialised archetype definition at any level consists of a set of changes with respect to its flat parent. The technically available changes are categorised as follows.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Logical Intention</th>
<th class="tableblock halign-left valign-top">Physical Redefinition</th>
<th class="tableblock halign-left valign-top">Criteria</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>Attibute node constraints</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MANDATE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential attribute node refines existence to 1.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has same attribute name as a node at the same path location in the flat parent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCLUDE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential attribute node refines existence to 0.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has same attribute name as a node at the same path location in the flat parent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REFINE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential attribute node refines cardinality of attribute at corresponding location in flat parent.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has same attribute name as a node at the same path location in the flat parent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD a new node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential attribute node will be added to parent object node at corresponding location in flat parent.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node does not exist in the flat parent, only in the Reference Model.</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="3"><p class="tableblock"><strong>Object node constraints</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REFINE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential object node and sub-elements will OVERRIDE corresponding node, and some / all of its sub-elements from the flat parent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences = 1 or else differential node is sole replacement and has max occurrences = 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPECIALISE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential object node(s) and sub-elements will OVERRIDE a CLONE of the corresponding node, and some / all of its sub-elements from the flat parent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences &gt; 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ADD a new node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential object node(s) and sub-elements will be ADDed to container or single-valued attribute. In the case of a container, ordering can be controlled with the before/after constraint.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has a specialised node identifier, and corresponding node in flat parent has max occurrences &gt; 1.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCLUDE an existing node.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential object node DELETEs existing node which has min occurrences = 0 (i.e. can’t delete a mandatory node).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node has same node identifier as corresponding node in parent, and occurrences = 0..0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FILL a slot.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">External reference node will be added as slot filler next to corresponding slot from flat parent.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node is an external reference node, has specialised node identifier of a slot in the flat parent.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLOSE a slot.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Archetype slot node causes corresponding slot from flat parent to be closed to further filling.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Differential node is an archetype slot node, with same node identifier as a slot in the flat parent, and has the ‘closed’ flag set.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In the ADL syntax, objects can be specified in two places: under single-value attributes and under multiply-valued (container) attributes.</p>
</div>
<div class="paragraph">
<p>Each object under a single-valued attribute defines an alternative that may be used to constrain data at that attribute position. An example is the <code>OBSERVATION</code>.<code><em>protocol</em></code> attribute from the openEHR reference model: if multiple objects appear under this attribute, only one can be used at runtime to constrain data.</p>
</div>
<div class="paragraph">
<p>Within a container attribute, the meaning of multiple objects is that each child object defines constraints on one or more members of the container in the data. The <code>occurrences</code> constraint on each one determines how many objects in the data match a given object constraint in the attribute.</p>
</div>
<div class="paragraph">
<p>Object constraints can be specialised in both places by redefinition, refinement and exclusion. Addition can also be used under either kind of attribute: in both cases, it corresponds to an alternative. The actual semantics are described in terms of object node identification, type redefinition, and structural constraints (existence, cardinality and occurrences), and are the same for objects under single- and multiply-valued attributes. The following sections describe the details.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_attribute_redefinition">10.4. Attribute Redefinition</h3>
<div class="paragraph">
<p>A small number of things can be redefined on attributes, including existence and cardinality. A basic rule of redefinition is that a specialised archetype cannot change the multiplicity type of an attribute.</p>
</div>
<div class="sect3">
<h4 id="_existence_redefinition_mandation_and_exclusion">10.4.1. Existence Redefinition: Mandation and Exclusion</h4>
<div class="paragraph">
<p>All attributes mentioned in an archetype have an <em>existence</em> constraint, indicating whether a value is required or not. The constraint is either stated explicitly - typically done for single-valued attirbutes - or it is the value from the reference model - typical for multiply-valued attributes. In both cases, the existence of an attribute in a parent archetype can be redefined in a specialised archetype using the standard cADL syntax. In the following example, an implicit existence constraint picked up from the reference model of <code>{0..1}</code> is redefined in a child archetype to <code>{1}</code> , i.e. mandatory.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    OBSERVATION[id1] ∈ { -- blood pressure measurement
        protocol ∈ { -- existence not changed from reference model
            -- etc
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    OBSERVATION[id1.1] ∈ { -- paediatric blood pressure measurement
        /protocol existence ∈ {1} ∈ {
            -- etc
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Redefinition of existence to ` {0}` by this method denotes exclusion, i.e. removal of the entire attribute (including all sub-structure) from the resulting structure. In an archetype, it is likely to indicate poor design, given that the decision to remove optional attributes is much more likely to be local, and therefore more appropriate in templates rather than archetypes; within a template it would be perfectly normal. The following example shows the protocol attribute in the above ` OBSERVATION` archetype being excluded in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">   OBSERVATION[id1] ∈ { -- paediatric blood pressure measurement
        /protocol existence ∈ {0}
    }</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre> 
Note that in the above, the ‘/’ is used to denote ‘/protocol’ as a differential path. Without the slash, the ‘protocol’ attribute would be considered to be trying to constrain a hitherto unconstrained attribute called ‘protocol’, rather than redefine a constraint already present in a parent archetype.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_multiply_valued_container_attributes">10.4.2. Multiply-valued (Container) Attributes</h4>
<div class="paragraph">
<p>The following sub-sections describe specialisation semantics specific to container attributes.</p>
</div>
<div class="sect4">
<h5 id="_cardinality_2">Cardinality</h5>
<div class="paragraph">
<p>The <em>cardinality</em> constraint defines how many object instances can be in the container within the data (not the archetype). In a specialised archetype, cardinality can be redefined to be a narrower range than in the parent, further limiting the valid ranges of items in the data that may occur within the container. This would normally only make sense if refinements were made to the occurrences of the contained items, i.e.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>narrowing the occurrences range of an object;</p>
</li>
<li>
<p>excluding an object by setting its occurrences to {0};</p>
</li>
<li>
<p>adding new objects, which themselves will have occurrences constraints;</p>
</li>
<li>
<p>setting some object occurrences to mandatory, and the enclosing cardinality lower limit to some non-zero value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>As long as the relationship between the enclosing attribute’s cardinality constraint and the occurrences constraints defined on all the contained items (including those inherited unchanged, and therefore not mentioned in the specialised archetype) is respected (see VCOC validity rule, AOM specification), any of the above specialisations can occur.</p>
</div>
<div class="paragraph">
<p>The following provides an example of cardinality redefinition.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    ITEM_LIST[id3] ∈ { -- general check list
        items cardinality ∈ {0..*} ∈ { -- any number of items
            ELEMENT[id12] occurrences ∈ {0..*} ∈ {} -- generic checklist item
        }
    }</pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    ITEM_LIST[id3] ∈ { -- pre-operative check list
        /items cardinality ∈ {3..10} ∈ { -- at least 3 mandatory items
            ELEMENT[id12.1] occurrences ∈ {1} ∈ {} -- item #1
            ELEMENT[id12.2] occurrences ∈ {1} ∈ {} -- item #2
            ELEMENT[id12.3] occurrences ∈ {1} ∈ {} -- item #3
            ELEMENT[id12.4] occurrences ∈ {0..1} ∈ {} -- item #4
            ...
            ELEMENT[id12.10] occurrences ∈ {0..1} ∈ {} -- item #10
        }
    }</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ordering_of_sibling_nodes">Ordering of Sibling Nodes</h5>
<div class="paragraph">
<p>Within container attributes, the order of objects may be significant from the point of view of domain users, i.e. the container may be considered as an ordered list. This is easy to achieve in top-level archetype, using the ‘ordered’ qualifier on a cardinality constraint. However when particular node(s) are redefined into multiple specialised nodes, or new nodes added by extension, the desired order of the new nodes may be such that they should occur interspersed at particular locations among nodes defined in the parent archetype. The following text is a slightly summarised view of the items attribute from the problem archetype shown in <a href="#Specialised archetype showing redefinition and extension">[Specialised archetype showing redefinition and extension]</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>    items cardinality ∈ {0..*; ordered} ∈ {
        ELEMENT[id2] occurrences ∈ {1} ∈ {..}                         -- Problem
        ELEMENT[id3] occurrences ∈ {0..1} ∈ {..}                      -- Date of initial onset
        ELEMENT[id4] occurrences ∈ {0..1} ∈ {..}                      -- Age at initial onset
        ELEMENT[id5] occurrences ∈ {0..1} ∈ {..}                      -- Severity
        ELEMENT[id9] occurrences ∈ {0..1} ∈ {..}                      -- Clinical description
        ELEMENT[id10] occurrences ∈ {0..1} ∈ {..}                     -- Date clinically received
        CLUSTER[id11] occurrences ∈ {0..*} ∈ {..}                     -- Location
        CLUSTER[id14] occurrences ∈ {0..1} ∈ {..}                     -- Aetiology
        CLUSTER[id18] occurrences ∈ {0..1} ∈ {..}                     -- Occurrences or exacerb’ns
        CLUSTER[id26] occurrences ∈ {0..1} ∈ {..}                     -- Related problems
        ELEMENT[id30] occurrences ∈ {0..1} ∈ {..}                     -- Date of resolution
        ELEMENT[id31] occurrences ∈ {0..1} ∈ {..}                     -- Age at resolution
    }</pre>
</div>
</div>
<div class="paragraph">
<p>To indicate significant ordering in the specialised problem-diagnosis archetype, the keywords ` before` and ` after` can be used, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id3]/items ∈ {
        before [id3]
        ELEMENT[id2.1] ∈ {..}                         -- Diagnosis
        ELEMENT[id0.32] occurrences ∈ {0..1} ∈ {..}  -- Status
        after [id26]
        CLUSTER[id0.35] occurrences ∈ {0..1} ∈ {..}  -- Diagnostic criteria
        CLUSTER[id0.37] occurrences ∈ {0..1} ∈ {..}  -- Clinical Staging
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These keywords are followed by a node identifier reference, and act to modify the node definition immediately following. Technically the following visual rendition would be more faithful, but it is less readable, and makes no difference to a parser:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    after [id26] CLUSTER[id0.35] occurrences ∈ {0..1} ∈ {..} -- etc</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rules for specifying ordering are as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Ordering is only applicable to object nodes defined within a multiply-valued (i.e. container) attribute whose cardinality includes the <code>ordered</code> constraint;</p>
</li>
<li>
<p>Any <code>before</code> or <code>after</code> statement can refer to the node identifier of any sibling node known in the flat form of the archetype, i.e.:</p>
</li>
<li>
<p>the identifier of any redefined node;</p>
</li>
<li>
<p>the identifier of any new node;</p>
</li>
<li>
<p>the identifier of any inherited node that is not redefined amongst the sibling nodes.</p>
</li>
<li>
<p>If no ordering indications are given, redefined nodes should appear in the same position as the nodes they replace, while extension nodes should appear at the end.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If ordering indicators are used in an archetype that is itself further specialised, the following rules apply:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the referenced identifier becomes unavailable due to being redefined in the new archetype, it must be redefined to refer to an available sibling identifier as per the rules above.</p>
</li>
<li>
<p>If this does not occur, a <code>before</code> reference will default to the first sibling node identifier currently available conforming to the original identifier, while an after reference will default to the <em>last</em> such identifier available in the current flat archetype.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If, due to multiple levels of redefinition, there is more than one candidate to go before (or after) a given node, the compiler should output a warning. The problem would be resolved by the choice of one of the candidates being changed to indicate that it is to be ordered before (after) another of the candidates rather than the originally stated node.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_object_redefinition">10.5. Object Redefinition</h3>
<div class="paragraph">
<p>Object redefinition can occur for any object constraint in the parent archeype, and can include redefinition of node identifier, occurrences, reference model type. For certain kinds of object constraints, specific kinds of redefinition are possible.</p>
</div>
<div class="sect3">
<h4 id="_node_identifiers_3">10.5.1. Node Identifiers</h4>
<div class="paragraph">
<p>In an archetype, node identifiers (‘id-codes’) are mandatory on all object constraint nodes. The identifiers of those object nodes defined as children of a multiply-valued attribute and multiple alternative children of single-valued attributes (see <a href="#_node_identifiers">Node Identifiers</a>) require definitions in the archetype terminology. Definitions are optional on other single child constraints of single-valued attributes. This rule applies in specialised as well as top-level archetypes.</p>
</div>
<div class="paragraph">
<p>A key question is: when does a node identifier need to be redefined? There are three possible situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when the node is the root node of an archetype, the meaning is always considered to be redefined;</p>
</li>
<li>
<p>it can be redefined for purely semantic purposes on other nodes, e.g. to redefine ‘heart rate’ to ‘fetal heart rate’;</p>
</li>
<li>
<p>a node identifier must be redefined if the node is being redefined into multiple child nodes, either under a multiply-valued attribute, or as alternatives under a single-valued attribute.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Redefinition of an object node identifier for purely semantic purposes, unaccompanied by any other kind of constraint change is done as shown in the following example.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    EVALUATION[id1] ∈ {                             -- Medical Certificate
        data ∈ {
            ITEM_TREE[id2] ∈ {
                items ∈ {
                    ELEMENT[id5] occurrences ∈ {0..1} ∈ {   -- Description
                        value ∈ {
                            DV_TEXT[id7] ∈ {*}
                        }
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    EVALUATION[id1.1] ∈ {                              -- Singapore Medical Certificate
        /data[id2]/items ∈ {
            ELEMENT[id5.1]                              -- Summary
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the <code>id5</code> (‘Description’) node is refined in meaning to <code>id5.1</code> (‘Summary’). Since there is no other constraint to be stated, no further <code>matches</code> block is required.</p>
</div>
<div class="paragraph">
<p>An example of the 3rd case above of redefinition is shown in the first archetype in <a href="#Specialised archetype showing redefinition and extension">[Specialised archetype showing redefinition and extension]</a>, where the node <code>[id79]</code> is redefined into a number of more specialised nodes <code>[id79.2]</code> - <code>[id79.9]</code> , while in the second, the identifier <code>[id2]</code> is redefined to a single node <code>[id2.1]</code> .</p>
</div>
<div class="sect4">
<h5 id="_node_redefinition_semantics">Node Redefinition Semantics</h5>
<div class="paragraph">
<p>The syntactic form of the identifier of a redefined node is a copy of the original followed by a dot (‘.’), optionally intervening instances of the pattern ‘0.’ and then a further non-zero number, i.e.:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>idN {.0}* .N</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This permits node identifiers from a given level to be redefined not just at the next level, but at multiple levels below.</p>
</div>
<div class="paragraph">
<p>Examples of redefined node identifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id2.1</code>  &#8201;&#8212;&#8201;redefinition of <code>id1</code> at level 1 specialisation</p>
</li>
<li>
<p><code>id2.0.1</code>&#8201;&#8212;&#8201;redefinition of <code>id1</code> node in level 2 specialisation archetype</p>
</li>
<li>
<p><code>id2.1.1</code>&#8201;&#8212;&#8201;redefinition of <code>id2.1</code> in level 2 specialisation archetype.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Redefined versions of nodes with no node id in the parent archetype do not require a node identifier in the child archetype.</p>
</div>
<div class="paragraph">
<p>In both cases, there is a question of whether the original node being redefined (<code>id79</code> and <code>id2</code> respectively in the examples) remains available for further redefinition in subsequent child archetypes, or do the redefinition children exhaustively define the instance space for the given parent node?</p>
</div>
<div class="paragraph">
<p>Should these children be considered exhaustive? One point of view says so, since all subsequently discovered varieties of hepratitis (C, D, E, etc) would now become children of ‘hepatitis non-A non-B’. However this is likely to be sub-optimal, since now the category ‘hepatitis non-A non-B’ probably exists solely because of the order in which the various hepatitis virus tests were perfected. Therefore an alternative argument would say that the categories ‘hepatitis C’, ‘hepatitis D’ etc should be defined directly below ‘hepatitis’, as if ‘hepatitis non-A non-B’ had never existed. Under this argument, the children would not be declared, even when they are theoretically exhaustive.</p>
</div>
<div class="paragraph">
<p>This kind of argument comes up time and again, and the need for catch-all categories (archetype nodes) and the possibility of future discoveries cannot be predicted. Even in situations such as a lab result (e.g. cholesterol), where the list of analytes seem to be known and fixed, experience of clinical modellers has shown that there is nevertheless no guarantee of not needing another data point, perhaps for something other than an analyte.</p>
</div>
<div class="paragraph">
<p>The default situation is that they do , unless explicitly stated otherwise, by excluding the parent node in the normal way (i.e. using occurrences matches <code>{0}</code>).The first example would then become:</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    items cardinality ∈ {0..*; unordered} ∈ {
        CLUSTER[id4] occurrences ∈ {1} ∈ {..}                          -- Specimen
        CLUSTER[id11] occurrences ∈ {0..*} ∈ {..}                      -- level 1
        ELEMENT[id79] occurrences ∈ {0..*} ∈ {                         -- panel item
            value ∈ {*}
        }
        ELEMENT[id17] occurrences ∈ {0..1} ∈ {..}                      -- Overall Comment
        ELEMENT[id37] occurrences ∈ {0..1} ∈ {..}                      -- Multimedia rep.
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data/events[id2]/data/items ∈ {
        ELEMENT[id79.2] occurrences ∈ {0..1} ∈ {    ..}                -- TSH
        ELEMENT[id79.7] occurrences ∈ {0..1} ∈ {..}                    -- Free Triiodothyronine
        ELEMENT[id79.8] occurrences ∈ {0..1} ∈ {..}                    -- Total Triiodothyronine
        ELEMENT[id79.3] occurrences ∈ {0..1} ∈ {..}                    -- Free thyroxine (Free T4)
        ELEMENT[id79.4] occurrences ∈ {0..1} ∈ {..}                    -- Total Thyroxine (Total T4)
        ELEMENT[id79.5] occurrences ∈ {0..1} ∈ {..}                    -- T4 loaded uptake
        ELEMENT[id79.9] occurrences ∈ {0..1} ∈ {..}                    -- Free Triiodothyronine index
        ELEMENT[id79.6] occurrences ∈ {0..1} ∈ {..}                    -- Free thyroxine index (FTI)
        ELEMENT[id79] occurrences ∈ {0}
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without the above specification, a further child archetype could then redefine both the original <code>id79</code> node (e.g. into <code>id79.0.1</code> , <code>id79.0.2</code>), and any of the <code>id79</code> nodes (e.g. <code>id79.1.1</code> , <code>id79.1.2</code> ); with it, only the latter is possible.</p>
</div>
</div>
<div class="sect4">
<h5 id="_adding_nodes">Adding Nodes</h5>
<div class="paragraph">
<p>Added object constraint nodes carry identifiers according to the rule mentioned above. The second example includes the new node identifiers <code>id0.32</code> , <code>id0.35</code> and <code>id0.37</code> , whose codes start with a ‘0’. indicating that they have no equivalent code in the parent archetype.</p>
</div>
<div class="paragraph">
<p>The node identifier syntax of an extension node commences with at least one instance of the pattern ‘0.’. The structure of node identifiers for both kinds of node thus always indicates at what level the identifier was introduced, given by the number of dots.</p>
</div>
<div class="paragraph">
<p>Examples of redefined node identifiers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>id0.1</code>  &#8201;&#8212;&#8201;identifier of extension node introduced at level 1</p>
</li>
<li>
<p><code>id0.0.1</code>&#8201;&#8212;&#8201;identifier of extension node introduced at level 2</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a flat form is created, the level at which any given node was introduced or redefined is clear due to the identifier coding system.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_occurrences_redefinition_and_exclusion">10.5.2. Occurrences Redefinition and Exclusion</h4>
<div class="paragraph">
<p>The <code>occurrences</code> constraint on an object node indicates how many instances within the data may conform to that constraint (see <a href="#_container_attributes">Container Attributes</a>). If occurrences is redefined on an identified node, the node identifier must be specialised. Within container attributes, <code>occurrences</code> is usually redefined in order to make a given object mandatory rather than optional; it can also be used to exclude an object constraint. In the following example, the occurrences of the <code>id3</code> node is redefined from <code>{0..1}</code> i.e. optional, to <code>{1}</code> , i.e. mandatory.</p>
</div>
<div class="paragraph">
<p>Parent (<code>openEHR-EHR-EVALUATION.problem.v1.0.3</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    EVALUATION[id1] ∈ { -- Problem
        data ∈ {
            ITEM_TREE[id2] ∈ {
                items cardinality ∈ {0..*; ordered} ∈ {
                    ELEMENT[id3] occurrences ∈ {1} ∈ {..}       -- Problem
                    ELEMENT[id4] occurrences ∈ {0..1} ∈ {..}    -- Date of initial onset
                    -- etc
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child (<code>openEHR-EHR-EVALUATION.problem-diagnosis.v1</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/items ∈ {
        ELEMENT[id4] occurrences ∈ {1}  -- Date of initial onset
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above we can see that if the only change in the redefinition is to occurrences, the remainder of the block from the parent is not repeated in the child. Occurrences is normally only constrained on child objects of container attributes, but can be set on objects of any attribute to effect exclusion of part of the instance space. This can be useful in archetypes where a number of alternatives for a single-valued attribute have been stated, and the need is to remove some alternatives in a specialised child archetype. For example, an archetype might have the following constraint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id3] ∈ {
        value ∈ {
            DV_QUANTITY[id4] ∈ {*}
            DV_INTERVAL&lt;DV_QUANTITY&gt;[id5] ∈ {*}
            DV_COUNT[id6] ∈ {*}
            DV_INTERVAL&lt;DV_COUNT&gt;[id7] ∈ {*}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the intention is to remove the <code>DV_INTERVAL&lt;*&gt;</code> alternatives. This is achieved by redefining the enclosing object to removed the relevant types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id3] ∈ {
        value ∈ {
            DV_INTERVAL&lt;DV_QUANTITY&gt;[id4] occurrences ∈ {0}
            DV_INTERVAL&lt;DV_COUNT&gt;[id7] occurrences ∈ {0}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Exclusion by setting occurrences to <code>{0}</code> is also common in templates, and is used to remove specific child objects of container attributes, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    /data[id2]/items ∈ {
        CLUSTER[id26] occurrences ∈ {0}     -- remove ‘Related problems’
        ELEMENT[id31] occurrences ∈ {0}     -- remove ‘Age at resolution’
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the whole attribute is to be removed, this can be done by redefining existence to <code>{0}</code>, as described in <a href="#_existence_redefinition_mandation_and_exclusion">Existence Redefinition: Mandation and Exclusion</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_reference_model_type_refinement">10.5.3. Reference Model Type Refinement</h4>
<div class="paragraph">
<p>The type of an object may be redefined to one of its subtypes as defined by the reference model. A typical example of where this occurs in archetypes based on the openEHR reference model is when <code>ELEMENT</code>.<code><em>value</em></code> is constrained to <code>*</code> in a parent archetype, meaning ‘no further constraint on its RM type of <code>DATA_VALUE</code>’, but is then constrained in a specialised archetype to subtypes of <code>DATA_VALUE</code>, e.g. <code>DV_QUANTITY</code> or <code>DV_PROPORTION</code> (see <a href="#openehr_data_types">[openehr_data_types]</a>). The following figure containts a simplified extract of the data values part of the openEHR reference model, and is the basis for the examples below.</p>
</div>
<div id="specialisation_with_cloning" class="imageblock text-center" style="text-align: center">
<div class="content">
<img src="images/specialisation_with_cloning.png" alt="specialisation with cloning">
</div>
<div class="title">Figure 5. Specialisation with Cloning</div>
</div>
<div class="paragraph">
<p>The most basic form of type refinement is shown in the following example:</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {*} -- any subtype of DATA_VALUE, from the ref model</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value ∈ {
        DV_QUANTITY[id8] ∈ {*} -- now limit to the DV_QUANTITY subtype
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meaning of the above is that instance data constrained by the specialised archetype at the value node must match the <code>DV_QUANTITY</code> constraint only - no other subtype of <code>DATA_VALUE</code> is allowed.</p>
</div>
<div class="paragraph">
<p>When a type in an archetype is redefined into one of its subtypes, any existing constraints on the original type in the parent archetype are respected. In the following example, a <code>DV_AMOUNT</code> constraint that required <em>accuracy</em> to be present and in the range +/-5% is refined into a <code>DV_QUANTITY</code> in which two attributes of the subtype are constrained. The original <em>accuracy</em> attribute is inherited without change.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {
        DV_AMOUNT[id4] ∈ {
            accuracy ∈ {|-0.05..0.05|}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value ∈ {
        DV_QUANTITY[id4] ∈ {
            magnitude ∈ {|2.0..10.0|}
            units ∈ {“mmol/ml”}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the same manner, an object node can be specialised into more than one subtype, where each such constraint selects a mutually exclusive subset of the instance space. The following example shows a specialisation of the <code>DV_AMOUNT</code> constraint above into two subtyped constraints.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value ∈ {
        DV_QUANTITY[id4] ∈ {
            magnitude ∈ {|2.0..10.0|}
            units ∈ {“mmol/ml”}
        }
        DV_PROPORTION[id5] ∈ {
            numerator ∈ {|2.0..10.0|}
            type ∈ {pk_unitary}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, instance data may only be of type <code>DV_QUANTITY</code> or <code>DV_PROPORTION</code>, and must satisfy the respective constraints for those types.</p>
</div>
<div class="paragraph">
<p>A final variant of subtyping is when the intention is to constraint the data to a supertype with exceptions for particular subtypes. In this case, constraints based on subtypes are matched first, with the constraint based on the parent type being used to constrain all other subtypes. The following example constrains data at the <em>value</em> node to be:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>an instance of <code>DV_QUANTITY</code> with <em>magnitude</em> within the given range etc;</p>
</li>
<li>
<p>an instance of <code>DV_PROPORTION</code> with <em>numerator</em> in the given range etc;</p>
</li>
<li>
<p>an instance of any other subtype of <code>DV_AMOUNT</code> , with <em>accuracy</em> in the given range.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value ∈ {
        DV_QUANTITY[id4] ∈ {
            magnitude ∈ {|2.0..10.0|}
            units ∈ {“mmol/ml”}
        }
        DV_PROPORTION[id5] ∈ {
            numerator ∈ {|2.0..10.0|}
            type ∈ {pk_unitary}
        }
        DV_AMOUNT[id6] ∈ {
            accuracy ∈ {|-0.05..0.05|}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A typical use of this kind of refinement in openEHR would be to add an alternative for a <code>DV_CODED_TEXT</code> constraint for a specific terminology to an existing <code>DV_TEXT</code> constraint in a <em>name</em> attribute, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    name ∈ {
        DV_CODED_TEXT[id79] ∈ {
            defining_code ∈ {[Snomed_ct::]}
        }
        DV_TEXT[id14] ∈ {
            value ∈ {/.+/} -- non-empty string
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>All of the above specialisation based on reference model subtypes can be applied in the same way to identified object constraints.</p>
</div>
</div>
<div class="sect3">
<h4 id="_terminology_external_subset_redefinition">10.5.4. Terminology External Subset Redefinition</h4>
<div class="paragraph">
<p>A terminology external subset constraint is used to set the value set of a coded term to be one defined externally in a terminology, specified in the <code>term_definitions</code> sub-section of the <code>terminology</code> section, as shown in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    definition
        ELEMENT [id79] ∈ { -- cuff size
            value ∈ {
                DV_CODED_TEXT[id4] ∈ {
                    defining_code ∈ {[local::ac1]}
                }
            }
        }
    terminology
        term_bindings = &lt;
            [“snomed_ct”]    = &lt;
                items = &lt;
                    [“ac1”] = &lt;http://terminology.org?query_id=12345&gt;
                &gt;
            &gt;
        &gt;     </code></pre>
</div>
</div>
<div class="paragraph">
<p>In a specialisation of the archetype, the placeholder constraint can be redefined in two different ways. The first is by redefinition of the placeholder constraint to a narrower one. This is a achieved by redefining the constraint code, and adding a new definition in the ontology of the specialised archetype, as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    definition
        ELEMENT [id79] ∈ {               -- cuff size
            value ∈ {
                DV_CODED_TEXT[id14] ∈ {
                    defining_code ∈ {[local::ac1.1]}
                }
            }
        }
    terminology
        term_bindings = &lt;
            [“snomed_ct”]    = &lt;
                items = &lt;
                    [“ac1.1”] = &lt;http://terminology.org?query_id=12345-1&gt;
                &gt;
            &gt;
        &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second kind of redefinition is by an inline constraint of the same primitive ADL type <code>TERMINOLOGY_CODE</code> .</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT [id79] ∈ { -- cuff size
        value ∈ {
            DV_CODED_TEXT[id14] ∈ {
                defining_code ∈ {
                    [local::
                    at22,   -- child cuff
                    at23]    -- infant cuff
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>These redefinitions are assumed to be valid, although it is not directly validatable unless the terminology subset is available to the tooling.</p>
</div>
<div class="paragraph">
<p>A third variation on the same semantics is when a term constraint is used as a redefinition of a previously unconstrained term code, e.g. as illustrated by the following fragment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id79] ∈ { -- cuff size
        value ∈ {
            DV_CODED_TEXT[id14] ∈ {*}
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_internal_reference_proxy_object_redefinition">10.5.5. Internal Reference (Proxy Object) Redefinition</h4>
<div class="paragraph">
<p>An archetype proxy object, or <code>use_node</code> constraint is used to refer to an object constraint from a point elsewhere in the archetype. These references can be redefined in two ways, as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Target redefinition: the target constraint of reference may be itself redefined. The meaning for this is that all internal references now assume the redefined form.</p>
</li>
<li>
<p>Reference redefinition: specialised archetypes can redefine a use_node object into a normal inline concrete constraint that a) replaces the reference, and b) must be completely conformant to the structure which is the target of the original reference.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that if the intention is to redefine a structure referred to by <code>use_node</code> constraints, but to leave the constraints at the reference source points in form to which the reference points in the parent level, each <code>use_node</code> reference needs to be manually redefined as a copy of the target structure originally pointed to.</p>
</div>
<div class="paragraph">
<p>The second type of redefinition above is the most common, and is shown in the following example.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ENTRY[id1]∈ {
        data ∈ {
            CLUSTER[id2] ∈ {
                items ∈ {
                    -- etc --
                }
            }
            use_node CLUSTER[id3] /data[id2]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ENTRY [id1.1]∈ {
        /data[id3]/items ∈ {
            ELEMENT [id0.1] ∈ {
                -- etc --
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remembering that the parent archetype is essentially just definition two sibling object structures with the identifiers <code>id1</code> and <code>id2</code> (defined by the use_node reference), the child is redefining the id2 node (it could also have redefined the id1 node as well). The result of this in the flattened output is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ENTRY [id1.1] ∈ {
        data ∈ {
            CLUSTER[id2] ∈ {
                items ∈ {
                    -- etc --
                }
            }
            CLUSTER[id3] ∈ {
                items ∈ {
                    ELEMENT[id0.1] ∈ {
                        -- etc --
                    }
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is one subtlety to do with redefinition of occurrences of a use_node target: if it is redefined to have occurrences matches <code>{0}</code> (normally only in a template), then the effect of this is the same on any use_node reference definitions, unless they define occurrences locally at the reference point. The chance of this actually occurring appears vaninshingly small, since by the time ‘exclusion’ occurrence redefinition is being done in templates, use_node object definitions are most likely to have been locally overridden anyway.</p>
</div>
<div class="paragraph">
<p>Lastly, one further type of redefinition appears technically possible, but seems of no utility, and is therefore not part of ADL:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Reference re-targetting: an internal reference could potentially be redefined into a reference to a different target whose structure conforms to the original target.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_external_reference_redefinition">10.5.6. External Reference Redefinition</h4>
<div class="paragraph">
<p>External reference nodes can be redefined by another external reference node, in the following ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>exclusion - using the occurrences matches <code>{0}</code> method;</p>
</li>
<li>
<p>semantic refinement of the node identifier in the normal way;</p>
</li>
<li>
<p>redefinition of the reference to another archetype which is a specialisation of the one from the corresponding reference node in the flat parent.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_slot_filling_and_redefinition">10.5.7. Slot Filling and Redefinition</h4>
<div class="paragraph">
<p>Slots and slot-filling is a special kind of ‘redefinition’ in ADL. Logically, an archetype slot constraint is understood to consist of a) its definition (what archetypes are allowed to fill it) and b) current filler list. At the point of definition, the current fillers is invariably empty. More specialised descendants can progressively add or replace fillers for a slot. Thus, the appearance of an object node whose identifier is the specialisation of a slot node in the flat parent is always understood as a partial specialisation for it.</p>
</div>
<div class="paragraph">
<p>In other words, a slot within an archetype can be specialised by any combination of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>one or more slot-fillers;</p>
</li>
<li>
<p>a redefinition of the slot itself, either to narrow the set of archetypes it matches, or to close it to filling in either further specialisations, or at runtime, or to remove it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both types of redefinition are generally used by templates rather than published archetypes, since the business of filling slots is mostly related to local use-case specific uses of archetypes rather than part of the initial design.</p>
</div>
<div class="paragraph">
<p>The following example shows a slot from a <code>SECTION</code> archetype for the concept ‘history_medical_surgical’ archetype.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id1] ∈ {    -- Past history
        items ∈ {
            allow_archetype EVALUATION[id2] ∈ { -- Past problems
                include
                    archetype_id/value ∈ {
                        /openEHR-EHR-EVALUATION\.clinical_synopsis\.v1
                            |openEHR-EHR-EVALUATION\.excluded(-[a-z0-9_]+)*\.v1
                            |openEHR-EHR-EVALUATION\.injury\.v1
                            |openEHR-EHR-EVALUATION\.problem(-[a-z0-9_]+)*\.v1/}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>This slot specification allows <code>EVALUATION</code> archetypes for the concepts ‘clinical synopsis’, various kinds of ‘exclusions’ and ‘problems’, and ‘injury’ to be used, and no others. The following fragment of ADL shows how the slot is filled in a template, using the keyword <code>use_archetype</code>. In this syntax, the node identification is a variation on the normal archetype id-codes. Within the template, the identifier of the used archetype is also the identifier of that node. However, the original at-code (if defined) must also be mentioned, so as to indicate which slot the used archetype is filling. Templates may also be used to fill slots in the same way. Thus, in the following example, two archetypes and a template are designated to fill the id2 slot defined in the above fragment of ADL. The slot definition is not mentioned, so it remains unchanged, i.e. ‘open’.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    SECTION[id1] ∈ {    -- Past history
        /items ∈ {
            use_archetype EVALUATION[id2, org.openehr::openEHR-EHR-EVALUATION.problem.v1]
            use_template EVALUATION[id2, uk.nhs.cfh::openEHR-EHR-EVALUATION.t_ed_diagnosis.v1]
            use_archetype EVALUATION[id2, org.openehr::openEHR-EHR-EVALUATION.clin_synopsis.v1]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since node identifiers are only required to disambiguate multiple sibling nodes, they may not exist on all nodes in a typical archetype. It is therefore possible to have a slot that carries no node identifier (e.g. due to being under a single-valued attribute). A <code>use_archetype</code> specification within a template will accordingly only mention the archetype identifier, with no node id, as per the following example (archetype followed by a template).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ACTIVITY[id1] ∈ {   -- Medication activity
        description ∈ {
            allow_archetype ITEM_TREE[id4] ∈ {
                include
                    archetype_id/value ∈ {...}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>A template containing a filler for this slot would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_archetype INSTRUCTION[openEHR-EHR-INSTRUCTION.medication.v1] ∈ {
        /activities[id1]/description ∈ {
            use_archetype ITEM_TREE[id4,
                                org.openehr::openEHR-EHR-                               ITEM_TREE.medication.v1]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Slots can be recursively filled in the above fashion, according to the possibilities offered by the chosen archetypes or templates. The following ADL fragment shows two levels of slot-filling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_archetype COMPOSITION[openEHR-EHR-COMPOSITION.xxx.v1] ∈ {
        /content ∈ {
            use_archetype SECTION[id1, org.openehr::openEHR-EHR-SECTION.yyy.v1 ∈ {
                /items ∈ {
                    use_template EVALUATION[id2, uk.nhs.cfh::openEHR-EHR-EVALUATION.t_xx.v1]
                    use_archetype EVALUATION[id2, org.openehr::openEHR-EHR-EVALUATION.xx.v1]
                    use_archetype EVALUATION[id3, org.openehr::openEHR-EHR-EVALUATION.xx.v1]
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the above the archetype fillers are specified as published archetypes, but in reality, it is far more likely that template-specific specialisations of these archetypes would be used. The identification and organisation of such archetypes is described in the openEHR Templates document.</p>
</div>
<div class="paragraph">
<p>In addition to or instead of specifying slot fillers, it is possible in a slot specialisation to narrow the slot definition, or to close it. If fillers are specified, closing the slot as well is typical. The latter is done by including an overridden version of the archetype slot object itself, with the ‘closed’ constraint set, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    use_archetype SECTION[org.openehr::openEHR-EHR-SECTION.history_medical_surgical.v1] ∈ {
        /items ∈ {
            use_archetype EVALUATION[id2] openEHR-EHR-EVALUATION.problem.v1
            allow_archetype EVALUATION[id2] closed
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Narrowing the slot is done with a replacement ` allow_archetype` statement containing a narrowed set of match criteria.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unconstrained_attributes">10.5.8. Unconstrained Attributes</h4>
<div class="paragraph">
<p>The <code>use_archetype</code> keyword can be used to specify child object constraints under any attribute in the reference model that is so far unconstrained by the flat parent of an archetype or template. Technically this could occur in any kind of archetype but would normally be in a specialised archetype or template. This is no more than the standard use of an ‘external reference’ (see <a href="#_external_references">External References</a>).</p>
</div>
<div class="paragraph">
<p>Any reference specified will have no slot, and is instead validity-checked against the appropriate part of the underlying reference model.</p>
</div>
<div class="paragraph">
<p>The following example from the openEHR reference model is typical.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    COMPOSITION[id1] matches {               -- Referral document
        category matches {...}
        context matches {
            EVENT_CONTEXT[id2] matches {
                participations matches {...}
                other_context matches {...}
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above cADL block partially specifies a <code>COMPOSITION</code> object, via constraints (often including slot definitions) on the <em>category</em> and <em>context</em> attributes defined on that class in the reference model. However, the attribute of most interest in a <code>COMPOSITION</code> object is usually the <em>content</em> attribute, which is not constrained at all here. The reference model defines it to be of type <code>List&lt;CONTENT_ITEM&gt;</code> .</p>
</div>
<div class="paragraph">
<p>This kind of constraint is similar to ‘slot-filling’, except there is no slot providing any constraint, and typically occurs . Using an external reference for in an unarchetyped part of the RM structure is almost always done in specialised archetypes or templates, but is technically valid in a top-level archetype.</p>
</div>
<div class="paragraph">
<p>The following example shows the use of <code>use_archetype</code> within a specialised archetype.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    COMPOSITION[id1.1] matches {        -- Referral document (specialisation)
        content matches {
            use_archetype SECTION[id2, openEHR-EHR-SECTION.history_medical_surgical.v1]
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_primitive_object_redefinition">10.5.9. Primitive Object Redefinition</h4>
<div class="paragraph">
<p>For terminal objects (i.e. elements of the type <code>C_PRIMITIVE_OBJECT</code>) redefinition consists of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>redefined value ranges or sets using a narrower value range or set;</p>
</li>
<li>
<p>exclusions on the previously defined value ranges or sets which have the effect of narrowing the original range or set.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows a redefined real value range.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    value ∈ {
        DV_QUANTITY[id3] ∈ {
            magnitude ∈ {|2.0..10.0|}
            units ∈ {“mmol/ml”}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../value ∈ {
        DV_QUANTITY[id3] ∈ {
            magnitude ∈ {|4.0..6.5|}
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a redefined <code>CODE_PHRASE</code> value set.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id7] occurrences ∈ {0..*} ∈ {   -- System
        name ∈ {
            DV_CODED_TEXT[id14] ∈ {
                defining_code ∈ {
                    [local::
                    at8,    -- Cardiovascular system
                    at9,    -- Respiratory system
                    at10,   -- Gastro-intestinal system
                    at11,   -- Reticulo-Endothelial system
                    at12,   -- Genito-urinary system
                    at13,   -- Endocrine System
                    at14,   -- Central nervous system
                    at15]    -- Musculoskeletal system
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../name[id14]/defining_code ∈ {
        [local::
        at10,   -- Gastro-intestinal system
        at11,   -- Reticulo-Endothelial system
        at12,   -- Genito-urinary system
        at13,   -- Endocrine System
        at15]    -- Musculoskeletal system
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following example, the exclusion operator ∉ (text form: ‘not matches’) is used to remove particular values from a value set.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    ELEMENT[id7] occurrences ∈ {0..*} ∈ {   -- System
        name ∈ {
            DV_CODED_TEXT[id14] ∈ {
                defining_code ∈ {
                    [local::
                    at8,    -- Cardiovascular system
                    at9,    -- Respiratory system
                    at10,   -- Gastro-intestinal system
                    at11,   -- Reticulo-Endothelial system
                    at12,   -- Genito-urinary system
                    at13,   -- Endocrine System
                    at14,   -- Central nervous system
                    at15]    -- Musculoskeletal system
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specialised archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    .../name[id14]/defining_code ∉ {
        [local::
        at12,   -- Genito-urinary system
        at13]   -- Endocrine System
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_10_5_10_tuple_redefinition">10.5.10. 10.5.10 Tuple Redefinition</h4>
<div class="paragraph">
<p>Tuple constraints can be redefined by narrowing, as for other primitive constraints. A typical example is as follows.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    DV_QUANTITY[id42] ∈ {
        property ∈ {[at29]}
        [magnitude, units] ∈ {
            [{|&gt;=50.0|}, {&quot;mm[Hg]&quot;}]
            [{|&gt;=68.0|}, {&quot;cm[H20]&quot;}]
        }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    DV_QUANTITY[id42] ∈ {
        property ∈ {[at29]}
        [magnitude, units] ∈ {
            [{|&gt;=50.0|}, {&quot;mm[Hg]&quot;}]
        }
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rules">10.6. Rules</h3>
<div class="paragraph">
<p>The <code>rules</code> section in an archetype consists of definitions and assertion statements. Assertions in archetypes have the effect of further reducing the instance space that conforms to an archetype by specifying relationships between values that must hold. For example the main part of an archetype may specify that the existence of a subtree, containing data points related to ‘tobacco use’ for example, is dependent on the value of another data point representing ‘smoker?’ being True.</p>
</div>
<div class="paragraph">
<p>In specialised archetypes, further invariants can be added, but existing ones cannot be changed. New invariants cannot logically contradict existing invariants and are considered to be logically related to invariants from the flat parent by the logical semi-strict operator ‘and then’.</p>
</div>
</div>
<div class="sect2">
<h3 id="_languages">10.7. Languages</h3>
<div class="paragraph">
<p>A specialised archetype or template is only required to have one language in common with its flat precursor, enabling a flat output containing this language. This supports the common situation in which an international standard archetype with numerous translations is used as a basis for further specialisation in a particular country or project. Clearly, the latter has no need of, and quite probably no capability for including all the original translations in the specialisation.</p>
</div>
<div class="paragraph">
<p>However, if the specialised archetype language is not present at all in the parent flat, it will need to be added to the archetypes in the specialisation lineage first.</p>
</div>
<div class="paragraph">
<p>The languages present in the flat output will therefore be those languages available in both the flat parent (implying all previous archetypes / templates in the specialisation lineage) and the new specialisation. Any new languages introduced in the latter not available in the flat parent will be discarded.</p>
</div>
<div class="paragraph">
<p>Locale-specific overrides can be introduced for any linguistic element in an archetype, including the terminology. Such an override has a language code conforming to a subset of the IETF RFC 5646 language tag standard (see <a href="#rfc5646">[rfc5646]</a>), namely the common 2-part language-region tag exemplified by ‘en-GB’ (British English), ‘pt-BR’ (Brazilian Portuguese), and so on. The tags are case-insensitive, but tools that create tags should follow the recommendation from the standard, which is that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>language tag is lowercase;</p>
</li>
<li>
<p>region tags are uppercase.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_description_section_2">10.8. Description Section</h3>
<div class="paragraph">
<p>The <code>description</code> section of a specialised archetype or template always replaces that of the parent in the flattened result. Tools could of course provide views of each part of the description back up the specialisation hierarchy if required.</p>
</div>
</div>
<div class="sect2">
<h3 id="_terminology">10.9. Terminology</h3>
<div class="paragraph">
<p>Specialisation in the <code>terminology</code> section manifests in terms of specialised and added terms in the <code>term_definitions</code> sub-section.</p>
</div>
<div class="paragraph">
<p>Value sets can be specialised, which has the effect in the flattened form of replacing the original rather than adding to it, as shown in the following example.</p>
</div>
<div class="paragraph">
<p>Parent archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    archetype (adl_version=2.0.0; generated)
        openEHR-EHR-EVALUATION.code_list_parent.v1.0.0
    language
        original_language = &lt;[ISO_639-1::en]&gt;
    description
        ...
     
    definition
        EVALUATION[id1] matches {   -- General statement of exclusions or states
            data matches {
                ITEM_TREE[id2] matches {
                    items cardinality matches {1..*; unordered} matches {
                        ELEMENT[id3] occurrences matches {1..*} matches {   -- Statement
                            value matches {
                                DV_CODED_TEXT[id4] matches {
                                    defining_code matches {[ac1]}       -- Statement
                                }
                            }
                        }
                    }
                }
            }
        }
     
    terminology
        term_definitions = &lt;
            [&quot;en&quot;] = &lt;
                [&quot;id1&quot;] = &lt;
                    text = &lt;&quot;General statement of exclusions or states&quot;&gt;
                    description = &lt;&quot;A category of ... have been excluded&quot;&gt;
                &gt;
                [&quot;id3&quot;] = &lt;
                    text = &lt;&quot;Statement&quot;&gt;
                    description = &lt;&quot;The statement about what is excluded&quot;&gt;
                &gt;
                [&quot;at4&quot;] = &lt;
                    text = &lt;&quot;No significant illness&quot;&gt;
                    description = &lt;&quot;The person ... condition&quot;&gt;
                &gt;
                [&quot;at5&quot;] = &lt;
                    text = &lt;&quot;No significant past history&quot;&gt;
                    description = &lt;&quot;The person has no ... history&quot;&gt;
                &gt;
                ...
                [&quot;at13&quot;] = &lt;
                    text = &lt;&quot;No relevant family history&quot;&gt;
                    description = &lt;&quot;No family history ... situation&quot;&gt;
                &gt;
                [&quot;at14&quot;] = &lt;
                    text = &lt;&quot;No known allergies&quot;&gt;
                    description = &lt;&quot;No allergies known to any ... or substances&quot;&gt;
                &gt;
                [&quot;ac1&quot;] = &lt;
                    text = &lt;&quot;Statement&quot;&gt;
                    description = &lt;&quot;The statement about what is excluded&quot;&gt;
                &gt;
            &gt;
        &gt;
        value_sets = &lt;
            [&quot;ac1&quot;] = &lt;
                id = &lt;&quot;ac1&quot;&gt;
                members = &lt;&quot;at4&quot;, &quot;at5&quot;, &quot;at6&quot;, &quot;at7&quot;, &quot;at10&quot;, &quot;at13&quot;, &quot;at14&quot;, &quot;at11&quot;, &quot;at12&quot;, &quot;at8&quot;, &quot;at9&quot;&gt;
            &gt;
        &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Flattened child archetype:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="cadl">    archetype (adl_version=2.0.0; generated)
        openEHR-EHR-EVALUATION.code_list_constrained.v1.0.0
    ...
    terminology
        term_definitions = &lt;
            [&quot;en&quot;] = &lt;
                [&quot;id1&quot;] = &lt;
                    text = &lt;&quot;General statement of exclusions or states&quot;&gt;
                    description = &lt;&quot;A category of ...have been excluded&quot;&gt;
                &gt;
                [&quot;id3&quot;] = &lt;
                    text = &lt;&quot;Statement&quot;&gt;
                    description = &lt;&quot;The statement about what is excluded&quot;&gt;
                &gt;
                ...
                [&quot;at13&quot;] = &lt;
                    text = &lt;&quot;No relevant family history&quot;&gt;
                    description = &lt;&quot;No family history relevant .. situation&quot;&gt;
                &gt;
                [&quot;ac1&quot;] = &lt;
                    text = &lt;&quot;Statement&quot;&gt;
                    description = &lt;&quot;The statement about what is excluded&quot;&gt;
                &gt;
                [&quot;ac1.1&quot;] = &lt;
                    text = &lt;&quot;(added by post-parse processor)&quot;&gt;
                    description = &lt;&quot;(added by post-parse processor)&quot;&gt;
                &gt;
                [&quot;id1.1&quot;] = &lt;
                    text = &lt;&quot;Adverse reaction exclusions&quot;&gt;
                    description = &lt;&quot;A category of ... of adverse reaction&quot;&gt;
                &gt;
            &gt;
        &gt;
        value_sets = &lt;
            [&quot;ac1.1&quot;] = &lt;
                id = &lt;&quot;ac1.1&quot;&gt;
                members = &lt;&quot;at6&quot;, &quot;at7&quot;, &quot;at10&quot;, &quot;at13&quot;&gt;
            &gt;
        &gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flattened result always includes the sum of term definitions from the parent.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bindings">10.10. Bindings</h3>
<div class="paragraph">
<p>Bindings in a specialised archetype can include a binding to an at-code or ac-code defined in the current archetype or any parent archetype. A binding may be defined that overrides one from the flat parent, in which case the binding target - a term (at-code binding) or value set (ac-code binding) should be a proper specialised concept or subset respectively of the binding they replace. Since the binding target is an external code or subset, authoring tools need a connection to an appropriate terminology service to validate the relationship.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_relationship_of_adl_to_other_formalisms">Appendix A: Relationship of ADL to Other Formalisms</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_9">A.1. Overview</h3>
<div class="paragraph">
<p>Whenever a new formalism is defined, it is reasonable to ask the question: are there not existing formalisms which would do the same job? Research to date has shown that in fact, no other formalism has been designed for the same use, and none easily express ADL’s semantics. During ADL’s initial development, it was felt that there was great value in analysing the problem space very carefully, and constructing an abstract syntax exactly matched to the solution, rather than attempting to use some other formalism - undoubtedly designed for a different purpose - to try and express the semantics of archetypes, or worse, to start with an XML-based exchange format, which often leads to the conflation of abstract and concrete representational semantics. Instead, the approach used has paid off, in that the resulting syntax is very simple and powerful, and in fact has allowed mappings to other formalisms to be more correctly defined and understood. The following sections compare ADL to other formalisms and show how it is different.</p>
</div>
</div>
<div class="sect2">
<h3 id="_constraint_syntaxes">A.2. Constraint Syntaxes</h3>
<div class="sect3">
<h4 id="_omg_ocl_object_constraint_language">A.2.1. OMG OCL (Object Constraint Language)</h4>
<div class="paragraph">
<p>The OMG’s Object Constraint Language (OCL) appears at first glance to be an obvious contender for writing archetypes. However, its designed use is to write constraints on object models, rather than on data, which is what archetypes are about. As a concrete example, OCL can be used to make statements about the actors attribute of a class Company - e.g. that actors must exist and contain the Actor who is the lead of Company. However, if used in the normal way to write constraints on a class model, it cannot describe the notion that for a particular kind of (acting) company, such as ‘itinerant jugglers’, there must be at least four actors, each of whom have among their capabilities ‘advanced juggling’, plus an Actor who has skill ‘musician’. This is because doing so would constrain all instances of the class Company to conform to the specific configuration of instances corresponding to actors and jugglers, when what is intended is to allow a myriad of possibilities. ADL provides the ability to create numerous archetypes, each describing in detail a concrete configuration of instances of type Company.  OCL’s constraint types include function pre- and post-conditions, and class invariants. There is no structural character to the syntax - all statements are essentially first-order predicate logic statements about elements in models expressed in UML, and are related to parts of a model by ‘context’ statements.  This makes it impossible to use OCL to express an archetype in a structural way which is natural to domain experts. OCL also has some flaws, described by Beale <a href="#beale_ocl">[beale_ocl]</a>.  However, OCL is in fact relevant to ADL. ADL archetypes include invariants (and one day, might include pre- and post-conditions). Currently these are expressed in a syntax very similar to OCL, with minor differences. The exact definition of the ADL invariant syntax in the future will depend somewhat on the progress of OCL through the OMG standards process.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ontology_formalisms">A.3. Ontology Formalisms</h3>
<div class="sect3">
<h4 id="_owl_web_ontology_language">A.3.1. OWL (Web Ontology Language)</h4>
<div class="paragraph">
<p>The Web Ontology Language (OWL) <a href="#w3c_xpath">[w3c_xpath]</a> is a W3C initiative for defining Web-enabled ontologies which aim to allow the building of the “Semantic Web”. OWL has an abstract syntax <a href="#w3c_owl">[w3c_owl]</a>, developed</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references">References</h2>
<div class="sectionbody">
<div class="olist bibliography">
<ol class="bibliography">
<li>
<p><a id="Beale_2000"></a>[Beale_2000] Beale T. <strong>Archetypes: Constraint-based Domain Models for Future-proof Information Systems.</strong> 2000.  Available at <a href="http://www.openehr.org/files/resources/publications/archetypes/archetypes_beale_web_2000.pdf" class="bare">http://www.openehr.org/files/resources/publications/archetypes/archetypes_beale_web_2000.pdf</a> .</p>
</li>
<li>
<p><a id="Beale_2002"></a>[Beale_2002] Beale T. <strong>Archetypes: Constraint-based Domain Models for Future-proof Information Systems.</strong> Eleventh OOPSLA Workshop on Behavioral Semantics: Serving the Customer (Seattle, Washington, USA, November 4, 2002). Edited by Kenneth Baclawski and Haim Kilov. Northeastern University, Boston, 2002, pp. 16-32. Available at <a href="http://www.openehr.org/files/resources/publications/archetypes/archetypes_beale_oopsla_2002.pdf" class="bare">http://www.openehr.org/files/resources/publications/archetypes/archetypes_beale_oopsla_2002.pdf</a> .</p>
</li>
<li>
<p><a id="cov_contra"></a>[cov_contra] Wikipedia. <strong>Covariance and contravariance.</strong> See <a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science" class="bare">https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science</a>) .</p>
</li>
<li>
<p><a id="uri_syntax"></a>[uri_syntax] Uniform Resource Identifier (URI): Generic Syntax, Internet proposed standard, January 2005; see <a href="http://www.ietf.org/rfc/rfc3986.txt" class="bare">http://www.ietf.org/rfc/rfc3986.txt</a> .</p>
</li>
<li>
<p><a id="rfc2781"></a>[rfc2781] IETF. <strong>RFC 2781.</strong> See <a href="http://tools.ietf.org/html/rfc2781" class="bare">http://tools.ietf.org/html/rfc2781</a>.</p>
</li>
<li>
<p><a id="rfc5646"></a>[rfc5646] IETF. <strong>RFC 5646.</strong> Available at <a href="http://tools.ietf.org/html/rfc5646" class="bare">http://tools.ietf.org/html/rfc5646</a>.</p>
</li>
<li>
<p><a id="openehr_aom"></a>[openehr_aom] The openEHR Foundation. <strong>The openEHR Archetype Object Model.</strong> See <a href="http://www.openehr.org/releases/trunk/architecture/am/aom2.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/am/aom2.pdf</a> .</p>
</li>
<li>
<p><a id="beale_ocl"></a>[beale_ocl] Beale T. A Short Review of OCL. See <a href="http://www.deepthought.com.au/it/ocl_review.html" class="bare">http://www.deepthought.com.au/it/ocl_review.html</a>.</p>
</li>
<li>
<p><a id="EHR_IM"></a>[EHR_IM] The openEHR Foundation. <strong>The EHR Information Model</strong>. <a href="http://www.openehr.org/releases/trunk/architecture/rm/ehr_im.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/rm/ehr_im.pdf</a> .</p>
</li>
<li>
<p>Dolin R, Elkin P, Mead C et al. HL7 Templates Proposal. 2002. Available at <a href="http://www.hl7.org" class="bare">http://www.hl7.org</a> .</p>
</li>
<li>
<p>Heard S, Beale T. Archetype Definitions and Principles. See <a href="http://www.openehr.org/repositories/spec-dev/latest/publishing/architecture/archetypes/principles/REV_HIST.html" class="bare">http://www.openehr.org/repositories/spec-dev/latest/publishing/architecture/archetypes/principles/REV_HIST.html</a> .</p>
</li>
<li>
<p>Heard S, Beale T. The openEHR Archetype System. See <a href="http://www.openehr.org/repositories/spec-dev/latest/publishing/architecture/archetypes/system/REV_HIST.html" class="bare">http://www.openehr.org/repositories/spec-dev/latest/publishing/architecture/archetypes/system/REV_HIST.html</a> .</p>
</li>
<li>
<p><a id="Hein"></a>[Hein] Hein J L. Discrete Structures, Logic and Computability (2nd Ed). Jones and Bartlett 2002.</p>
</li>
<li>
<p><a id="Kilov_Ross"></a>[Kilov_Ross] Kilov H, Ross J. <strong>Information Modelling: an Object-Oriented Approach.</strong> Prentice Hall 1994.</p>
</li>
<li>
<p><a id="Gruber"></a>[Gruber] Gruber T R. <strong>Toward Principles for the Design of Ontologies Used for Knowledge Sharing.</strong> in Formal Ontology in Conceptual Analysis and Knowledge Representation. Eds Guarino N, Poli R. Kluwer Academic Publishers. 1993 (Aug revision).</p>
</li>
<li>
<p>Martin P. <strong>Translations between UML, OWL, KIF and the WebKB-2 languages (For-Taxonomy, Frame-CG, Formalized English)</strong>. May/June 2003. Available at <a href="http://www.webkb.org/doc/model/comparisons.html" class="bare">http://www.webkb.org/doc/model/comparisons.html</a> as at Aug 2004.</p>
</li>
<li>
<p><a id="Eiffel"></a>[Eiffel] Meyer B. <strong>Eiffel the Language (2nd Ed).</strong> Prentice Hall, 1992.</p>
</li>
<li>
<p><a id="Horrocks_owl"></a>[Horrocks_owl] Patel-Schneider P, Horrocks I, Hayes P. <strong>OWL Web Ontology Language Semantics and Abstract Syntax.</strong> See <a href="http://w3c.org/TR/owl-semantics/" class="bare">http://w3c.org/TR/owl-semantics/</a> .</p>
</li>
<li>
<p><a id="Object_Z"></a>[Object_Z] Smith G. The Object Z Specification Language. Kluwer Academic Publishers 2000. See <a href="http://www.itee.uq.edu.au/~smith/objectz.html" class="bare">http://www.itee.uq.edu.au/~smith/objectz.html</a> .</p>
</li>
<li>
<p><a id="Perl_regex"></a>[Perl_regex] Perl.org. Perl Regular Expressions. Available at <a href="http://perldoc.perl.org/perlre.html" class="bare">http://perldoc.perl.org/perlre.html</a> .</p>
</li>
<li>
<p><a id="IHTSDO"></a>[IHTSDO] International Health Terminology Standards Development Organisation, <a href="http://www.ihtsdo.org" class="bare">http://www.ihtsdo.org</a>.</p>
</li>
<li>
<p><a id="Sowa"></a>[Sowa] Sowa J F. <strong>Knowledge Representation: Logical, philosophical and Computational Foundations</strong>. 2000, Brooks/Cole, California.</p>
</li>
<li>
<p>HL7 v3 RIM. See <a href="http://www.hl7.org" class="bare">http://www.hl7.org</a> .</p>
</li>
<li>
<p>HL7 Templates Proposal. See <a href="http://www.hl7.org" class="bare">http://www.hl7.org</a> .</p>
</li>
<li>
<p><a id="openehr_ehr"></a>[openehr_ehr] openEHR. <strong>EHR Information Model.</strong> See <a href="http://www.openehr.org/releases/trunk/architecture/rm/ehr_im.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/rm/ehr_im.pdf</a>.</p>
</li>
<li>
<p><a id="openehr_data_types"></a>[openehr_data_types] openEHR. <strong>Data Types Information Model.</strong> See <a href="http://www.openehr.org/releases/trunk/architecture/rm/data_types_im.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/rm/data_types_im.pdf</a>.</p>
</li>
<li>
<p><a id="knowledge_artefact_identification"></a>[knowledge_artefact_identification] The openEHR Foundation. <strong>Knowledge Artefact Identification specification.</strong> Available at <a href="http://www.openehr.org/releases/trunk/architecture/am/knowledge_id_system.pdf" class="bare">http://www.openehr.org/releases/trunk/architecture/am/knowledge_id_system.pdf</a> .</p>
</li>
<li>
<p><a id="perl_regex"></a>[perl_regex] Perl Regular Expressions. See <a href="http://www.perldoc.com/perl5.6/pod/perlre.html" class="bare">http://www.perldoc.com/perl5.6/pod/perlre.html</a> .</p>
</li>
<li>
<p>SynEx project, UCL. <a href="http://www.chime.ucl.ac.uk/HealthI/SynEx/" class="bare">http://www.chime.ucl.ac.uk/HealthI/SynEx/</a> .</p>
</li>
<li>
<p><a id="w3c_owl"></a>[w3c_owl] W3C. <strong>OWL - the Web Ontology Language</strong>. See <a href="http://www.w3.org/TR/2003/CR-owl-ref-20030818/" class="bare">http://www.w3.org/TR/2003/CR-owl-ref-20030818/</a> .</p>
</li>
<li>
<p><a id="w3c_xpath"></a>[w3c_xpath] W3C. <strong>XML Path Language</strong>. See <a href="http://w3c.org/TR/xpath" class="bare">http://w3c.org/TR/xpath</a> .</p>
</li>
<li>
<p><a id="WHO_ICD"></a>[WHO_ICD] World Health Organisation (WHO). <strong>International Classification of Diseases (ICD).</strong> See: <a href="http://www.who.int/classifications/icd/en/" class="bare">http://www.who.int/classifications/icd/en/</a> .</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-06-30 21:22:54 BST
</div>
</div>
</body>
</html>